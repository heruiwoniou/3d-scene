var An=Object.defineProperty;var Pn=(m,t,e)=>t in m?An(m,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):m[t]=e;var q=(m,t,e)=>Pn(m,typeof t!="symbol"?t+"":t,e);import*as G from"three";import{Mesh as sn,ShaderMaterial as Fn,BackSide as In,UniformsUtils as zn,BoxGeometry as Bn,Vector3 as nt,Quaternion as xt,Matrix4 as U,Vector4 as jt,Curve as Rn,Euler as Pt,Loader as we,LoaderUtils as Ln,FileLoader as kn,TextureLoader as Nn,RepeatWrapping as Ie,ClampToEdgeWrapping as ze,Texture as _n,MeshPhongMaterial as $t,MeshLambertMaterial as On,ColorManagement as Ct,Color as bt,SRGBColorSpace as it,EquirectangularReflectionMapping as Dn,Group as Be,Bone as Re,PropertyBinding as se,Object3D as Kt,PerspectiveCamera as qn,PointLight as Le,MathUtils as tt,SpotLight as Vn,DirectionalLight as Wn,SkinnedMesh as jn,LineBasicMaterial as Gn,Line as Hn,Skeleton as Un,AmbientLight as Xn,BufferGeometry as ae,Float32BufferAttribute as Bt,Uint16BufferAttribute as Yn,Matrix3 as $n,Vector2 as Kn,ShapeUtils as Zn,AnimationClip as Qn,VectorKeyframeTrack as Jn,QuaternionKeyframeTrack as ke,NumberKeyframeTrack as ts,LoadingManager as es}from"three";(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function e(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(s){if(s.ep)return;s.ep=!0;const i=e(s);fetch(s.href,i)}})();class ht{constructor(t){t===void 0&&(t=[0,0,0,0,0,0,0,0,0]),this.elements=t}identity(){const t=this.elements;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1}setZero(){const t=this.elements;t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0}setTrace(t){const e=this.elements;e[0]=t.x,e[4]=t.y,e[8]=t.z}getTrace(t){t===void 0&&(t=new d);const e=this.elements;return t.x=e[0],t.y=e[4],t.z=e[8],t}vmult(t,e){e===void 0&&(e=new d);const n=this.elements,s=t.x,i=t.y,o=t.z;return e.x=n[0]*s+n[1]*i+n[2]*o,e.y=n[3]*s+n[4]*i+n[5]*o,e.z=n[6]*s+n[7]*i+n[8]*o,e}smult(t){for(let e=0;e<this.elements.length;e++)this.elements[e]*=t}mmult(t,e){e===void 0&&(e=new ht);const n=this.elements,s=t.elements,i=e.elements,o=n[0],r=n[1],a=n[2],c=n[3],h=n[4],u=n[5],l=n[6],p=n[7],f=n[8],y=s[0],v=s[1],g=s[2],w=s[3],x=s[4],b=s[5],E=s[6],S=s[7],M=s[8];return i[0]=o*y+r*w+a*E,i[1]=o*v+r*x+a*S,i[2]=o*g+r*b+a*M,i[3]=c*y+h*w+u*E,i[4]=c*v+h*x+u*S,i[5]=c*g+h*b+u*M,i[6]=l*y+p*w+f*E,i[7]=l*v+p*x+f*S,i[8]=l*g+p*b+f*M,e}scale(t,e){e===void 0&&(e=new ht);const n=this.elements,s=e.elements;for(let i=0;i!==3;i++)s[3*i+0]=t.x*n[3*i+0],s[3*i+1]=t.y*n[3*i+1],s[3*i+2]=t.z*n[3*i+2];return e}solve(t,e){e===void 0&&(e=new d);const n=3,s=4,i=[];let o,r;for(o=0;o<n*s;o++)i.push(0);for(o=0;o<3;o++)for(r=0;r<3;r++)i[o+s*r]=this.elements[o+3*r];i[3+4*0]=t.x,i[3+4*1]=t.y,i[3+4*2]=t.z;let a=3;const c=a;let h;const u=4;let l;do{if(o=c-a,i[o+s*o]===0){for(r=o+1;r<c;r++)if(i[o+s*r]!==0){h=u;do l=u-h,i[l+s*o]+=i[l+s*r];while(--h);break}}if(i[o+s*o]!==0)for(r=o+1;r<c;r++){const p=i[o+s*r]/i[o+s*o];h=u;do l=u-h,i[l+s*r]=l<=o?0:i[l+s*r]-i[l+s*o]*p;while(--h)}}while(--a);if(e.z=i[2*s+3]/i[2*s+2],e.y=(i[1*s+3]-i[1*s+2]*e.z)/i[1*s+1],e.x=(i[0*s+3]-i[0*s+2]*e.z-i[0*s+1]*e.y)/i[0*s+0],isNaN(e.x)||isNaN(e.y)||isNaN(e.z)||e.x===1/0||e.y===1/0||e.z===1/0)throw`Could not solve equation! Got x=[${e.toString()}], b=[${t.toString()}], A=[${this.toString()}]`;return e}e(t,e,n){if(n===void 0)return this.elements[e+3*t];this.elements[e+3*t]=n}copy(t){for(let e=0;e<t.elements.length;e++)this.elements[e]=t.elements[e];return this}toString(){let t="";const e=",";for(let n=0;n<9;n++)t+=this.elements[n]+e;return t}reverse(t){t===void 0&&(t=new ht);const e=3,n=6,s=ns;let i,o;for(i=0;i<3;i++)for(o=0;o<3;o++)s[i+n*o]=this.elements[i+3*o];s[3+6*0]=1,s[3+6*1]=0,s[3+6*2]=0,s[4+6*0]=0,s[4+6*1]=1,s[4+6*2]=0,s[5+6*0]=0,s[5+6*1]=0,s[5+6*2]=1;let r=3;const a=r;let c;const h=n;let u;do{if(i=a-r,s[i+n*i]===0){for(o=i+1;o<a;o++)if(s[i+n*o]!==0){c=h;do u=h-c,s[u+n*i]+=s[u+n*o];while(--c);break}}if(s[i+n*i]!==0)for(o=i+1;o<a;o++){const l=s[i+n*o]/s[i+n*i];c=h;do u=h-c,s[u+n*o]=u<=i?0:s[u+n*o]-s[u+n*i]*l;while(--c)}}while(--r);i=2;do{o=i-1;do{const l=s[i+n*o]/s[i+n*i];c=n;do u=n-c,s[u+n*o]=s[u+n*o]-s[u+n*i]*l;while(--c)}while(o--)}while(--i);i=2;do{const l=1/s[i+n*i];c=n;do u=n-c,s[u+n*i]=s[u+n*i]*l;while(--c)}while(i--);i=2;do{o=2;do{if(u=s[e+o+n*i],isNaN(u)||u===1/0)throw`Could not reverse! A=[${this.toString()}]`;t.e(i,o,u)}while(o--)}while(i--);return t}setRotationFromQuaternion(t){const e=t.x,n=t.y,s=t.z,i=t.w,o=e+e,r=n+n,a=s+s,c=e*o,h=e*r,u=e*a,l=n*r,p=n*a,f=s*a,y=i*o,v=i*r,g=i*a,w=this.elements;return w[3*0+0]=1-(l+f),w[3*0+1]=h-g,w[3*0+2]=u+v,w[3*1+0]=h+g,w[3*1+1]=1-(c+f),w[3*1+2]=p-y,w[3*2+0]=u-v,w[3*2+1]=p+y,w[3*2+2]=1-(c+l),this}transpose(t){t===void 0&&(t=new ht);const e=this.elements,n=t.elements;let s;return n[0]=e[0],n[4]=e[4],n[8]=e[8],s=e[1],n[1]=e[3],n[3]=s,s=e[2],n[2]=e[6],n[6]=s,s=e[5],n[5]=e[7],n[7]=s,t}}const ns=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class d{constructor(t,e,n){t===void 0&&(t=0),e===void 0&&(e=0),n===void 0&&(n=0),this.x=t,this.y=e,this.z=n}cross(t,e){e===void 0&&(e=new d);const n=t.x,s=t.y,i=t.z,o=this.x,r=this.y,a=this.z;return e.x=r*i-a*s,e.y=a*n-o*i,e.z=o*s-r*n,e}set(t,e,n){return this.x=t,this.y=e,this.z=n,this}setZero(){this.x=this.y=this.z=0}vadd(t,e){if(e)e.x=t.x+this.x,e.y=t.y+this.y,e.z=t.z+this.z;else return new d(this.x+t.x,this.y+t.y,this.z+t.z)}vsub(t,e){if(e)e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z;else return new d(this.x-t.x,this.y-t.y,this.z-t.z)}crossmat(){return new ht([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const t=this.x,e=this.y,n=this.z,s=Math.sqrt(t*t+e*e+n*n);if(s>0){const i=1/s;this.x*=i,this.y*=i,this.z*=i}else this.x=0,this.y=0,this.z=0;return s}unit(t){t===void 0&&(t=new d);const e=this.x,n=this.y,s=this.z;let i=Math.sqrt(e*e+n*n+s*s);return i>0?(i=1/i,t.x=e*i,t.y=n*i,t.z=s*i):(t.x=1,t.y=0,t.z=0),t}length(){const t=this.x,e=this.y,n=this.z;return Math.sqrt(t*t+e*e+n*n)}lengthSquared(){return this.dot(this)}distanceTo(t){const e=this.x,n=this.y,s=this.z,i=t.x,o=t.y,r=t.z;return Math.sqrt((i-e)*(i-e)+(o-n)*(o-n)+(r-s)*(r-s))}distanceSquared(t){const e=this.x,n=this.y,s=this.z,i=t.x,o=t.y,r=t.z;return(i-e)*(i-e)+(o-n)*(o-n)+(r-s)*(r-s)}scale(t,e){e===void 0&&(e=new d);const n=this.x,s=this.y,i=this.z;return e.x=t*n,e.y=t*s,e.z=t*i,e}vmul(t,e){return e===void 0&&(e=new d),e.x=t.x*this.x,e.y=t.y*this.y,e.z=t.z*this.z,e}addScaledVector(t,e,n){return n===void 0&&(n=new d),n.x=this.x+t*e.x,n.y=this.y+t*e.y,n.z=this.z+t*e.z,n}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}isZero(){return this.x===0&&this.y===0&&this.z===0}negate(t){return t===void 0&&(t=new d),t.x=-this.x,t.y=-this.y,t.z=-this.z,t}tangents(t,e){const n=this.length();if(n>0){const s=ss,i=1/n;s.set(this.x*i,this.y*i,this.z*i);const o=is;Math.abs(s.x)<.9?(o.set(1,0,0),s.cross(o,t)):(o.set(0,1,0),s.cross(o,t)),s.cross(t,e)}else t.set(1,0,0),e.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}lerp(t,e,n){const s=this.x,i=this.y,o=this.z;n.x=s+(t.x-s)*e,n.y=i+(t.y-i)*e,n.z=o+(t.z-o)*e}almostEquals(t,e){return e===void 0&&(e=1e-6),!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e||Math.abs(this.z-t.z)>e)}almostZero(t){return t===void 0&&(t=1e-6),!(Math.abs(this.x)>t||Math.abs(this.y)>t||Math.abs(this.z)>t)}isAntiparallelTo(t,e){return this.negate(Ne),Ne.almostEquals(t,e)}clone(){return new d(this.x,this.y,this.z)}}d.ZERO=new d(0,0,0);d.UNIT_X=new d(1,0,0);d.UNIT_Y=new d(0,1,0);d.UNIT_Z=new d(0,0,1);const ss=new d,is=new d,Ne=new d;class ot{constructor(t){t===void 0&&(t={}),this.lowerBound=new d,this.upperBound=new d,t.lowerBound&&this.lowerBound.copy(t.lowerBound),t.upperBound&&this.upperBound.copy(t.upperBound)}setFromPoints(t,e,n,s){const i=this.lowerBound,o=this.upperBound,r=n;i.copy(t[0]),r&&r.vmult(i,i),o.copy(i);for(let a=1;a<t.length;a++){let c=t[a];r&&(r.vmult(c,_e),c=_e),c.x>o.x&&(o.x=c.x),c.x<i.x&&(i.x=c.x),c.y>o.y&&(o.y=c.y),c.y<i.y&&(i.y=c.y),c.z>o.z&&(o.z=c.z),c.z<i.z&&(i.z=c.z)}return e&&(e.vadd(i,i),e.vadd(o,o)),s&&(i.x-=s,i.y-=s,i.z-=s,o.x+=s,o.y+=s,o.z+=s),this}copy(t){return this.lowerBound.copy(t.lowerBound),this.upperBound.copy(t.upperBound),this}clone(){return new ot().copy(this)}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){const e=this.lowerBound,n=this.upperBound,s=t.lowerBound,i=t.upperBound,o=s.x<=n.x&&n.x<=i.x||e.x<=i.x&&i.x<=n.x,r=s.y<=n.y&&n.y<=i.y||e.y<=i.y&&i.y<=n.y,a=s.z<=n.z&&n.z<=i.z||e.z<=i.z&&i.z<=n.z;return o&&r&&a}volume(){const t=this.lowerBound,e=this.upperBound;return(e.x-t.x)*(e.y-t.y)*(e.z-t.z)}contains(t){const e=this.lowerBound,n=this.upperBound,s=t.lowerBound,i=t.upperBound;return e.x<=s.x&&n.x>=i.x&&e.y<=s.y&&n.y>=i.y&&e.z<=s.z&&n.z>=i.z}getCorners(t,e,n,s,i,o,r,a){const c=this.lowerBound,h=this.upperBound;t.copy(c),e.set(h.x,c.y,c.z),n.set(h.x,h.y,c.z),s.set(c.x,h.y,h.z),i.set(h.x,c.y,h.z),o.set(c.x,h.y,c.z),r.set(c.x,c.y,h.z),a.copy(h)}toLocalFrame(t,e){const n=Oe,s=n[0],i=n[1],o=n[2],r=n[3],a=n[4],c=n[5],h=n[6],u=n[7];this.getCorners(s,i,o,r,a,c,h,u);for(let l=0;l!==8;l++){const p=n[l];t.pointToLocal(p,p)}return e.setFromPoints(n)}toWorldFrame(t,e){const n=Oe,s=n[0],i=n[1],o=n[2],r=n[3],a=n[4],c=n[5],h=n[6],u=n[7];this.getCorners(s,i,o,r,a,c,h,u);for(let l=0;l!==8;l++){const p=n[l];t.pointToWorld(p,p)}return e.setFromPoints(n)}overlapsRay(t){const{direction:e,from:n}=t,s=1/e.x,i=1/e.y,o=1/e.z,r=(this.lowerBound.x-n.x)*s,a=(this.upperBound.x-n.x)*s,c=(this.lowerBound.y-n.y)*i,h=(this.upperBound.y-n.y)*i,u=(this.lowerBound.z-n.z)*o,l=(this.upperBound.z-n.z)*o,p=Math.max(Math.max(Math.min(r,a),Math.min(c,h)),Math.min(u,l)),f=Math.min(Math.min(Math.max(r,a),Math.max(c,h)),Math.max(u,l));return!(f<0||p>f)}}const _e=new d,Oe=[new d,new d,new d,new d,new d,new d,new d,new d];class De{constructor(){this.matrix=[]}get(t,e){let{index:n}=t,{index:s}=e;if(s>n){const i=s;s=n,n=i}return this.matrix[(n*(n+1)>>1)+s-1]}set(t,e,n){let{index:s}=t,{index:i}=e;if(i>s){const o=i;i=s,s=o}this.matrix[(s*(s+1)>>1)+i-1]=n?1:0}reset(){for(let t=0,e=this.matrix.length;t!==e;t++)this.matrix[t]=0}setNumObjects(t){this.matrix.length=t*(t-1)>>1}}class on{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;return n[t]===void 0&&(n[t]=[]),n[t].includes(e)||n[t].push(e),this}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return!!(n[t]!==void 0&&n[t].includes(e))}hasAnyEventListener(t){return this._listeners===void 0?!1:this._listeners[t]!==void 0}removeEventListener(t,e){if(this._listeners===void 0)return this;const n=this._listeners;if(n[t]===void 0)return this;const s=n[t].indexOf(e);return s!==-1&&n[t].splice(s,1),this}dispatchEvent(t){if(this._listeners===void 0)return this;const n=this._listeners[t.type];if(n!==void 0){t.target=this;for(let s=0,i=n.length;s<i;s++)n[s].call(this,t)}return this}}class ${constructor(t,e,n,s){t===void 0&&(t=0),e===void 0&&(e=0),n===void 0&&(n=0),s===void 0&&(s=1),this.x=t,this.y=e,this.z=n,this.w=s}set(t,e,n,s){return this.x=t,this.y=e,this.z=n,this.w=s,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(t,e){const n=Math.sin(e*.5);return this.x=t.x*n,this.y=t.y*n,this.z=t.z*n,this.w=Math.cos(e*.5),this}toAxisAngle(t){t===void 0&&(t=new d),this.normalize();const e=2*Math.acos(this.w),n=Math.sqrt(1-this.w*this.w);return n<.001?(t.x=this.x,t.y=this.y,t.z=this.z):(t.x=this.x/n,t.y=this.y/n,t.z=this.z/n),[t,e]}setFromVectors(t,e){if(t.isAntiparallelTo(e)){const n=os,s=rs;t.tangents(n,s),this.setFromAxisAngle(n,Math.PI)}else{const n=t.cross(e);this.x=n.x,this.y=n.y,this.z=n.z,this.w=Math.sqrt(t.length()**2*e.length()**2)+t.dot(e),this.normalize()}return this}mult(t,e){e===void 0&&(e=new $);const n=this.x,s=this.y,i=this.z,o=this.w,r=t.x,a=t.y,c=t.z,h=t.w;return e.x=n*h+o*r+s*c-i*a,e.y=s*h+o*a+i*r-n*c,e.z=i*h+o*c+n*a-s*r,e.w=o*h-n*r-s*a-i*c,e}inverse(t){t===void 0&&(t=new $);const e=this.x,n=this.y,s=this.z,i=this.w;this.conjugate(t);const o=1/(e*e+n*n+s*s+i*i);return t.x*=o,t.y*=o,t.z*=o,t.w*=o,t}conjugate(t){return t===void 0&&(t=new $),t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=this.w,t}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return t===0?(this.x=0,this.y=0,this.z=0,this.w=0):(t=1/t,this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}normalizeFast(){const t=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return t===0?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}vmult(t,e){e===void 0&&(e=new d);const n=t.x,s=t.y,i=t.z,o=this.x,r=this.y,a=this.z,c=this.w,h=c*n+r*i-a*s,u=c*s+a*n-o*i,l=c*i+o*s-r*n,p=-o*n-r*s-a*i;return e.x=h*c+p*-o+u*-a-l*-r,e.y=u*c+p*-r+l*-o-h*-a,e.z=l*c+p*-a+h*-r-u*-o,e}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}toEuler(t,e){e===void 0&&(e="YZX");let n,s,i;const o=this.x,r=this.y,a=this.z,c=this.w;switch(e){case"YZX":const h=o*r+a*c;if(h>.499&&(n=2*Math.atan2(o,c),s=Math.PI/2,i=0),h<-.499&&(n=-2*Math.atan2(o,c),s=-Math.PI/2,i=0),n===void 0){const u=o*o,l=r*r,p=a*a;n=Math.atan2(2*r*c-2*o*a,1-2*l-2*p),s=Math.asin(2*h),i=Math.atan2(2*o*c-2*r*a,1-2*u-2*p)}break;default:throw new Error(`Euler order ${e} not supported yet.`)}t.y=n,t.z=s,t.x=i}setFromEuler(t,e,n,s){s===void 0&&(s="XYZ");const i=Math.cos(t/2),o=Math.cos(e/2),r=Math.cos(n/2),a=Math.sin(t/2),c=Math.sin(e/2),h=Math.sin(n/2);return s==="XYZ"?(this.x=a*o*r+i*c*h,this.y=i*c*r-a*o*h,this.z=i*o*h+a*c*r,this.w=i*o*r-a*c*h):s==="YXZ"?(this.x=a*o*r+i*c*h,this.y=i*c*r-a*o*h,this.z=i*o*h-a*c*r,this.w=i*o*r+a*c*h):s==="ZXY"?(this.x=a*o*r-i*c*h,this.y=i*c*r+a*o*h,this.z=i*o*h+a*c*r,this.w=i*o*r-a*c*h):s==="ZYX"?(this.x=a*o*r-i*c*h,this.y=i*c*r+a*o*h,this.z=i*o*h-a*c*r,this.w=i*o*r+a*c*h):s==="YZX"?(this.x=a*o*r+i*c*h,this.y=i*c*r+a*o*h,this.z=i*o*h-a*c*r,this.w=i*o*r-a*c*h):s==="XZY"&&(this.x=a*o*r-i*c*h,this.y=i*c*r-a*o*h,this.z=i*o*h+a*c*r,this.w=i*o*r+a*c*h),this}clone(){return new $(this.x,this.y,this.z,this.w)}slerp(t,e,n){n===void 0&&(n=new $);const s=this.x,i=this.y,o=this.z,r=this.w;let a=t.x,c=t.y,h=t.z,u=t.w,l,p,f,y,v;return p=s*a+i*c+o*h+r*u,p<0&&(p=-p,a=-a,c=-c,h=-h,u=-u),1-p>1e-6?(l=Math.acos(p),f=Math.sin(l),y=Math.sin((1-e)*l)/f,v=Math.sin(e*l)/f):(y=1-e,v=e),n.x=y*s+v*a,n.y=y*i+v*c,n.z=y*o+v*h,n.w=y*r+v*u,n}integrate(t,e,n,s){s===void 0&&(s=new $);const i=t.x*n.x,o=t.y*n.y,r=t.z*n.z,a=this.x,c=this.y,h=this.z,u=this.w,l=e*.5;return s.x+=l*(i*u+o*h-r*c),s.y+=l*(o*u+r*a-i*h),s.z+=l*(r*u+i*c-o*a),s.w+=l*(-i*a-o*c-r*h),s}}const os=new d,rs=new d,as={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class z{constructor(t){t===void 0&&(t={}),this.id=z.idCounter++,this.type=t.type||0,this.boundingSphereRadius=0,this.collisionResponse=t.collisionResponse?t.collisionResponse:!0,this.collisionFilterGroup=t.collisionFilterGroup!==void 0?t.collisionFilterGroup:1,this.collisionFilterMask=t.collisionFilterMask!==void 0?t.collisionFilterMask:-1,this.material=t.material?t.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(t,e){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(t,e,n,s){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}z.idCounter=0;z.types=as;class V{constructor(t){t===void 0&&(t={}),this.position=new d,this.quaternion=new $,t.position&&this.position.copy(t.position),t.quaternion&&this.quaternion.copy(t.quaternion)}pointToLocal(t,e){return V.pointToLocalFrame(this.position,this.quaternion,t,e)}pointToWorld(t,e){return V.pointToWorldFrame(this.position,this.quaternion,t,e)}vectorToWorldFrame(t,e){return e===void 0&&(e=new d),this.quaternion.vmult(t,e),e}static pointToLocalFrame(t,e,n,s){return s===void 0&&(s=new d),n.vsub(t,s),e.conjugate(qe),qe.vmult(s,s),s}static pointToWorldFrame(t,e,n,s){return s===void 0&&(s=new d),e.vmult(n,s),s.vadd(t,s),s}static vectorToWorldFrame(t,e,n){return n===void 0&&(n=new d),t.vmult(e,n),n}static vectorToLocalFrame(t,e,n,s){return s===void 0&&(s=new d),e.w*=-1,e.vmult(n,s),e.w*=-1,s}}const qe=new $;class Vt extends z{constructor(t){t===void 0&&(t={});const{vertices:e=[],faces:n=[],normals:s=[],axes:i,boundingSphereRadius:o}=t;super({type:z.types.CONVEXPOLYHEDRON}),this.vertices=e,this.faces=n,this.faceNormals=s,this.faceNormals.length===0&&this.computeNormals(),o?this.boundingSphereRadius=o:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=i?i.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const t=this.faces,e=this.vertices,n=this.uniqueEdges;n.length=0;const s=new d;for(let i=0;i!==t.length;i++){const o=t[i],r=o.length;for(let a=0;a!==r;a++){const c=(a+1)%r;e[o[a]].vsub(e[o[c]],s),s.normalize();let h=!1;for(let u=0;u!==n.length;u++)if(n[u].almostEquals(s)||n[u].almostEquals(s)){h=!0;break}h||n.push(s.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let t=0;t<this.faces.length;t++){for(let s=0;s<this.faces[t].length;s++)if(!this.vertices[this.faces[t][s]])throw new Error(`Vertex ${this.faces[t][s]} not found!`);const e=this.faceNormals[t]||new d;this.getFaceNormal(t,e),e.negate(e),this.faceNormals[t]=e;const n=this.vertices[this.faces[t][0]];if(e.dot(n)<0){console.error(`.faceNormals[${t}] = Vec3(${e.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let s=0;s<this.faces[t].length;s++)console.warn(`.vertices[${this.faces[t][s]}] = Vec3(${this.vertices[this.faces[t][s]].toString()})`)}}}getFaceNormal(t,e){const n=this.faces[t],s=this.vertices[n[0]],i=this.vertices[n[1]],o=this.vertices[n[2]];Vt.computeNormal(s,i,o,e)}static computeNormal(t,e,n,s){const i=new d,o=new d;e.vsub(t,o),n.vsub(e,i),i.cross(o,s),s.isZero()||s.normalize()}clipAgainstHull(t,e,n,s,i,o,r,a,c){const h=new d;let u=-1,l=-Number.MAX_VALUE;for(let f=0;f<n.faces.length;f++){h.copy(n.faceNormals[f]),i.vmult(h,h);const y=h.dot(o);y>l&&(l=y,u=f)}const p=[];for(let f=0;f<n.faces[u].length;f++){const y=n.vertices[n.faces[u][f]],v=new d;v.copy(y),i.vmult(v,v),s.vadd(v,v),p.push(v)}u>=0&&this.clipFaceAgainstHull(o,t,e,p,r,a,c)}findSeparatingAxis(t,e,n,s,i,o,r,a){const c=new d,h=new d,u=new d,l=new d,p=new d,f=new d;let y=Number.MAX_VALUE;const v=this;if(v.uniqueAxes)for(let g=0;g!==v.uniqueAxes.length;g++){n.vmult(v.uniqueAxes[g],c);const w=v.testSepAxis(c,t,e,n,s,i);if(w===!1)return!1;w<y&&(y=w,o.copy(c))}else{const g=r?r.length:v.faces.length;for(let w=0;w<g;w++){const x=r?r[w]:w;c.copy(v.faceNormals[x]),n.vmult(c,c);const b=v.testSepAxis(c,t,e,n,s,i);if(b===!1)return!1;b<y&&(y=b,o.copy(c))}}if(t.uniqueAxes)for(let g=0;g!==t.uniqueAxes.length;g++){i.vmult(t.uniqueAxes[g],h);const w=v.testSepAxis(h,t,e,n,s,i);if(w===!1)return!1;w<y&&(y=w,o.copy(h))}else{const g=a?a.length:t.faces.length;for(let w=0;w<g;w++){const x=a?a[w]:w;h.copy(t.faceNormals[x]),i.vmult(h,h);const b=v.testSepAxis(h,t,e,n,s,i);if(b===!1)return!1;b<y&&(y=b,o.copy(h))}}for(let g=0;g!==v.uniqueEdges.length;g++){n.vmult(v.uniqueEdges[g],l);for(let w=0;w!==t.uniqueEdges.length;w++)if(i.vmult(t.uniqueEdges[w],p),l.cross(p,f),!f.almostZero()){f.normalize();const x=v.testSepAxis(f,t,e,n,s,i);if(x===!1)return!1;x<y&&(y=x,o.copy(f))}}return s.vsub(e,u),u.dot(o)>0&&o.negate(o),!0}testSepAxis(t,e,n,s,i,o){const r=this;Vt.project(r,t,n,s,ce),Vt.project(e,t,i,o,le);const a=ce[0],c=ce[1],h=le[0],u=le[1];if(a<u||h<c)return!1;const l=a-u,p=h-c;return l<p?l:p}calculateLocalInertia(t,e){const n=new d,s=new d;this.computeLocalAABB(s,n);const i=n.x-s.x,o=n.y-s.y,r=n.z-s.z;e.x=1/12*t*(2*o*2*o+2*r*2*r),e.y=1/12*t*(2*i*2*i+2*r*2*r),e.z=1/12*t*(2*o*2*o+2*i*2*i)}getPlaneConstantOfFace(t){const e=this.faces[t],n=this.faceNormals[t],s=this.vertices[e[0]];return-n.dot(s)}clipFaceAgainstHull(t,e,n,s,i,o,r){const a=new d,c=new d,h=new d,u=new d,l=new d,p=new d,f=new d,y=new d,v=this,g=[],w=s,x=g;let b=-1,E=Number.MAX_VALUE;for(let R=0;R<v.faces.length;R++){a.copy(v.faceNormals[R]),n.vmult(a,a);const F=a.dot(t);F<E&&(E=F,b=R)}if(b<0)return;const S=v.faces[b];S.connectedFaces=[];for(let R=0;R<v.faces.length;R++)for(let F=0;F<v.faces[R].length;F++)S.indexOf(v.faces[R][F])!==-1&&R!==b&&S.connectedFaces.indexOf(R)===-1&&S.connectedFaces.push(R);const M=S.length;for(let R=0;R<M;R++){const F=v.vertices[S[R]],_=v.vertices[S[(R+1)%M]];F.vsub(_,c),h.copy(c),n.vmult(h,h),e.vadd(h,h),u.copy(this.faceNormals[b]),n.vmult(u,u),e.vadd(u,u),h.cross(u,l),l.negate(l),p.copy(F),n.vmult(p,p),e.vadd(p,p);const T=S.connectedFaces[R];f.copy(this.faceNormals[T]);const P=this.getPlaneConstantOfFace(T);y.copy(f),n.vmult(y,y);const A=P-y.dot(e);for(this.clipFaceAgainstPlane(w,x,y,A);w.length;)w.shift();for(;x.length;)w.push(x.shift())}f.copy(this.faceNormals[b]);const I=this.getPlaneConstantOfFace(b);y.copy(f),n.vmult(y,y);const L=I-y.dot(e);for(let R=0;R<w.length;R++){let F=y.dot(w[R])+L;if(F<=i&&(console.log(`clamped: depth=${F} to minDist=${i}`),F=i),F<=o){const _=w[R];if(F<=1e-6){const T={point:_,normal:y,depth:F};r.push(T)}}}}clipFaceAgainstPlane(t,e,n,s){let i,o;const r=t.length;if(r<2)return e;let a=t[t.length-1],c=t[0];i=n.dot(a)+s;for(let h=0;h<r;h++){if(c=t[h],o=n.dot(c)+s,i<0)if(o<0){const u=new d;u.copy(c),e.push(u)}else{const u=new d;a.lerp(c,i/(i-o),u),e.push(u)}else if(o<0){const u=new d;a.lerp(c,i/(i-o),u),e.push(u),e.push(c)}a=c,i=o}return e}computeWorldVertices(t,e){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new d);const n=this.vertices,s=this.worldVertices;for(let i=0;i!==this.vertices.length;i++)e.vmult(n[i],s[i]),t.vadd(s[i],s[i]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(t,e){const n=this.vertices;t.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let s=0;s<this.vertices.length;s++){const i=n[s];i.x<t.x?t.x=i.x:i.x>e.x&&(e.x=i.x),i.y<t.y?t.y=i.y:i.y>e.y&&(e.y=i.y),i.z<t.z?t.z=i.z:i.z>e.z&&(e.z=i.z)}}computeWorldFaceNormals(t){const e=this.faceNormals.length;for(;this.worldFaceNormals.length<e;)this.worldFaceNormals.push(new d);const n=this.faceNormals,s=this.worldFaceNormals;for(let i=0;i!==e;i++)t.vmult(n[i],s[i]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let t=0;const e=this.vertices;for(let n=0;n!==e.length;n++){const s=e[n].lengthSquared();s>t&&(t=s)}this.boundingSphereRadius=Math.sqrt(t)}calculateWorldAABB(t,e,n,s){const i=this.vertices;let o,r,a,c,h,u,l=new d;for(let p=0;p<i.length;p++){l.copy(i[p]),e.vmult(l,l),t.vadd(l,l);const f=l;(o===void 0||f.x<o)&&(o=f.x),(c===void 0||f.x>c)&&(c=f.x),(r===void 0||f.y<r)&&(r=f.y),(h===void 0||f.y>h)&&(h=f.y),(a===void 0||f.z<a)&&(a=f.z),(u===void 0||f.z>u)&&(u=f.z)}n.set(o,r,a),s.set(c,h,u)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(t){t===void 0&&(t=new d);const e=this.vertices;for(let n=0;n<e.length;n++)t.vadd(e[n],t);return t.scale(1/e.length,t),t}transformAllPoints(t,e){const n=this.vertices.length,s=this.vertices;if(e){for(let i=0;i<n;i++){const o=s[i];e.vmult(o,o)}for(let i=0;i<this.faceNormals.length;i++){const o=this.faceNormals[i];e.vmult(o,o)}}if(t)for(let i=0;i<n;i++){const o=s[i];o.vadd(t,o)}}pointIsInside(t){const e=this.vertices,n=this.faces,s=this.faceNormals,i=new d;this.getAveragePointLocal(i);for(let o=0;o<this.faces.length;o++){let r=s[o];const a=e[n[o][0]],c=new d;t.vsub(a,c);const h=r.dot(c),u=new d;i.vsub(a,u);const l=r.dot(u);if(h<0&&l>0||h>0&&l<0)return!1}return-1}static project(t,e,n,s,i){const o=t.vertices.length,r=cs;let a=0,c=0;const h=ls,u=t.vertices;h.setZero(),V.vectorToLocalFrame(n,s,e,r),V.pointToLocalFrame(n,s,h,h);const l=h.dot(r);c=a=u[0].dot(r);for(let p=1;p<o;p++){const f=u[p].dot(r);f>a&&(a=f),f<c&&(c=f)}if(c-=l,a-=l,c>a){const p=c;c=a,a=p}i[0]=a,i[1]=c}}const ce=[],le=[];new d;const cs=new d,ls=new d;let xe=class rn extends z{constructor(t){super({type:z.types.BOX}),this.halfExtents=t,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const t=this.halfExtents.x,e=this.halfExtents.y,n=this.halfExtents.z,s=d,i=[new s(-t,-e,-n),new s(t,-e,-n),new s(t,e,-n),new s(-t,e,-n),new s(-t,-e,n),new s(t,-e,n),new s(t,e,n),new s(-t,e,n)],o=[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],r=[new s(0,0,1),new s(0,1,0),new s(1,0,0)],a=new Vt({vertices:i,faces:o,axes:r});this.convexPolyhedronRepresentation=a,a.material=this.material}calculateLocalInertia(t,e){return e===void 0&&(e=new d),rn.calculateInertia(this.halfExtents,t,e),e}static calculateInertia(t,e,n){const s=t;n.x=1/12*e*(2*s.y*2*s.y+2*s.z*2*s.z),n.y=1/12*e*(2*s.x*2*s.x+2*s.z*2*s.z),n.z=1/12*e*(2*s.y*2*s.y+2*s.x*2*s.x)}getSideNormals(t,e){const n=t,s=this.halfExtents;if(n[0].set(s.x,0,0),n[1].set(0,s.y,0),n[2].set(0,0,s.z),n[3].set(-s.x,0,0),n[4].set(0,-s.y,0),n[5].set(0,0,-s.z),e!==void 0)for(let i=0;i!==n.length;i++)e.vmult(n[i],n[i]);return n}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(t,e,n){const s=this.halfExtents,i=[[s.x,s.y,s.z],[-s.x,s.y,s.z],[-s.x,-s.y,s.z],[-s.x,-s.y,-s.z],[s.x,-s.y,-s.z],[s.x,s.y,-s.z],[-s.x,s.y,-s.z],[s.x,-s.y,s.z]];for(let o=0;o<i.length;o++)Et.set(i[o][0],i[o][1],i[o][2]),e.vmult(Et,Et),t.vadd(Et,Et),n(Et.x,Et.y,Et.z)}calculateWorldAABB(t,e,n,s){const i=this.halfExtents;ut[0].set(i.x,i.y,i.z),ut[1].set(-i.x,i.y,i.z),ut[2].set(-i.x,-i.y,i.z),ut[3].set(-i.x,-i.y,-i.z),ut[4].set(i.x,-i.y,-i.z),ut[5].set(i.x,i.y,-i.z),ut[6].set(-i.x,i.y,-i.z),ut[7].set(i.x,-i.y,i.z);const o=ut[0];e.vmult(o,o),t.vadd(o,o),s.copy(o),n.copy(o);for(let r=1;r<8;r++){const a=ut[r];e.vmult(a,a),t.vadd(a,a);const c=a.x,h=a.y,u=a.z;c>s.x&&(s.x=c),h>s.y&&(s.y=h),u>s.z&&(s.z=u),c<n.x&&(n.x=c),h<n.y&&(n.y=h),u<n.z&&(n.z=u)}}};const Et=new d,ut=[new d,new d,new d,new d,new d,new d,new d,new d],be={DYNAMIC:1,STATIC:2,KINEMATIC:4},Ee={AWAKE:0,SLEEPY:1,SLEEPING:2};class B extends on{constructor(t){t===void 0&&(t={}),super(),this.id=B.idCounter++,this.index=-1,this.world=null,this.vlambda=new d,this.collisionFilterGroup=typeof t.collisionFilterGroup=="number"?t.collisionFilterGroup:1,this.collisionFilterMask=typeof t.collisionFilterMask=="number"?t.collisionFilterMask:-1,this.collisionResponse=typeof t.collisionResponse=="boolean"?t.collisionResponse:!0,this.position=new d,this.previousPosition=new d,this.interpolatedPosition=new d,this.initPosition=new d,t.position&&(this.position.copy(t.position),this.previousPosition.copy(t.position),this.interpolatedPosition.copy(t.position),this.initPosition.copy(t.position)),this.velocity=new d,t.velocity&&this.velocity.copy(t.velocity),this.initVelocity=new d,this.force=new d;const e=typeof t.mass=="number"?t.mass:0;this.mass=e,this.invMass=e>0?1/e:0,this.material=t.material||null,this.linearDamping=typeof t.linearDamping=="number"?t.linearDamping:.01,this.type=e<=0?B.STATIC:B.DYNAMIC,typeof t.type==typeof B.STATIC&&(this.type=t.type),this.allowSleep=typeof t.allowSleep<"u"?t.allowSleep:!0,this.sleepState=B.AWAKE,this.sleepSpeedLimit=typeof t.sleepSpeedLimit<"u"?t.sleepSpeedLimit:.1,this.sleepTimeLimit=typeof t.sleepTimeLimit<"u"?t.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new d,this.quaternion=new $,this.initQuaternion=new $,this.previousQuaternion=new $,this.interpolatedQuaternion=new $,t.quaternion&&(this.quaternion.copy(t.quaternion),this.initQuaternion.copy(t.quaternion),this.previousQuaternion.copy(t.quaternion),this.interpolatedQuaternion.copy(t.quaternion)),this.angularVelocity=new d,t.angularVelocity&&this.angularVelocity.copy(t.angularVelocity),this.initAngularVelocity=new d,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new d,this.invInertia=new d,this.invInertiaWorld=new ht,this.invMassSolve=0,this.invInertiaSolve=new d,this.invInertiaWorldSolve=new ht,this.fixedRotation=typeof t.fixedRotation<"u"?t.fixedRotation:!1,this.angularDamping=typeof t.angularDamping<"u"?t.angularDamping:.01,this.linearFactor=new d(1,1,1),t.linearFactor&&this.linearFactor.copy(t.linearFactor),this.angularFactor=new d(1,1,1),t.angularFactor&&this.angularFactor.copy(t.angularFactor),this.aabb=new ot,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new d,this.isTrigger=!!t.isTrigger,t.shape&&this.addShape(t.shape),this.updateMassProperties()}wakeUp(){const t=this.sleepState;this.sleepState=B.AWAKE,this.wakeUpAfterNarrowphase=!1,t===B.SLEEPING&&this.dispatchEvent(B.wakeupEvent)}sleep(){this.sleepState=B.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(t){if(this.allowSleep){const e=this.sleepState,n=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),s=this.sleepSpeedLimit**2;e===B.AWAKE&&n<s?(this.sleepState=B.SLEEPY,this.timeLastSleepy=t,this.dispatchEvent(B.sleepyEvent)):e===B.SLEEPY&&n>s?this.wakeUp():e===B.SLEEPY&&t-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(B.sleepEvent))}}updateSolveMassProperties(){this.sleepState===B.SLEEPING||this.type===B.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(t,e){return e===void 0&&(e=new d),t.vsub(this.position,e),this.quaternion.conjugate().vmult(e,e),e}vectorToLocalFrame(t,e){return e===void 0&&(e=new d),this.quaternion.conjugate().vmult(t,e),e}pointToWorldFrame(t,e){return e===void 0&&(e=new d),this.quaternion.vmult(t,e),e.vadd(this.position,e),e}vectorToWorldFrame(t,e){return e===void 0&&(e=new d),this.quaternion.vmult(t,e),e}addShape(t,e,n){const s=new d,i=new $;return e&&s.copy(e),n&&i.copy(n),this.shapes.push(t),this.shapeOffsets.push(s),this.shapeOrientations.push(i),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=this,this}removeShape(t){const e=this.shapes.indexOf(t);return e===-1?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(e,1),this.shapeOffsets.splice(e,1),this.shapeOrientations.splice(e,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=null,this)}updateBoundingRadius(){const t=this.shapes,e=this.shapeOffsets,n=t.length;let s=0;for(let i=0;i!==n;i++){const o=t[i];o.updateBoundingSphereRadius();const r=e[i].length(),a=o.boundingSphereRadius;r+a>s&&(s=r+a)}this.boundingRadius=s}updateAABB(){const t=this.shapes,e=this.shapeOffsets,n=this.shapeOrientations,s=t.length,i=hs,o=us,r=this.quaternion,a=this.aabb,c=ds;for(let h=0;h!==s;h++){const u=t[h];r.vmult(e[h],i),i.vadd(this.position,i),r.mult(n[h],o),u.calculateWorldAABB(i,o,c.lowerBound,c.upperBound),h===0?a.copy(c):a.extend(c)}this.aabbNeedsUpdate=!1}updateInertiaWorld(t){const e=this.invInertia;if(!(e.x===e.y&&e.y===e.z&&!t)){const n=ps,s=fs;n.setRotationFromQuaternion(this.quaternion),n.transpose(s),n.scale(e,n),n.mmult(s,this.invInertiaWorld)}}applyForce(t,e){if(e===void 0&&(e=new d),this.type!==B.DYNAMIC)return;this.sleepState===B.SLEEPING&&this.wakeUp();const n=ms;e.cross(t,n),this.force.vadd(t,this.force),this.torque.vadd(n,this.torque)}applyLocalForce(t,e){if(e===void 0&&(e=new d),this.type!==B.DYNAMIC)return;const n=vs,s=ys;this.vectorToWorldFrame(t,n),this.vectorToWorldFrame(e,s),this.applyForce(n,s)}applyTorque(t){this.type===B.DYNAMIC&&(this.sleepState===B.SLEEPING&&this.wakeUp(),this.torque.vadd(t,this.torque))}applyImpulse(t,e){if(e===void 0&&(e=new d),this.type!==B.DYNAMIC)return;this.sleepState===B.SLEEPING&&this.wakeUp();const n=e,s=ws;s.copy(t),s.scale(this.invMass,s),this.velocity.vadd(s,this.velocity);const i=gs;n.cross(t,i),this.invInertiaWorld.vmult(i,i),this.angularVelocity.vadd(i,this.angularVelocity)}applyLocalImpulse(t,e){if(e===void 0&&(e=new d),this.type!==B.DYNAMIC)return;const n=xs,s=bs;this.vectorToWorldFrame(t,n),this.vectorToWorldFrame(e,s),this.applyImpulse(n,s)}updateMassProperties(){const t=Es;this.invMass=this.mass>0?1/this.mass:0;const e=this.inertia,n=this.fixedRotation;this.updateAABB(),t.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),xe.calculateInertia(t,this.mass,e),this.invInertia.set(e.x>0&&!n?1/e.x:0,e.y>0&&!n?1/e.y:0,e.z>0&&!n?1/e.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(t,e){const n=new d;return t.vsub(this.position,n),this.angularVelocity.cross(n,e),this.velocity.vadd(e,e),e}integrate(t,e,n){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),!(this.type===B.DYNAMIC||this.type===B.KINEMATIC)||this.sleepState===B.SLEEPING)return;const s=this.velocity,i=this.angularVelocity,o=this.position,r=this.force,a=this.torque,c=this.quaternion,h=this.invMass,u=this.invInertiaWorld,l=this.linearFactor,p=h*t;s.x+=r.x*p*l.x,s.y+=r.y*p*l.y,s.z+=r.z*p*l.z;const f=u.elements,y=this.angularFactor,v=a.x*y.x,g=a.y*y.y,w=a.z*y.z;i.x+=t*(f[0]*v+f[1]*g+f[2]*w),i.y+=t*(f[3]*v+f[4]*g+f[5]*w),i.z+=t*(f[6]*v+f[7]*g+f[8]*w),o.x+=s.x*t,o.y+=s.y*t,o.z+=s.z*t,c.integrate(this.angularVelocity,t,this.angularFactor,c),e&&(n?c.normalizeFast():c.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}B.idCounter=0;B.COLLIDE_EVENT_NAME="collide";B.DYNAMIC=be.DYNAMIC;B.STATIC=be.STATIC;B.KINEMATIC=be.KINEMATIC;B.AWAKE=Ee.AWAKE;B.SLEEPY=Ee.SLEEPY;B.SLEEPING=Ee.SLEEPING;B.wakeupEvent={type:"wakeup"};B.sleepyEvent={type:"sleepy"};B.sleepEvent={type:"sleep"};const hs=new d,us=new $,ds=new ot,ps=new ht,fs=new ht;new ht;const ms=new d,vs=new d,ys=new d,ws=new d,gs=new d,xs=new d,bs=new d,Es=new d;class Ss{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(t,e,n){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(t,e){return!(!(t.collisionFilterGroup&e.collisionFilterMask)||!(e.collisionFilterGroup&t.collisionFilterMask)||(t.type&B.STATIC||t.sleepState===B.SLEEPING)&&(e.type&B.STATIC||e.sleepState===B.SLEEPING))}intersectionTest(t,e,n,s){this.useBoundingBoxes?this.doBoundingBoxBroadphase(t,e,n,s):this.doBoundingSphereBroadphase(t,e,n,s)}doBoundingSphereBroadphase(t,e,n,s){const i=Cs;e.position.vsub(t.position,i);const o=(t.boundingRadius+e.boundingRadius)**2;i.lengthSquared()<o&&(n.push(t),s.push(e))}doBoundingBoxBroadphase(t,e,n,s){t.aabbNeedsUpdate&&t.updateAABB(),e.aabbNeedsUpdate&&e.updateAABB(),t.aabb.overlaps(e.aabb)&&(n.push(t),s.push(e))}makePairsUnique(t,e){const n=Ts,s=Ms,i=As,o=t.length;for(let r=0;r!==o;r++)s[r]=t[r],i[r]=e[r];t.length=0,e.length=0;for(let r=0;r!==o;r++){const a=s[r].id,c=i[r].id,h=a<c?`${a},${c}`:`${c},${a}`;n[h]=r,n.keys.push(h)}for(let r=0;r!==n.keys.length;r++){const a=n.keys.pop(),c=n[a];t.push(s[c]),e.push(i[c]),delete n[a]}}setWorld(t){}static boundingSphereCheck(t,e){const n=new d;t.position.vsub(e.position,n);const s=t.shapes[0],i=e.shapes[0];return Math.pow(s.boundingSphereRadius+i.boundingSphereRadius,2)>n.lengthSquared()}aabbQuery(t,e,n){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const Cs=new d;new d;new $;new d;const Ts={keys:[]},Ms=[],As=[];new d;new d;new d;class an extends Ss{constructor(){super()}collisionPairs(t,e,n){const s=t.bodies,i=s.length;let o,r;for(let a=0;a!==i;a++)for(let c=0;c!==a;c++)o=s[a],r=s[c],this.needBroadphaseCollision(o,r)&&this.intersectionTest(o,r,e,n)}aabbQuery(t,e,n){n===void 0&&(n=[]);for(let s=0;s<t.bodies.length;s++){const i=t.bodies[s];i.aabbNeedsUpdate&&i.updateAABB(),i.aabb.overlaps(e)&&n.push(i)}return n}}class ie{constructor(){this.rayFromWorld=new d,this.rayToWorld=new d,this.hitNormalWorld=new d,this.hitPointWorld=new d,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(t,e,n,s,i,o,r){this.rayFromWorld.copy(t),this.rayToWorld.copy(e),this.hitNormalWorld.copy(n),this.hitPointWorld.copy(s),this.shape=i,this.body=o,this.distance=r}}let cn,ln,hn,un,dn,pn,fn;const Se={CLOSEST:1,ANY:2,ALL:4};cn=z.types.SPHERE;ln=z.types.PLANE;hn=z.types.BOX;un=z.types.CYLINDER;dn=z.types.CONVEXPOLYHEDRON;pn=z.types.HEIGHTFIELD;fn=z.types.TRIMESH;class Y{get[cn](){return this._intersectSphere}get[ln](){return this._intersectPlane}get[hn](){return this._intersectBox}get[un](){return this._intersectConvex}get[dn](){return this._intersectConvex}get[pn](){return this._intersectHeightfield}get[fn](){return this._intersectTrimesh}constructor(t,e){t===void 0&&(t=new d),e===void 0&&(e=new d),this.from=t.clone(),this.to=e.clone(),this.direction=new d,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=Y.ANY,this.result=new ie,this.hasHit=!1,this.callback=n=>{}}intersectWorld(t,e){return this.mode=e.mode||Y.ANY,this.result=e.result||new ie,this.skipBackfaces=!!e.skipBackfaces,this.collisionFilterMask=typeof e.collisionFilterMask<"u"?e.collisionFilterMask:-1,this.collisionFilterGroup=typeof e.collisionFilterGroup<"u"?e.collisionFilterGroup:-1,this.checkCollisionResponse=typeof e.checkCollisionResponse<"u"?e.checkCollisionResponse:!0,e.from&&this.from.copy(e.from),e.to&&this.to.copy(e.to),this.callback=e.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(Ve),he.length=0,t.broadphase.aabbQuery(t,Ve,he),this.intersectBodies(he),this.hasHit}intersectBody(t,e){e&&(this.result=e,this.updateDirection());const n=this.checkCollisionResponse;if(n&&!t.collisionResponse||!(this.collisionFilterGroup&t.collisionFilterMask)||!(t.collisionFilterGroup&this.collisionFilterMask))return;const s=Ps,i=Fs;for(let o=0,r=t.shapes.length;o<r;o++){const a=t.shapes[o];if(!(n&&!a.collisionResponse)&&(t.quaternion.mult(t.shapeOrientations[o],i),t.quaternion.vmult(t.shapeOffsets[o],s),s.vadd(t.position,s),this.intersectShape(a,i,s,t),this.result.shouldStop))break}}intersectBodies(t,e){e&&(this.result=e,this.updateDirection());for(let n=0,s=t.length;!this.result.shouldStop&&n<s;n++)this.intersectBody(t[n])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(t,e,n,s){const i=this.from;if(js(i,this.direction,n)>t.boundingSphereRadius)return;const r=this[t.type];r&&r.call(this,t,e,n,s,t)}_intersectBox(t,e,n,s,i){return this._intersectConvex(t.convexPolyhedronRepresentation,e,n,s,i)}_intersectPlane(t,e,n,s,i){const o=this.from,r=this.to,a=this.direction,c=new d(0,0,1);e.vmult(c,c);const h=new d;o.vsub(n,h);const u=h.dot(c);r.vsub(n,h);const l=h.dot(c);if(u*l>0||o.distanceTo(r)<u)return;const p=c.dot(a);if(Math.abs(p)<this.precision)return;const f=new d,y=new d,v=new d;o.vsub(n,f);const g=-c.dot(f)/p;a.scale(g,y),o.vadd(y,v),this.reportIntersection(c,v,i,s,-1)}getAABB(t){const{lowerBound:e,upperBound:n}=t,s=this.to,i=this.from;e.x=Math.min(s.x,i.x),e.y=Math.min(s.y,i.y),e.z=Math.min(s.z,i.z),n.x=Math.max(s.x,i.x),n.y=Math.max(s.y,i.y),n.z=Math.max(s.z,i.z)}_intersectHeightfield(t,e,n,s,i){t.data,t.elementSize;const o=Is;o.from.copy(this.from),o.to.copy(this.to),V.pointToLocalFrame(n,e,o.from,o.from),V.pointToLocalFrame(n,e,o.to,o.to),o.updateDirection();const r=zs;let a,c,h,u;a=c=0,h=u=t.data.length-1;const l=new ot;o.getAABB(l),t.getIndexOfPosition(l.lowerBound.x,l.lowerBound.y,r,!0),a=Math.max(a,r[0]),c=Math.max(c,r[1]),t.getIndexOfPosition(l.upperBound.x,l.upperBound.y,r,!0),h=Math.min(h,r[0]+1),u=Math.min(u,r[1]+1);for(let p=a;p<h;p++)for(let f=c;f<u;f++){if(this.result.shouldStop)return;if(t.getAabbAtIndex(p,f,l),!!l.overlapsRay(o)){if(t.getConvexTrianglePillar(p,f,!1),V.pointToWorldFrame(n,e,t.pillarOffset,Zt),this._intersectConvex(t.pillarConvex,e,Zt,s,i,We),this.result.shouldStop)return;t.getConvexTrianglePillar(p,f,!0),V.pointToWorldFrame(n,e,t.pillarOffset,Zt),this._intersectConvex(t.pillarConvex,e,Zt,s,i,We)}}}_intersectSphere(t,e,n,s,i){const o=this.from,r=this.to,a=t.radius,c=(r.x-o.x)**2+(r.y-o.y)**2+(r.z-o.z)**2,h=2*((r.x-o.x)*(o.x-n.x)+(r.y-o.y)*(o.y-n.y)+(r.z-o.z)*(o.z-n.z)),u=(o.x-n.x)**2+(o.y-n.y)**2+(o.z-n.z)**2-a**2,l=h**2-4*c*u,p=Bs,f=Rs;if(!(l<0))if(l===0)o.lerp(r,l,p),p.vsub(n,f),f.normalize(),this.reportIntersection(f,p,i,s,-1);else{const y=(-h-Math.sqrt(l))/(2*c),v=(-h+Math.sqrt(l))/(2*c);if(y>=0&&y<=1&&(o.lerp(r,y,p),p.vsub(n,f),f.normalize(),this.reportIntersection(f,p,i,s,-1)),this.result.shouldStop)return;v>=0&&v<=1&&(o.lerp(r,v,p),p.vsub(n,f),f.normalize(),this.reportIntersection(f,p,i,s,-1))}}_intersectConvex(t,e,n,s,i,o){const r=Ls,a=je,c=o&&o.faceList||null,h=t.faces,u=t.vertices,l=t.faceNormals,p=this.direction,f=this.from,y=this.to,v=f.distanceTo(y),g=c?c.length:h.length,w=this.result;for(let x=0;!w.shouldStop&&x<g;x++){const b=c?c[x]:x,E=h[b],S=l[b],M=e,I=n;a.copy(u[E[0]]),M.vmult(a,a),a.vadd(I,a),a.vsub(f,a),M.vmult(S,r);const L=p.dot(r);if(Math.abs(L)<this.precision)continue;const R=r.dot(a)/L;if(!(R<0)){p.scale(R,et),et.vadd(f,et),at.copy(u[E[0]]),M.vmult(at,at),I.vadd(at,at);for(let F=1;!w.shouldStop&&F<E.length-1;F++){dt.copy(u[E[F]]),pt.copy(u[E[F+1]]),M.vmult(dt,dt),M.vmult(pt,pt),I.vadd(dt,dt),I.vadd(pt,pt);const _=et.distanceTo(f);!(Y.pointInTriangle(et,at,dt,pt)||Y.pointInTriangle(et,dt,at,pt))||_>v||this.reportIntersection(r,et,i,s,b)}}}}_intersectTrimesh(t,e,n,s,i,o){const r=ks,a=Vs,c=Ws,h=je,u=Ns,l=_s,p=Os,f=qs,y=Ds,v=t.indices;t.vertices;const g=this.from,w=this.to,x=this.direction;c.position.copy(n),c.quaternion.copy(e),V.vectorToLocalFrame(n,e,x,u),V.pointToLocalFrame(n,e,g,l),V.pointToLocalFrame(n,e,w,p),p.x*=t.scale.x,p.y*=t.scale.y,p.z*=t.scale.z,l.x*=t.scale.x,l.y*=t.scale.y,l.z*=t.scale.z,p.vsub(l,u),u.normalize();const b=l.distanceSquared(p);t.tree.rayQuery(this,c,a);for(let E=0,S=a.length;!this.result.shouldStop&&E!==S;E++){const M=a[E];t.getNormal(M,r),t.getVertex(v[M*3],at),at.vsub(l,h);const I=u.dot(r),L=r.dot(h)/I;if(L<0)continue;u.scale(L,et),et.vadd(l,et),t.getVertex(v[M*3+1],dt),t.getVertex(v[M*3+2],pt);const R=et.distanceSquared(l);!(Y.pointInTriangle(et,dt,at,pt)||Y.pointInTriangle(et,at,dt,pt))||R>b||(V.vectorToWorldFrame(e,r,y),V.pointToWorldFrame(n,e,et,f),this.reportIntersection(y,f,i,s,M))}a.length=0}reportIntersection(t,e,n,s,i){const o=this.from,r=this.to,a=o.distanceTo(e),c=this.result;if(!(this.skipBackfaces&&t.dot(this.direction)>0))switch(c.hitFaceIndex=typeof i<"u"?i:-1,this.mode){case Y.ALL:this.hasHit=!0,c.set(o,r,t,e,n,s,a),c.hasHit=!0,this.callback(c);break;case Y.CLOSEST:(a<c.distance||!c.hasHit)&&(this.hasHit=!0,c.hasHit=!0,c.set(o,r,t,e,n,s,a));break;case Y.ANY:this.hasHit=!0,c.hasHit=!0,c.set(o,r,t,e,n,s,a),c.shouldStop=!0;break}}static pointInTriangle(t,e,n,s){s.vsub(e,Ft),n.vsub(e,_t),t.vsub(e,ue);const i=Ft.dot(Ft),o=Ft.dot(_t),r=Ft.dot(ue),a=_t.dot(_t),c=_t.dot(ue);let h,u;return(h=a*r-o*c)>=0&&(u=i*c-o*r)>=0&&h+u<i*a-o*o}}Y.CLOSEST=Se.CLOSEST;Y.ANY=Se.ANY;Y.ALL=Se.ALL;const Ve=new ot,he=[],_t=new d,ue=new d,Ps=new d,Fs=new $,et=new d,at=new d,dt=new d,pt=new d;new d;new ie;const We={faceList:[0]},Zt=new d,Is=new Y,zs=[],Bs=new d,Rs=new d,Ls=new d;new d;new d;const je=new d,ks=new d,Ns=new d,_s=new d,Os=new d,Ds=new d,qs=new d;new ot;const Vs=[],Ws=new V,Ft=new d,Qt=new d;function js(m,t,e){e.vsub(m,Ft);const n=Ft.dot(t);return t.scale(n,Qt),Qt.vadd(m,Qt),e.distanceTo(Qt)}class Gs{static defaults(t,e){t===void 0&&(t={});for(let n in e)n in t||(t[n]=e[n]);return t}}class Ge{constructor(){this.spatial=new d,this.rotational=new d}multiplyElement(t){return t.spatial.dot(this.spatial)+t.rotational.dot(this.rotational)}multiplyVectors(t,e){return t.dot(this.spatial)+e.dot(this.rotational)}}class Ut{constructor(t,e,n,s){n===void 0&&(n=-1e6),s===void 0&&(s=1e6),this.id=Ut.idCounter++,this.minForce=n,this.maxForce=s,this.bi=t,this.bj=e,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new Ge,this.jacobianElementB=new Ge,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(t,e,n){const s=e,i=t,o=n;this.a=4/(o*(1+4*s)),this.b=4*s/(1+4*s),this.eps=4/(o*o*i*(1+4*s))}computeB(t,e,n){const s=this.computeGW(),i=this.computeGq(),o=this.computeGiMf();return-i*t-s*e-o*n}computeGq(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.position,o=s.position;return t.spatial.dot(i)+e.spatial.dot(o)}computeGW(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.velocity,o=s.velocity,r=n.angularVelocity,a=s.angularVelocity;return t.multiplyVectors(i,r)+e.multiplyVectors(o,a)}computeGWlambda(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.vlambda,o=s.vlambda,r=n.wlambda,a=s.wlambda;return t.multiplyVectors(i,r)+e.multiplyVectors(o,a)}computeGiMf(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.force,o=n.torque,r=s.force,a=s.torque,c=n.invMassSolve,h=s.invMassSolve;return i.scale(c,He),r.scale(h,Ue),n.invInertiaWorldSolve.vmult(o,Xe),s.invInertiaWorldSolve.vmult(a,Ye),t.multiplyVectors(He,Xe)+e.multiplyVectors(Ue,Ye)}computeGiMGt(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.invMassSolve,o=s.invMassSolve,r=n.invInertiaWorldSolve,a=s.invInertiaWorldSolve;let c=i+o;return r.vmult(t.rotational,Jt),c+=Jt.dot(t.rotational),a.vmult(e.rotational,Jt),c+=Jt.dot(e.rotational),c}addToWlambda(t){const e=this.jacobianElementA,n=this.jacobianElementB,s=this.bi,i=this.bj,o=Hs;s.vlambda.addScaledVector(s.invMassSolve*t,e.spatial,s.vlambda),i.vlambda.addScaledVector(i.invMassSolve*t,n.spatial,i.vlambda),s.invInertiaWorldSolve.vmult(e.rotational,o),s.wlambda.addScaledVector(t,o,s.wlambda),i.invInertiaWorldSolve.vmult(n.rotational,o),i.wlambda.addScaledVector(t,o,i.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}Ut.idCounter=0;const He=new d,Ue=new d,Xe=new d,Ye=new d,Jt=new d,Hs=new d;class Us extends Ut{constructor(t,e,n){n===void 0&&(n=1e6),super(t,e,0,n),this.restitution=0,this.ri=new d,this.rj=new d,this.ni=new d}computeB(t){const e=this.a,n=this.b,s=this.bi,i=this.bj,o=this.ri,r=this.rj,a=Xs,c=Ys,h=s.velocity,u=s.angularVelocity;s.force,s.torque;const l=i.velocity,p=i.angularVelocity;i.force,i.torque;const f=$s,y=this.jacobianElementA,v=this.jacobianElementB,g=this.ni;o.cross(g,a),r.cross(g,c),g.negate(y.spatial),a.negate(y.rotational),v.spatial.copy(g),v.rotational.copy(c),f.copy(i.position),f.vadd(r,f),f.vsub(s.position,f),f.vsub(o,f);const w=g.dot(f),x=this.restitution+1,b=x*l.dot(g)-x*h.dot(g)+p.dot(c)-u.dot(a),E=this.computeGiMf();return-w*e-b*n-t*E}getImpactVelocityAlongNormal(){const t=Ks,e=Zs,n=Qs,s=Js,i=ti;return this.bi.position.vadd(this.ri,n),this.bj.position.vadd(this.rj,s),this.bi.getVelocityAtWorldPoint(n,t),this.bj.getVelocityAtWorldPoint(s,e),t.vsub(e,i),this.ni.dot(i)}}const Xs=new d,Ys=new d,$s=new d,Ks=new d,Zs=new d,Qs=new d,Js=new d,ti=new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;class $e extends Ut{constructor(t,e,n){super(t,e,-n,n),this.ri=new d,this.rj=new d,this.t=new d}computeB(t){this.a;const e=this.b;this.bi,this.bj;const n=this.ri,s=this.rj,i=ei,o=ni,r=this.t;n.cross(r,i),s.cross(r,o);const a=this.jacobianElementA,c=this.jacobianElementB;r.negate(a.spatial),i.negate(a.rotational),c.spatial.copy(r),c.rotational.copy(o);const h=this.computeGW(),u=this.computeGiMf();return-h*e-t*u}}const ei=new d,ni=new d;class oe{constructor(t,e,n){n=Gs.defaults(n,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=oe.idCounter++,this.materials=[t,e],this.friction=n.friction,this.restitution=n.restitution,this.contactEquationStiffness=n.contactEquationStiffness,this.contactEquationRelaxation=n.contactEquationRelaxation,this.frictionEquationStiffness=n.frictionEquationStiffness,this.frictionEquationRelaxation=n.frictionEquationRelaxation}}oe.idCounter=0;class Xt{constructor(t){t===void 0&&(t={});let e="";typeof t=="string"&&(e=t,t={}),this.name=e,this.id=Xt.idCounter++,this.friction=typeof t.friction<"u"?t.friction:-1,this.restitution=typeof t.restitution<"u"?t.restitution:-1}}Xt.idCounter=0;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new Y;new d;new d;new d;new d(1,0,0),new d(0,1,0),new d(0,0,1);new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;class si extends z{constructor(t){if(super({type:z.types.SPHERE}),this.radius=t!==void 0?t:1,this.radius<0)throw new Error("The sphere radius cannot be negative.");this.updateBoundingSphereRadius()}calculateLocalInertia(t,e){e===void 0&&(e=new d);const n=2*t*this.radius*this.radius/5;return e.x=n,e.y=n,e.z=n,e}volume(){return 4*Math.PI*Math.pow(this.radius,3)/3}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateWorldAABB(t,e,n,s){const i=this.radius,o=["x","y","z"];for(let r=0;r<o.length;r++){const a=o[r];n[a]=t[a]-i,s[a]=t[a]+i}}}new d;new d;new d;new d;new d;new d;new d;new d;new d;class ii extends z{constructor(){super({type:z.types.PLANE}),this.worldNormal=new d,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}computeWorldNormal(t){const e=this.worldNormal;e.set(0,0,1),t.vmult(e,e),this.worldNormalNeedsUpdate=!1}calculateLocalInertia(t,e){return e===void 0&&(e=new d),e}volume(){return Number.MAX_VALUE}calculateWorldAABB(t,e,n,s){mt.set(0,0,1),e.vmult(mt,mt);const i=Number.MAX_VALUE;n.set(-i,-i,-i),s.set(i,i,i),mt.x===1?s.x=t.x:mt.x===-1&&(n.x=t.x),mt.y===1?s.y=t.y:mt.y===-1&&(n.y=t.y),mt.z===1?s.z=t.z:mt.z===-1&&(n.z=t.z)}updateBoundingSphereRadius(){this.boundingSphereRadius=Number.MAX_VALUE}}const mt=new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new ot;new d;new ot;new d;new d;new d;new d;new d;new d;new d;new ot;new d;new V;new ot;class oi{constructor(){this.equations=[]}solve(t,e){return 0}addEquation(t){t.enabled&&!t.bi.isTrigger&&!t.bj.isTrigger&&this.equations.push(t)}removeEquation(t){const e=this.equations,n=e.indexOf(t);n!==-1&&e.splice(n,1)}removeAllEquations(){this.equations.length=0}}class ri extends oi{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(t,e){let n=0;const s=this.iterations,i=this.tolerance*this.tolerance,o=this.equations,r=o.length,a=e.bodies,c=a.length,h=t;let u,l,p,f,y,v;if(r!==0)for(let b=0;b!==c;b++)a[b].updateSolveMassProperties();const g=ci,w=li,x=ai;g.length=r,w.length=r,x.length=r;for(let b=0;b!==r;b++){const E=o[b];x[b]=0,w[b]=E.computeB(h),g[b]=1/E.computeC()}if(r!==0){for(let S=0;S!==c;S++){const M=a[S],I=M.vlambda,L=M.wlambda;I.set(0,0,0),L.set(0,0,0)}for(n=0;n!==s;n++){f=0;for(let S=0;S!==r;S++){const M=o[S];u=w[S],l=g[S],v=x[S],y=M.computeGWlambda(),p=l*(u-y-M.eps*v),v+p<M.minForce?p=M.minForce-v:v+p>M.maxForce&&(p=M.maxForce-v),x[S]+=p,f+=p>0?p:-p,M.addToWlambda(p)}if(f*f<i)break}for(let S=0;S!==c;S++){const M=a[S],I=M.velocity,L=M.angularVelocity;M.vlambda.vmul(M.linearFactor,M.vlambda),I.vadd(M.vlambda,I),M.wlambda.vmul(M.angularFactor,M.wlambda),L.vadd(M.wlambda,L)}let b=o.length;const E=1/h;for(;b--;)o[b].multiplier=x[b]*E}return n}}const ai=[],ci=[],li=[];class hi{constructor(){this.objects=[],this.type=Object}release(){const t=arguments.length;for(let e=0;e!==t;e++)this.objects.push(e<0||arguments.length<=e?void 0:arguments[e]);return this}get(){return this.objects.length===0?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(t){const e=this.objects;for(;e.length>t;)e.pop();for(;e.length<t;)e.push(this.constructObject());return this}}class ui extends hi{constructor(){super(...arguments),this.type=d}constructObject(){return new d}}const j={sphereSphere:z.types.SPHERE,spherePlane:z.types.SPHERE|z.types.PLANE,boxBox:z.types.BOX|z.types.BOX,sphereBox:z.types.SPHERE|z.types.BOX,planeBox:z.types.PLANE|z.types.BOX,convexConvex:z.types.CONVEXPOLYHEDRON,sphereConvex:z.types.SPHERE|z.types.CONVEXPOLYHEDRON,planeConvex:z.types.PLANE|z.types.CONVEXPOLYHEDRON,boxConvex:z.types.BOX|z.types.CONVEXPOLYHEDRON,sphereHeightfield:z.types.SPHERE|z.types.HEIGHTFIELD,boxHeightfield:z.types.BOX|z.types.HEIGHTFIELD,convexHeightfield:z.types.CONVEXPOLYHEDRON|z.types.HEIGHTFIELD,sphereParticle:z.types.PARTICLE|z.types.SPHERE,planeParticle:z.types.PLANE|z.types.PARTICLE,boxParticle:z.types.BOX|z.types.PARTICLE,convexParticle:z.types.PARTICLE|z.types.CONVEXPOLYHEDRON,cylinderCylinder:z.types.CYLINDER,sphereCylinder:z.types.SPHERE|z.types.CYLINDER,planeCylinder:z.types.PLANE|z.types.CYLINDER,boxCylinder:z.types.BOX|z.types.CYLINDER,convexCylinder:z.types.CONVEXPOLYHEDRON|z.types.CYLINDER,heightfieldCylinder:z.types.HEIGHTFIELD|z.types.CYLINDER,particleCylinder:z.types.PARTICLE|z.types.CYLINDER,sphereTrimesh:z.types.SPHERE|z.types.TRIMESH,planeTrimesh:z.types.PLANE|z.types.TRIMESH};class di{get[j.sphereSphere](){return this.sphereSphere}get[j.spherePlane](){return this.spherePlane}get[j.boxBox](){return this.boxBox}get[j.sphereBox](){return this.sphereBox}get[j.planeBox](){return this.planeBox}get[j.convexConvex](){return this.convexConvex}get[j.sphereConvex](){return this.sphereConvex}get[j.planeConvex](){return this.planeConvex}get[j.boxConvex](){return this.boxConvex}get[j.sphereHeightfield](){return this.sphereHeightfield}get[j.boxHeightfield](){return this.boxHeightfield}get[j.convexHeightfield](){return this.convexHeightfield}get[j.sphereParticle](){return this.sphereParticle}get[j.planeParticle](){return this.planeParticle}get[j.boxParticle](){return this.boxParticle}get[j.convexParticle](){return this.convexParticle}get[j.cylinderCylinder](){return this.convexConvex}get[j.sphereCylinder](){return this.sphereConvex}get[j.planeCylinder](){return this.planeConvex}get[j.boxCylinder](){return this.boxConvex}get[j.convexCylinder](){return this.convexConvex}get[j.heightfieldCylinder](){return this.heightfieldCylinder}get[j.particleCylinder](){return this.particleCylinder}get[j.sphereTrimesh](){return this.sphereTrimesh}get[j.planeTrimesh](){return this.planeTrimesh}constructor(t){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new ui,this.world=t,this.currentContactMaterial=t.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(t,e,n,s,i,o){let r;this.contactPointPool.length?(r=this.contactPointPool.pop(),r.bi=t,r.bj=e):r=new Us(t,e),r.enabled=t.collisionResponse&&e.collisionResponse&&n.collisionResponse&&s.collisionResponse;const a=this.currentContactMaterial;r.restitution=a.restitution,r.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);const c=n.material||t.material,h=s.material||e.material;return c&&h&&c.restitution>=0&&h.restitution>=0&&(r.restitution=c.restitution*h.restitution),r.si=i||n,r.sj=o||s,r}createFrictionEquationsFromContact(t,e){const n=t.bi,s=t.bj,i=t.si,o=t.sj,r=this.world,a=this.currentContactMaterial;let c=a.friction;const h=i.material||n.material,u=o.material||s.material;if(h&&u&&h.friction>=0&&u.friction>=0&&(c=h.friction*u.friction),c>0){const l=c*(r.frictionGravity||r.gravity).length();let p=n.invMass+s.invMass;p>0&&(p=1/p);const f=this.frictionEquationPool,y=f.length?f.pop():new $e(n,s,l*p),v=f.length?f.pop():new $e(n,s,l*p);return y.bi=v.bi=n,y.bj=v.bj=s,y.minForce=v.minForce=-l*p,y.maxForce=v.maxForce=l*p,y.ri.copy(t.ri),y.rj.copy(t.rj),v.ri.copy(t.ri),v.rj.copy(t.rj),t.ni.tangents(y.t,v.t),y.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),v.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),y.enabled=v.enabled=t.enabled,e.push(y,v),!0}return!1}createFrictionFromAverage(t){let e=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(e,this.frictionResult)||t===1)return;const n=this.frictionResult[this.frictionResult.length-2],s=this.frictionResult[this.frictionResult.length-1];At.setZero(),Rt.setZero(),Lt.setZero();const i=e.bi;e.bj;for(let r=0;r!==t;r++)e=this.result[this.result.length-1-r],e.bi!==i?(At.vadd(e.ni,At),Rt.vadd(e.ri,Rt),Lt.vadd(e.rj,Lt)):(At.vsub(e.ni,At),Rt.vadd(e.rj,Rt),Lt.vadd(e.ri,Lt));const o=1/t;Rt.scale(o,n.ri),Lt.scale(o,n.rj),s.ri.copy(n.ri),s.rj.copy(n.rj),At.normalize(),At.tangents(n.t,s.t)}getContacts(t,e,n,s,i,o,r){this.contactPointPool=i,this.frictionEquationPool=r,this.result=s,this.frictionResult=o;const a=mi,c=vi,h=pi,u=fi;for(let l=0,p=t.length;l!==p;l++){const f=t[l],y=e[l];let v=null;f.material&&y.material&&(v=n.getContactMaterial(f.material,y.material)||null);const g=f.type&B.KINEMATIC&&y.type&B.STATIC||f.type&B.STATIC&&y.type&B.KINEMATIC||f.type&B.KINEMATIC&&y.type&B.KINEMATIC;for(let w=0;w<f.shapes.length;w++){f.quaternion.mult(f.shapeOrientations[w],a),f.quaternion.vmult(f.shapeOffsets[w],h),h.vadd(f.position,h);const x=f.shapes[w];for(let b=0;b<y.shapes.length;b++){y.quaternion.mult(y.shapeOrientations[b],c),y.quaternion.vmult(y.shapeOffsets[b],u),u.vadd(y.position,u);const E=y.shapes[b];if(!(x.collisionFilterMask&E.collisionFilterGroup&&E.collisionFilterMask&x.collisionFilterGroup)||h.distanceTo(u)>x.boundingSphereRadius+E.boundingSphereRadius)continue;let S=null;x.material&&E.material&&(S=n.getContactMaterial(x.material,E.material)||null),this.currentContactMaterial=S||v||n.defaultContactMaterial;const M=x.type|E.type,I=this[M];if(I){let L=!1;x.type<E.type?L=I.call(this,x,E,h,u,a,c,f,y,x,E,g):L=I.call(this,E,x,u,h,c,a,y,f,x,E,g),L&&g&&(n.shapeOverlapKeeper.set(x.id,E.id),n.bodyOverlapKeeper.set(f.id,y.id))}}}}}sphereSphere(t,e,n,s,i,o,r,a,c,h,u){if(u)return n.distanceSquared(s)<(t.radius+e.radius)**2;const l=this.createContactEquation(r,a,t,e,c,h);s.vsub(n,l.ni),l.ni.normalize(),l.ri.copy(l.ni),l.rj.copy(l.ni),l.ri.scale(t.radius,l.ri),l.rj.scale(-e.radius,l.rj),l.ri.vadd(n,l.ri),l.ri.vsub(r.position,l.ri),l.rj.vadd(s,l.rj),l.rj.vsub(a.position,l.rj),this.result.push(l),this.createFrictionEquationsFromContact(l,this.frictionResult)}spherePlane(t,e,n,s,i,o,r,a,c,h,u){const l=this.createContactEquation(r,a,t,e,c,h);if(l.ni.set(0,0,1),o.vmult(l.ni,l.ni),l.ni.negate(l.ni),l.ni.normalize(),l.ni.scale(t.radius,l.ri),n.vsub(s,te),l.ni.scale(l.ni.dot(te),Ke),te.vsub(Ke,l.rj),-te.dot(l.ni)<=t.radius){if(u)return!0;const p=l.ri,f=l.rj;p.vadd(n,p),p.vsub(r.position,p),f.vadd(s,f),f.vsub(a.position,f),this.result.push(l),this.createFrictionEquationsFromContact(l,this.frictionResult)}}boxBox(t,e,n,s,i,o,r,a,c,h,u){return t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e.convexPolyhedronRepresentation,n,s,i,o,r,a,t,e,u)}sphereBox(t,e,n,s,i,o,r,a,c,h,u){const l=this.v3pool,p=Wi;n.vsub(s,ee),e.getSideNormals(p,o);const f=t.radius;let y=!1;const v=Gi,g=Hi,w=Ui;let x=null,b=0,E=0,S=0,M=null;for(let C=0,W=p.length;C!==W&&y===!1;C++){const O=Di;O.copy(p[C]);const N=O.length();O.normalize();const Q=ee.dot(O);if(Q<N+f&&Q>0){const Z=qi,k=Vi;Z.copy(p[(C+1)%3]),k.copy(p[(C+2)%3]);const st=Z.length(),Tt=k.length();Z.normalize(),k.normalize();const ft=ee.dot(Z),Mt=ee.dot(k);if(ft<st&&ft>-st&&Mt<Tt&&Mt>-Tt){const zt=Math.abs(Q-N-f);if((M===null||zt<M)&&(M=zt,E=ft,S=Mt,x=N,v.copy(O),g.copy(Z),w.copy(k),b++,u))return!0}}}if(b){y=!0;const C=this.createContactEquation(r,a,t,e,c,h);v.scale(-f,C.ri),C.ni.copy(v),C.ni.negate(C.ni),v.scale(x,v),g.scale(E,g),v.vadd(g,v),w.scale(S,w),v.vadd(w,C.rj),C.ri.vadd(n,C.ri),C.ri.vsub(r.position,C.ri),C.rj.vadd(s,C.rj),C.rj.vsub(a.position,C.rj),this.result.push(C),this.createFrictionEquationsFromContact(C,this.frictionResult)}let I=l.get();const L=ji;for(let C=0;C!==2&&!y;C++)for(let W=0;W!==2&&!y;W++)for(let O=0;O!==2&&!y;O++)if(I.set(0,0,0),C?I.vadd(p[0],I):I.vsub(p[0],I),W?I.vadd(p[1],I):I.vsub(p[1],I),O?I.vadd(p[2],I):I.vsub(p[2],I),s.vadd(I,L),L.vsub(n,L),L.lengthSquared()<f*f){if(u)return!0;y=!0;const N=this.createContactEquation(r,a,t,e,c,h);N.ri.copy(L),N.ri.normalize(),N.ni.copy(N.ri),N.ri.scale(f,N.ri),N.rj.copy(I),N.ri.vadd(n,N.ri),N.ri.vsub(r.position,N.ri),N.rj.vadd(s,N.rj),N.rj.vsub(a.position,N.rj),this.result.push(N),this.createFrictionEquationsFromContact(N,this.frictionResult)}l.release(I),I=null;const R=l.get(),F=l.get(),_=l.get(),T=l.get(),P=l.get(),A=p.length;for(let C=0;C!==A&&!y;C++)for(let W=0;W!==A&&!y;W++)if(C%3!==W%3){p[W].cross(p[C],R),R.normalize(),p[C].vadd(p[W],F),_.copy(n),_.vsub(F,_),_.vsub(s,_);const O=_.dot(R);R.scale(O,T);let N=0;for(;N===C%3||N===W%3;)N++;P.copy(n),P.vsub(T,P),P.vsub(F,P),P.vsub(s,P);const Q=Math.abs(O),Z=P.length();if(Q<p[N].length()&&Z<f){if(u)return!0;y=!0;const k=this.createContactEquation(r,a,t,e,c,h);F.vadd(T,k.rj),k.rj.copy(k.rj),P.negate(k.ni),k.ni.normalize(),k.ri.copy(k.rj),k.ri.vadd(s,k.ri),k.ri.vsub(n,k.ri),k.ri.normalize(),k.ri.scale(f,k.ri),k.ri.vadd(n,k.ri),k.ri.vsub(r.position,k.ri),k.rj.vadd(s,k.rj),k.rj.vsub(a.position,k.rj),this.result.push(k),this.createFrictionEquationsFromContact(k,this.frictionResult)}}l.release(R,F,_,T,P)}planeBox(t,e,n,s,i,o,r,a,c,h,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,e.convexPolyhedronRepresentation.id=e.id,this.planeConvex(t,e.convexPolyhedronRepresentation,n,s,i,o,r,a,t,e,u)}convexConvex(t,e,n,s,i,o,r,a,c,h,u,l,p){const f=ao;if(!(n.distanceTo(s)>t.boundingSphereRadius+e.boundingSphereRadius)&&t.findSeparatingAxis(e,n,i,s,o,f,l,p)){const y=[],v=co;t.clipAgainstHull(n,i,e,s,o,f,-100,100,y);let g=0;for(let w=0;w!==y.length;w++){if(u)return!0;const x=this.createContactEquation(r,a,t,e,c,h),b=x.ri,E=x.rj;f.negate(x.ni),y[w].normal.negate(v),v.scale(y[w].depth,v),y[w].point.vadd(v,b),E.copy(y[w].point),b.vsub(n,b),E.vsub(s,E),b.vadd(n,b),b.vsub(r.position,b),E.vadd(s,E),E.vsub(a.position,E),this.result.push(x),g++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(x,this.frictionResult)}this.enableFrictionReduction&&g&&this.createFrictionFromAverage(g)}}sphereConvex(t,e,n,s,i,o,r,a,c,h,u){const l=this.v3pool;n.vsub(s,Xi);const p=e.faceNormals,f=e.faces,y=e.vertices,v=t.radius;let g=!1;for(let w=0;w!==y.length;w++){const x=y[w],b=Zi;o.vmult(x,b),s.vadd(b,b);const E=Ki;if(b.vsub(n,E),E.lengthSquared()<v*v){if(u)return!0;g=!0;const S=this.createContactEquation(r,a,t,e,c,h);S.ri.copy(E),S.ri.normalize(),S.ni.copy(S.ri),S.ri.scale(v,S.ri),b.vsub(s,S.rj),S.ri.vadd(n,S.ri),S.ri.vsub(r.position,S.ri),S.rj.vadd(s,S.rj),S.rj.vsub(a.position,S.rj),this.result.push(S),this.createFrictionEquationsFromContact(S,this.frictionResult);return}}for(let w=0,x=f.length;w!==x&&g===!1;w++){const b=p[w],E=f[w],S=Qi;o.vmult(b,S);const M=Ji;o.vmult(y[E[0]],M),M.vadd(s,M);const I=to;S.scale(-v,I),n.vadd(I,I);const L=eo;I.vsub(M,L);const R=L.dot(S),F=no;if(n.vsub(M,F),R<0&&F.dot(S)>0){const _=[];for(let T=0,P=E.length;T!==P;T++){const A=l.get();o.vmult(y[E[T]],A),s.vadd(A,A),_.push(A)}if(Oi(_,S,n)){if(u)return!0;g=!0;const T=this.createContactEquation(r,a,t,e,c,h);S.scale(-v,T.ri),S.negate(T.ni);const P=l.get();S.scale(-R,P);const A=l.get();S.scale(-v,A),n.vsub(s,T.rj),T.rj.vadd(A,T.rj),T.rj.vadd(P,T.rj),T.rj.vadd(s,T.rj),T.rj.vsub(a.position,T.rj),T.ri.vadd(n,T.ri),T.ri.vsub(r.position,T.ri),l.release(P),l.release(A),this.result.push(T),this.createFrictionEquationsFromContact(T,this.frictionResult);for(let C=0,W=_.length;C!==W;C++)l.release(_[C]);return}else for(let T=0;T!==E.length;T++){const P=l.get(),A=l.get();o.vmult(y[E[(T+1)%E.length]],P),o.vmult(y[E[(T+2)%E.length]],A),s.vadd(P,P),s.vadd(A,A);const C=Yi;A.vsub(P,C);const W=$i;C.unit(W);const O=l.get(),N=l.get();n.vsub(P,N);const Q=N.dot(W);W.scale(Q,O),O.vadd(P,O);const Z=l.get();if(O.vsub(n,Z),Q>0&&Q*Q<C.lengthSquared()&&Z.lengthSquared()<v*v){if(u)return!0;const k=this.createContactEquation(r,a,t,e,c,h);O.vsub(s,k.rj),O.vsub(n,k.ni),k.ni.normalize(),k.ni.scale(v,k.ri),k.rj.vadd(s,k.rj),k.rj.vsub(a.position,k.rj),k.ri.vadd(n,k.ri),k.ri.vsub(r.position,k.ri),this.result.push(k),this.createFrictionEquationsFromContact(k,this.frictionResult);for(let st=0,Tt=_.length;st!==Tt;st++)l.release(_[st]);l.release(P),l.release(A),l.release(O),l.release(Z),l.release(N);return}l.release(P),l.release(A),l.release(O),l.release(Z),l.release(N)}for(let T=0,P=_.length;T!==P;T++)l.release(_[T])}}}planeConvex(t,e,n,s,i,o,r,a,c,h,u){const l=so,p=io;p.set(0,0,1),i.vmult(p,p);let f=0;const y=oo;for(let v=0;v!==e.vertices.length;v++)if(l.copy(e.vertices[v]),o.vmult(l,l),s.vadd(l,l),l.vsub(n,y),p.dot(y)<=0){if(u)return!0;const w=this.createContactEquation(r,a,t,e,c,h),x=ro;p.scale(p.dot(y),x),l.vsub(x,x),x.vsub(n,w.ri),w.ni.copy(p),l.vsub(s,w.rj),w.ri.vadd(n,w.ri),w.ri.vsub(r.position,w.ri),w.rj.vadd(s,w.rj),w.rj.vsub(a.position,w.rj),this.result.push(w),f++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(w,this.frictionResult)}this.enableFrictionReduction&&f&&this.createFrictionFromAverage(f)}boxConvex(t,e,n,s,i,o,r,a,c,h,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e,n,s,i,o,r,a,t,e,u)}sphereHeightfield(t,e,n,s,i,o,r,a,c,h,u){const l=e.data,p=t.radius,f=e.elementSize,y=bo,v=xo;V.pointToLocalFrame(s,o,n,v);let g=Math.floor((v.x-p)/f)-1,w=Math.ceil((v.x+p)/f)+1,x=Math.floor((v.y-p)/f)-1,b=Math.ceil((v.y+p)/f)+1;if(w<0||b<0||g>l.length||x>l[0].length)return;g<0&&(g=0),w<0&&(w=0),x<0&&(x=0),b<0&&(b=0),g>=l.length&&(g=l.length-1),w>=l.length&&(w=l.length-1),b>=l[0].length&&(b=l[0].length-1),x>=l[0].length&&(x=l[0].length-1);const E=[];e.getRectMinMax(g,x,w,b,E);const S=E[0],M=E[1];if(v.z-p>M||v.z+p<S)return;const I=this.result;for(let L=g;L<w;L++)for(let R=x;R<b;R++){const F=I.length;let _=!1;if(e.getConvexTrianglePillar(L,R,!1),V.pointToWorldFrame(s,o,e.pillarOffset,y),n.distanceTo(y)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(_=this.sphereConvex(t,e.pillarConvex,n,y,i,o,r,a,t,e,u)),u&&_||(e.getConvexTrianglePillar(L,R,!0),V.pointToWorldFrame(s,o,e.pillarOffset,y),n.distanceTo(y)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(_=this.sphereConvex(t,e.pillarConvex,n,y,i,o,r,a,t,e,u)),u&&_))return!0;if(I.length-F>2)return}}boxHeightfield(t,e,n,s,i,o,r,a,c,h,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexHeightfield(t.convexPolyhedronRepresentation,e,n,s,i,o,r,a,t,e,u)}convexHeightfield(t,e,n,s,i,o,r,a,c,h,u){const l=e.data,p=e.elementSize,f=t.boundingSphereRadius,y=wo,v=go,g=yo;V.pointToLocalFrame(s,o,n,g);let w=Math.floor((g.x-f)/p)-1,x=Math.ceil((g.x+f)/p)+1,b=Math.floor((g.y-f)/p)-1,E=Math.ceil((g.y+f)/p)+1;if(x<0||E<0||w>l.length||b>l[0].length)return;w<0&&(w=0),x<0&&(x=0),b<0&&(b=0),E<0&&(E=0),w>=l.length&&(w=l.length-1),x>=l.length&&(x=l.length-1),E>=l[0].length&&(E=l[0].length-1),b>=l[0].length&&(b=l[0].length-1);const S=[];e.getRectMinMax(w,b,x,E,S);const M=S[0],I=S[1];if(!(g.z-f>I||g.z+f<M))for(let L=w;L<x;L++)for(let R=b;R<E;R++){let F=!1;if(e.getConvexTrianglePillar(L,R,!1),V.pointToWorldFrame(s,o,e.pillarOffset,y),n.distanceTo(y)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(F=this.convexConvex(t,e.pillarConvex,n,y,i,o,r,a,null,null,u,v,null)),u&&F||(e.getConvexTrianglePillar(L,R,!0),V.pointToWorldFrame(s,o,e.pillarOffset,y),n.distanceTo(y)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(F=this.convexConvex(t,e.pillarConvex,n,y,i,o,r,a,null,null,u,v,null)),u&&F))return!0}}sphereParticle(t,e,n,s,i,o,r,a,c,h,u){const l=po;if(l.set(0,0,1),s.vsub(n,l),l.lengthSquared()<=t.radius*t.radius){if(u)return!0;const f=this.createContactEquation(a,r,e,t,c,h);l.normalize(),f.rj.copy(l),f.rj.scale(t.radius,f.rj),f.ni.copy(l),f.ni.negate(f.ni),f.ri.set(0,0,0),this.result.push(f),this.createFrictionEquationsFromContact(f,this.frictionResult)}}planeParticle(t,e,n,s,i,o,r,a,c,h,u){const l=lo;l.set(0,0,1),r.quaternion.vmult(l,l);const p=ho;if(s.vsub(r.position,p),l.dot(p)<=0){if(u)return!0;const y=this.createContactEquation(a,r,e,t,c,h);y.ni.copy(l),y.ni.negate(y.ni),y.ri.set(0,0,0);const v=uo;l.scale(l.dot(s),v),s.vsub(v,v),y.rj.copy(v),this.result.push(y),this.createFrictionEquationsFromContact(y,this.frictionResult)}}boxParticle(t,e,n,s,i,o,r,a,c,h,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexParticle(t.convexPolyhedronRepresentation,e,n,s,i,o,r,a,t,e,u)}convexParticle(t,e,n,s,i,o,r,a,c,h,u){let l=-1;const p=mo,f=vo;let y=null;const v=fo;if(v.copy(s),v.vsub(n,v),i.conjugate(Ze),Ze.vmult(v,v),t.pointIsInside(v)){t.worldVerticesNeedsUpdate&&t.computeWorldVertices(n,i),t.worldFaceNormalsNeedsUpdate&&t.computeWorldFaceNormals(i);for(let g=0,w=t.faces.length;g!==w;g++){const x=[t.worldVertices[t.faces[g][0]]],b=t.worldFaceNormals[g];s.vsub(x[0],Qe);const E=-b.dot(Qe);if(y===null||Math.abs(E)<Math.abs(y)){if(u)return!0;y=E,l=g,p.copy(b)}}if(l!==-1){const g=this.createContactEquation(a,r,e,t,c,h);p.scale(y,f),f.vadd(s,f),f.vsub(n,f),g.rj.copy(f),p.negate(g.ni),g.ri.set(0,0,0);const w=g.ri,x=g.rj;w.vadd(s,w),w.vsub(a.position,w),x.vadd(n,x),x.vsub(r.position,x),this.result.push(g),this.createFrictionEquationsFromContact(g,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(t,e,n,s,i,o,r,a,c,h,u){return this.convexHeightfield(e,t,s,n,o,i,a,r,c,h,u)}particleCylinder(t,e,n,s,i,o,r,a,c,h,u){return this.convexParticle(e,t,s,n,o,i,a,r,c,h,u)}sphereTrimesh(t,e,n,s,i,o,r,a,c,h,u){const l=Ci,p=Ti,f=Mi,y=Ai,v=Pi,g=Fi,w=Ri,x=Si,b=bi,E=Li;V.pointToLocalFrame(s,o,n,v);const S=t.radius;w.lowerBound.set(v.x-S,v.y-S,v.z-S),w.upperBound.set(v.x+S,v.y+S,v.z+S),e.getTrianglesInAABB(w,E);const M=Ei,I=t.radius*t.radius;for(let T=0;T<E.length;T++)for(let P=0;P<3;P++)if(e.getVertex(e.indices[E[T]*3+P],M),M.vsub(v,b),b.lengthSquared()<=I){if(x.copy(M),V.pointToWorldFrame(s,o,x,M),M.vsub(n,b),u)return!0;let A=this.createContactEquation(r,a,t,e,c,h);A.ni.copy(b),A.ni.normalize(),A.ri.copy(A.ni),A.ri.scale(t.radius,A.ri),A.ri.vadd(n,A.ri),A.ri.vsub(r.position,A.ri),A.rj.copy(M),A.rj.vsub(a.position,A.rj),this.result.push(A),this.createFrictionEquationsFromContact(A,this.frictionResult)}for(let T=0;T<E.length;T++)for(let P=0;P<3;P++){e.getVertex(e.indices[E[T]*3+P],l),e.getVertex(e.indices[E[T]*3+(P+1)%3],p),p.vsub(l,f),v.vsub(p,g);const A=g.dot(f);v.vsub(l,g);let C=g.dot(f);if(C>0&&A<0&&(v.vsub(l,g),y.copy(f),y.normalize(),C=g.dot(y),y.scale(C,g),g.vadd(l,g),g.distanceTo(v)<t.radius)){if(u)return!0;const O=this.createContactEquation(r,a,t,e,c,h);g.vsub(v,O.ni),O.ni.normalize(),O.ni.scale(t.radius,O.ri),O.ri.vadd(n,O.ri),O.ri.vsub(r.position,O.ri),V.pointToWorldFrame(s,o,g,g),g.vsub(a.position,O.rj),V.vectorToWorldFrame(o,O.ni,O.ni),V.vectorToWorldFrame(o,O.ri,O.ri),this.result.push(O),this.createFrictionEquationsFromContact(O,this.frictionResult)}}const L=Ii,R=zi,F=Bi,_=xi;for(let T=0,P=E.length;T!==P;T++){e.getTriangleVertices(E[T],L,R,F),e.getNormal(E[T],_),v.vsub(L,g);let A=g.dot(_);if(_.scale(A,g),v.vsub(g,g),A=g.distanceTo(v),Y.pointInTriangle(g,L,R,F)&&A<t.radius){if(u)return!0;let C=this.createContactEquation(r,a,t,e,c,h);g.vsub(v,C.ni),C.ni.normalize(),C.ni.scale(t.radius,C.ri),C.ri.vadd(n,C.ri),C.ri.vsub(r.position,C.ri),V.pointToWorldFrame(s,o,g,g),g.vsub(a.position,C.rj),V.vectorToWorldFrame(o,C.ni,C.ni),V.vectorToWorldFrame(o,C.ri,C.ri),this.result.push(C),this.createFrictionEquationsFromContact(C,this.frictionResult)}}E.length=0}planeTrimesh(t,e,n,s,i,o,r,a,c,h,u){const l=new d,p=yi;p.set(0,0,1),i.vmult(p,p);for(let f=0;f<e.vertices.length/3;f++){e.getVertex(f,l);const y=new d;y.copy(l),V.pointToWorldFrame(s,o,y,l);const v=wi;if(l.vsub(n,v),p.dot(v)<=0){if(u)return!0;const w=this.createContactEquation(r,a,t,e,c,h);w.ni.copy(p);const x=gi;p.scale(v.dot(p),x),l.vsub(x,x),w.ri.copy(x),w.ri.vsub(r.position,w.ri),w.rj.copy(l),w.rj.vsub(a.position,w.rj),this.result.push(w),this.createFrictionEquationsFromContact(w,this.frictionResult)}}}}const At=new d,Rt=new d,Lt=new d,pi=new d,fi=new d,mi=new $,vi=new $,yi=new d,wi=new d,gi=new d,xi=new d,bi=new d;new d;const Ei=new d,Si=new d,Ci=new d,Ti=new d,Mi=new d,Ai=new d,Pi=new d,Fi=new d,Ii=new d,zi=new d,Bi=new d,Ri=new ot,Li=[],te=new d,Ke=new d,ki=new d,Ni=new d,_i=new d;function Oi(m,t,e){let n=null;const s=m.length;for(let i=0;i!==s;i++){const o=m[i],r=ki;m[(i+1)%s].vsub(o,r);const a=Ni;r.cross(t,a);const c=_i;e.vsub(o,c);const h=a.dot(c);if(n===null||h>0&&n===!0||h<=0&&n===!1){n===null&&(n=h>0);continue}else return!1}return!0}const ee=new d,Di=new d,qi=new d,Vi=new d,Wi=[new d,new d,new d,new d,new d,new d],ji=new d,Gi=new d,Hi=new d,Ui=new d,Xi=new d,Yi=new d,$i=new d,Ki=new d,Zi=new d,Qi=new d,Ji=new d,to=new d,eo=new d,no=new d;new d;new d;const so=new d,io=new d,oo=new d,ro=new d,ao=new d,co=new d,lo=new d,ho=new d,uo=new d,po=new d,Ze=new $,fo=new d;new d;const mo=new d,Qe=new d,vo=new d,yo=new d,wo=new d,go=[0],xo=new d,bo=new d;class Je{constructor(){this.current=[],this.previous=[]}getKey(t,e){if(e<t){const n=e;e=t,t=n}return t<<16|e}set(t,e){const n=this.getKey(t,e),s=this.current;let i=0;for(;n>s[i];)i++;if(n!==s[i]){for(let o=s.length-1;o>=i;o--)s[o+1]=s[o];s[i]=n}}tick(){const t=this.current;this.current=this.previous,this.previous=t,this.current.length=0}getDiff(t,e){const n=this.current,s=this.previous,i=n.length,o=s.length;let r=0;for(let a=0;a<i;a++){let c=!1;const h=n[a];for(;h>s[r];)r++;c=h===s[r],c||tn(t,h)}r=0;for(let a=0;a<o;a++){let c=!1;const h=s[a];for(;h>n[r];)r++;c=n[r]===h,c||tn(e,h)}}}function tn(m,t){m.push((t&4294901760)>>16,t&65535)}const de=(m,t)=>m<t?`${m}-${t}`:`${t}-${m}`;class Eo{constructor(){this.data={keys:[]}}get(t,e){const n=de(t,e);return this.data[n]}set(t,e,n){const s=de(t,e);this.get(t,e)||this.data.keys.push(s),this.data[s]=n}delete(t,e){const n=de(t,e),s=this.data.keys.indexOf(n);s!==-1&&this.data.keys.splice(s,1),delete this.data[n]}reset(){const t=this.data,e=t.keys;for(;e.length>0;){const n=e.pop();delete t[n]}}}class So extends on{constructor(t){t===void 0&&(t={}),super(),this.dt=-1,this.allowSleep=!!t.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=t.quatNormalizeSkip!==void 0?t.quatNormalizeSkip:0,this.quatNormalizeFast=t.quatNormalizeFast!==void 0?t.quatNormalizeFast:!1,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new d,t.gravity&&this.gravity.copy(t.gravity),t.frictionGravity&&(this.frictionGravity=new d,this.frictionGravity.copy(t.frictionGravity)),this.broadphase=t.broadphase!==void 0?t.broadphase:new an,this.bodies=[],this.hasActiveBodies=!1,this.solver=t.solver!==void 0?t.solver:new ri,this.constraints=[],this.narrowphase=new di(this),this.collisionMatrix=new De,this.collisionMatrixPrevious=new De,this.bodyOverlapKeeper=new Je,this.shapeOverlapKeeper=new Je,this.contactmaterials=[],this.contactMaterialTable=new Eo,this.defaultMaterial=new Xt("default"),this.defaultContactMaterial=new oe(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(t,e){return this.contactMaterialTable.get(t.id,e.id)}collisionMatrixTick(){const t=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=t,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(t){this.constraints.push(t)}removeConstraint(t){const e=this.constraints.indexOf(t);e!==-1&&this.constraints.splice(e,1)}rayTest(t,e,n){n instanceof ie?this.raycastClosest(t,e,{skipBackfaces:!0},n):this.raycastAll(t,e,{skipBackfaces:!0},n)}raycastAll(t,e,n,s){return n===void 0&&(n={}),n.mode=Y.ALL,n.from=t,n.to=e,n.callback=s,pe.intersectWorld(this,n)}raycastAny(t,e,n,s){return n===void 0&&(n={}),n.mode=Y.ANY,n.from=t,n.to=e,n.result=s,pe.intersectWorld(this,n)}raycastClosest(t,e,n,s){return n===void 0&&(n={}),n.mode=Y.CLOSEST,n.from=t,n.to=e,n.result=s,pe.intersectWorld(this,n)}addBody(t){this.bodies.includes(t)||(t.index=this.bodies.length,this.bodies.push(t),t.world=this,t.initPosition.copy(t.position),t.initVelocity.copy(t.velocity),t.timeLastSleepy=this.time,t instanceof B&&(t.initAngularVelocity.copy(t.angularVelocity),t.initQuaternion.copy(t.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=t,this.idToBodyMap[t.id]=t,this.dispatchEvent(this.addBodyEvent))}removeBody(t){t.world=null;const e=this.bodies.length-1,n=this.bodies,s=n.indexOf(t);if(s!==-1){n.splice(s,1);for(let i=0;i!==n.length;i++)n[i].index=i;this.collisionMatrix.setNumObjects(e),this.removeBodyEvent.body=t,delete this.idToBodyMap[t.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(t){return this.idToBodyMap[t]}getShapeById(t){const e=this.bodies;for(let n=0;n<e.length;n++){const s=e[n].shapes;for(let i=0;i<s.length;i++){const o=s[i];if(o.id===t)return o}}return null}addContactMaterial(t){this.contactmaterials.push(t),this.contactMaterialTable.set(t.materials[0].id,t.materials[1].id,t)}removeContactMaterial(t){const e=this.contactmaterials.indexOf(t);e!==-1&&(this.contactmaterials.splice(e,1),this.contactMaterialTable.delete(t.materials[0].id,t.materials[1].id))}fixedStep(t,e){t===void 0&&(t=1/60),e===void 0&&(e=10);const n=K.now()/1e3;if(!this.lastCallTime)this.step(t,void 0,e);else{const s=n-this.lastCallTime;this.step(t,s,e)}this.lastCallTime=n}step(t,e,n){if(n===void 0&&(n=10),e===void 0)this.internalStep(t),this.time+=t;else{this.accumulator+=e;const s=K.now();let i=0;for(;this.accumulator>=t&&i<n&&(this.internalStep(t),this.accumulator-=t,i++,!(K.now()-s>t*1e3)););this.accumulator=this.accumulator%t;const o=this.accumulator/t;for(let r=0;r!==this.bodies.length;r++){const a=this.bodies[r];a.previousPosition.lerp(a.position,o,a.interpolatedPosition),a.previousQuaternion.slerp(a.quaternion,o,a.interpolatedQuaternion),a.previousQuaternion.normalize()}this.time+=e}}internalStep(t){this.dt=t;const e=this.contacts,n=Po,s=Fo,i=this.bodies.length,o=this.bodies,r=this.solver,a=this.gravity,c=this.doProfiling,h=this.profile,u=B.DYNAMIC;let l=-1/0;const p=this.constraints,f=Ao;a.length();const y=a.x,v=a.y,g=a.z;let w=0;for(c&&(l=K.now()),w=0;w!==i;w++){const T=o[w];if(T.type===u){const P=T.force,A=T.mass;P.x+=A*y,P.y+=A*v,P.z+=A*g}}for(let T=0,P=this.subsystems.length;T!==P;T++)this.subsystems[T].update();c&&(l=K.now()),n.length=0,s.length=0,this.broadphase.collisionPairs(this,n,s),c&&(h.broadphase=K.now()-l);let x=p.length;for(w=0;w!==x;w++){const T=p[w];if(!T.collideConnected)for(let P=n.length-1;P>=0;P-=1)(T.bodyA===n[P]&&T.bodyB===s[P]||T.bodyB===n[P]&&T.bodyA===s[P])&&(n.splice(P,1),s.splice(P,1))}this.collisionMatrixTick(),c&&(l=K.now());const b=Mo,E=e.length;for(w=0;w!==E;w++)b.push(e[w]);e.length=0;const S=this.frictionEquations.length;for(w=0;w!==S;w++)f.push(this.frictionEquations[w]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(n,s,this,e,b,this.frictionEquations,f),c&&(h.narrowphase=K.now()-l),c&&(l=K.now()),w=0;w<this.frictionEquations.length;w++)r.addEquation(this.frictionEquations[w]);const M=e.length;for(let T=0;T!==M;T++){const P=e[T],A=P.bi,C=P.bj,W=P.si,O=P.sj;let N;if(A.material&&C.material?N=this.getContactMaterial(A.material,C.material)||this.defaultContactMaterial:N=this.defaultContactMaterial,N.friction,A.material&&C.material&&(A.material.friction>=0&&C.material.friction>=0&&A.material.friction*C.material.friction,A.material.restitution>=0&&C.material.restitution>=0&&(P.restitution=A.material.restitution*C.material.restitution)),r.addEquation(P),A.allowSleep&&A.type===B.DYNAMIC&&A.sleepState===B.SLEEPING&&C.sleepState===B.AWAKE&&C.type!==B.STATIC){const Q=C.velocity.lengthSquared()+C.angularVelocity.lengthSquared(),Z=C.sleepSpeedLimit**2;Q>=Z*2&&(A.wakeUpAfterNarrowphase=!0)}if(C.allowSleep&&C.type===B.DYNAMIC&&C.sleepState===B.SLEEPING&&A.sleepState===B.AWAKE&&A.type!==B.STATIC){const Q=A.velocity.lengthSquared()+A.angularVelocity.lengthSquared(),Z=A.sleepSpeedLimit**2;Q>=Z*2&&(C.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(A,C,!0),this.collisionMatrixPrevious.get(A,C)||(Ot.body=C,Ot.contact=P,A.dispatchEvent(Ot),Ot.body=A,C.dispatchEvent(Ot)),this.bodyOverlapKeeper.set(A.id,C.id),this.shapeOverlapKeeper.set(W.id,O.id)}for(this.emitContactEvents(),c&&(h.makeContactConstraints=K.now()-l,l=K.now()),w=0;w!==i;w++){const T=o[w];T.wakeUpAfterNarrowphase&&(T.wakeUp(),T.wakeUpAfterNarrowphase=!1)}for(x=p.length,w=0;w!==x;w++){const T=p[w];T.update();for(let P=0,A=T.equations.length;P!==A;P++){const C=T.equations[P];r.addEquation(C)}}r.solve(t,this),c&&(h.solve=K.now()-l),r.removeAllEquations();const I=Math.pow;for(w=0;w!==i;w++){const T=o[w];if(T.type&u){const P=I(1-T.linearDamping,t),A=T.velocity;A.scale(P,A);const C=T.angularVelocity;if(C){const W=I(1-T.angularDamping,t);C.scale(W,C)}}}this.dispatchEvent(To),c&&(l=K.now());const R=this.stepnumber%(this.quatNormalizeSkip+1)===0,F=this.quatNormalizeFast;for(w=0;w!==i;w++)o[w].integrate(t,R,F);this.clearForces(),this.broadphase.dirty=!0,c&&(h.integrate=K.now()-l),this.stepnumber+=1,this.dispatchEvent(Co);let _=!0;if(this.allowSleep)for(_=!1,w=0;w!==i;w++){const T=o[w];T.sleepTick(this.time),T.sleepState!==B.SLEEPING&&(_=!0)}this.hasActiveBodies=_}emitContactEvents(){const t=this.hasAnyEventListener("beginContact"),e=this.hasAnyEventListener("endContact");if((t||e)&&this.bodyOverlapKeeper.getDiff(vt,yt),t){for(let i=0,o=vt.length;i<o;i+=2)Dt.bodyA=this.getBodyById(vt[i]),Dt.bodyB=this.getBodyById(vt[i+1]),this.dispatchEvent(Dt);Dt.bodyA=Dt.bodyB=null}if(e){for(let i=0,o=yt.length;i<o;i+=2)qt.bodyA=this.getBodyById(yt[i]),qt.bodyB=this.getBodyById(yt[i+1]),this.dispatchEvent(qt);qt.bodyA=qt.bodyB=null}vt.length=yt.length=0;const n=this.hasAnyEventListener("beginShapeContact"),s=this.hasAnyEventListener("endShapeContact");if((n||s)&&this.shapeOverlapKeeper.getDiff(vt,yt),n){for(let i=0,o=vt.length;i<o;i+=2){const r=this.getShapeById(vt[i]),a=this.getShapeById(vt[i+1]);wt.shapeA=r,wt.shapeB=a,r&&(wt.bodyA=r.body),a&&(wt.bodyB=a.body),this.dispatchEvent(wt)}wt.bodyA=wt.bodyB=wt.shapeA=wt.shapeB=null}if(s){for(let i=0,o=yt.length;i<o;i+=2){const r=this.getShapeById(yt[i]),a=this.getShapeById(yt[i+1]);gt.shapeA=r,gt.shapeB=a,r&&(gt.bodyA=r.body),a&&(gt.bodyB=a.body),this.dispatchEvent(gt)}gt.bodyA=gt.bodyB=gt.shapeA=gt.shapeB=null}}clearForces(){const t=this.bodies,e=t.length;for(let n=0;n!==e;n++){const s=t[n];s.force,s.torque,s.force.set(0,0,0),s.torque.set(0,0,0)}}}new ot;const pe=new Y,K=globalThis.performance||{};if(!K.now){let m=Date.now();K.timing&&K.timing.navigationStart&&(m=K.timing.navigationStart),K.now=()=>Date.now()-m}new d;const Co={type:"postStep"},To={type:"preStep"},Ot={type:B.COLLIDE_EVENT_NAME,body:null,contact:null},Mo=[],Ao=[],Po=[],Fo=[],vt=[],yt=[],Dt={type:"beginContact",bodyA:null,bodyB:null},qt={type:"endContact",bodyA:null,bodyB:null},wt={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},gt={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};class Io{constructor(t){q(this,"scene");q(this,"world");q(this,"bodies");q(this,"meshes");this.scene=t,this.world=new So,this.bodies=new Map,this.meshes=new Map,this.world.gravity.set(0,-9.82,0),this.world.broadphase=new an,this.world.solver.iterations=20}addBody(...t){t.forEach(e=>{this.scene.add(e.mesh),this.world.addBody(e.body),this.bodies.set(e.mesh.uuid,e.body),this.meshes.set(e.body.id,e.mesh)})}update(t){this.world.step(t),this.bodies.forEach(e=>{const n=this.meshes.get(e.id);n&&(n.position.copy(e.position),n.quaternion.copy(e.quaternion))})}}class zo{constructor({size:t=4,position:e={x:0,y:20,z:0},rotation:n={pitch:0,yaw:0,roll:0}}={}){q(this,"mesh");q(this,"body");const s=new G.BoxGeometry(t,t,t),i=new G.MeshStandardMaterial({color:65280});this.mesh=new G.Mesh(s,i);const o=new xe(new d(t/2,t/2,t/2));this.body=new B({mass:1,shape:o,material:new Xt({friction:.3,restitution:.7})}),this.body.position.set(e.x,e.y,e.z),this.body.quaternion.setFromEuler((n==null?void 0:n.pitch)||0,(n==null?void 0:n.yaw)||0,(n==null?void 0:n.roll)||0,"XYZ"),this.mesh.position.copy(this.body.position),this.mesh.quaternion.copy(this.body.quaternion)}}class Bo{constructor(){q(this,"mesh");q(this,"body");const t=new G.PlaneGeometry(1e3,1e3),e=new G.MeshStandardMaterial({color:8947848});this.mesh=new G.Mesh(t,e),this.mesh.rotation.x=-Math.PI/2,this.mesh.receiveShadow=!0;const n=new ii;this.body=new B({mass:0}),this.body.addShape(n),this.body.quaternion.setFromAxisAngle(new d(1,0,0),-Math.PI/2)}}class re extends sn{constructor(){const t=re.SkyShader,e=new Fn({name:t.name,uniforms:zn.clone(t.uniforms),vertexShader:t.vertexShader,fragmentShader:t.fragmentShader,side:In,depthWrite:!1});super(new Bn(1,1,1),e),this.isSky=!0}}re.SkyShader={name:"SkyShader",uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new nt},up:{value:new nt(0,1,0)}},vertexShader:`
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calculation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorption + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`,fragmentShader:`
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`};class Ce{constructor(t,e){q(this,"mesh");q(this,"body");this.mesh=t,this.body=e}static create({model:t,position:e={x:0,y:0,z:0},rotation:n={pitch:0,yaw:0,roll:0}}){const s=t.children[0],i=new G.Box3().setFromObject(t),o=new G.Vector3;i.getSize(o);const r=new xe(new d(o.x/2,o.y/2,o.z/2)),a=new B({mass:0,shape:r,position:new d(e.x,e.y+o.y/2,e.z)});return a.quaternion.setFromEuler(n.pitch,n.yaw,n.roll,"XYZ"),s.position.copy(a.position),s.quaternion.copy(a.quaternion),new Ce(s,a)}}class Ro{constructor(){q(this,"scene");q(this,"camera");q(this,"renderer");q(this,"physicsWorld");q(this,"clock");this.scene=new G.Scene,this.camera=new G.PerspectiveCamera(60,window.innerWidth/window.innerHeight,.1,1e3),this.renderer=new G.WebGLRenderer({antialias:!0}),this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=G.PCFSoftShadowMap,this.physicsWorld=new Io(this.scene),this.clock=new G.Clock,this.init()}init(){this.renderer.setSize(window.innerWidth,window.innerHeight),this.renderer.setPixelRatio(window.devicePixelRatio),this.physicsWorld.addBody(...Gt.assets.map(a=>Ce.create({model:a})),...Array.from({length:10}).map((a,c)=>new zo({size:.2+2*Math.random(),position:{x:0+5*Math.random(),y:100+c*10,z:0},rotation:{pitch:Math.PI*Math.random(),yaw:0,roll:0}})),new Bo);const t=new G.HemisphereLight(16777147,526368,.6),e=new G.DirectionalLight(16777215,1.2),n=new re;n.scale.setScalar(1e3),this.scene.add(n);const s=n.material.uniforms;s.turbidity.value=5,s.rayleigh.value=1.5,s.mieCoefficient.value=.005,s.mieDirectionalG.value=.8;const i=new G.Vector3,o=G.MathUtils.degToRad(90),r=G.MathUtils.degToRad(180);i.setFromSphericalCoords(1,o,r),e.position.copy(i),s.sunPosition.value.copy(i),this.scene.add(t,e)}update(){const t=this.clock.getDelta();this.physicsWorld.update(t)}render(){this.renderer.render(this.scene,this.camera)}onWindowResize(){const t=window.innerWidth,e=window.innerHeight;this.camera.aspect=t/e,this.camera.updateProjectionMatrix(),this.renderer.setSize(t,e)}}class Lo{constructor({position:t}){q(this,"mesh");q(this,"body");this.mesh=new G.Mesh(new G.SphereGeometry(2),new G.MeshStandardMaterial),this.body=new B({mass:0,shape:new si(2),position:new d(t.x,t.y,t.z)}),this.mesh.visible=!1,this.mesh.position.copy(this.body.position),this.mesh.quaternion.copy(this.body.quaternion)}}class ko{constructor(t,e){q(this,"sceneManager");q(this,"camera");q(this,"moveSpeed");q(this,"lookSpeed");q(this,"pitch");q(this,"yaw");q(this,"locked",!1);q(this,"keys",{});q(this,"cameraBody",null);this.sceneManager=e,this.camera=t,this.moveSpeed=.1,this.lookSpeed=.002,this.camera.position.set(25,1.7,-25),this.camera.lookAt(0,0,0);const n=new G.Euler().setFromQuaternion(this.camera.quaternion,"YXZ");this.pitch=n.x,this.yaw=n.y,this.setupEventListeners(),this.initCameraBody()}initCameraBody(){this.cameraBody=new Lo({position:this.camera.position}),this.sceneManager.physicsWorld.addBody(this.cameraBody)}update(){const t=new G.Vector3(0,0,-1);t.applyQuaternion(this.camera.quaternion),t.y=0,t.normalize();const e=new G.Vector3(1,0,0);e.applyQuaternion(this.camera.quaternion),e.y=0,e.normalize(),this.keys.w&&this.camera.position.add(t.multiplyScalar(this.moveSpeed)),this.keys.s&&this.camera.position.add(t.multiplyScalar(-this.moveSpeed)),this.keys.a&&this.camera.position.add(e.multiplyScalar(-this.moveSpeed)),this.keys.d&&this.camera.position.add(e.multiplyScalar(this.moveSpeed)),this.cameraBody&&this.cameraBody.body.position.copy(new d(this.camera.position.x,this.camera.position.y,this.camera.position.z))}onWindowResize(){this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix()}onMouseMove(t){this.locked&&(this.yaw-=t.movementX*this.lookSpeed,this.pitch-=t.movementY*this.lookSpeed,this.pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.pitch)),this.camera.quaternion.setFromEuler(new G.Euler(this.pitch,this.yaw,0,"YXZ")),this.cameraBody&&this.cameraBody.body.position.copy(new d(this.camera.position.x,this.camera.position.y,this.camera.position.z)))}setKeyState(t,e){this.keys[t]=e}setupEventListeners(){document.addEventListener("keydown",t=>{this.locked&&this.setKeyState(t.key,!0)}),document.addEventListener("keyup",t=>{this.locked&&this.setKeyState(t.key,!1)}),document.addEventListener("pointerlockchange",()=>{this.locked=!!document.pointerLockElement;const t=document.querySelector(".tip");t&&(t.style.display=this.locked?"none":"block")}),document.addEventListener("mousemove",this.onMouseMove.bind(this)),document.addEventListener("click",()=>{document.pointerLockElement||this.sceneManager.renderer.domElement.requestPointerLock()})}}class No{constructor(){q(this,"startTime");q(this,"frames");q(this,"dom");this.startTime=Date.now(),this.frames=0,this.dom=document.createElement("div"),this.dom.classList.add("stats")}update(){this.frames++;const t=Date.now()-this.startTime;if(t>=1e3){const e=this.frames/t*1e3;this.dom.textContent=`FPS: ${e.toFixed(2)}`,this.startTime=Date.now(),this.frames=0}}}const It=class It{constructor(){q(this,"sceneManager");q(this,"camera");q(this,"stats");this.sceneManager=new Ro,this.camera=new ko(this.sceneManager.camera,this.sceneManager),this.stats=new No,this.init(),this.animate()}static initialize(){It.instance||(It.instance=new It)}init(){document.body.appendChild(this.sceneManager.renderer.domElement),document.body.appendChild(this.stats.dom),window.addEventListener("resize",this.onWindowResize.bind(this))}animate(){requestAnimationFrame(this.animate.bind(this)),this.sceneManager.update(),this.camera.update(),this.sceneManager.render(),this.stats.update()}onWindowResize(){this.sceneManager.onWindowResize(),this.camera.onWindowResize()}};q(It,"assets",[]),q(It,"instance");let Gt=It;const _o="./models/",mn=m=>`${_o}${m}`,Oo=async m=>{let t=0;const e=()=>{const o=t/m.length*100;document.querySelector(".progress-fill").style.width=`${o}%`},n=document.querySelector(".loading-screen"),s=document.querySelector(".status-text"),i=document.querySelector(".progress-fill");try{const o=m.map(a=>a.loader(mn(a.path),{name:a.name,onProgress:c=>{s.textContent=` ${a.name} (${c.toFixed(1)}%)`,c===100&&(t++,e())},sourcePath:a.sourcePath})),r=await Promise.allSettled(o);return n.style.display="none",r.filter(a=>a.status==="fulfilled").map(a=>a.value)}catch(o){return console.error(o),s.textContent="",s.classList.add("error-text"),i.style.background="#ff4444",[]}};new xt;new U;/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.8.2
*/var rt=Uint8Array,Nt=Uint16Array,Do=Int32Array,vn=new rt([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),yn=new rt([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),qo=new rt([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),wn=function(m,t){for(var e=new Nt(31),n=0;n<31;++n)e[n]=t+=1<<m[n-1];for(var s=new Do(e[30]),n=1;n<30;++n)for(var i=e[n];i<e[n+1];++i)s[i]=i-e[n]<<5|n;return{b:e,r:s}},gn=wn(vn,2),xn=gn.b,Vo=gn.r;xn[28]=258,Vo[258]=28;var Wo=wn(yn,0),jo=Wo.b,ge=new Nt(32768);for(var H=0;H<32768;++H){var St=(H&43690)>>1|(H&21845)<<1;St=(St&52428)>>2|(St&13107)<<2,St=(St&61680)>>4|(St&3855)<<4,ge[H]=((St&65280)>>8|(St&255)<<8)>>1}var Wt=function(m,t,e){for(var n=m.length,s=0,i=new Nt(t);s<n;++s)m[s]&&++i[m[s]-1];var o=new Nt(t);for(s=1;s<t;++s)o[s]=o[s-1]+i[s-1]<<1;var r;if(e){r=new Nt(1<<t);var a=15-t;for(s=0;s<n;++s)if(m[s])for(var c=s<<4|m[s],h=t-m[s],u=o[m[s]-1]++<<h,l=u|(1<<h)-1;u<=l;++u)r[ge[u]>>a]=c}else for(r=new Nt(n),s=0;s<n;++s)m[s]&&(r[s]=ge[o[m[s]-1]++]>>15-m[s]);return r},Yt=new rt(288);for(var H=0;H<144;++H)Yt[H]=8;for(var H=144;H<256;++H)Yt[H]=9;for(var H=256;H<280;++H)Yt[H]=7;for(var H=280;H<288;++H)Yt[H]=8;var bn=new rt(32);for(var H=0;H<32;++H)bn[H]=5;var Go=Wt(Yt,9,1),Ho=Wt(bn,5,1),fe=function(m){for(var t=m[0],e=1;e<m.length;++e)m[e]>t&&(t=m[e]);return t},ct=function(m,t,e){var n=t/8|0;return(m[n]|m[n+1]<<8)>>(t&7)&e},me=function(m,t){var e=t/8|0;return(m[e]|m[e+1]<<8|m[e+2]<<16)>>(t&7)},Uo=function(m){return(m+7)/8|0},Xo=function(m,t,e){return(e==null||e>m.length)&&(e=m.length),new rt(m.subarray(t,e))},Yo=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],lt=function(m,t,e){var n=new Error(t||Yo[m]);if(n.code=m,Error.captureStackTrace&&Error.captureStackTrace(n,lt),!e)throw n;return n},$o=function(m,t,e,n){var s=m.length,i=0;if(!s||t.f&&!t.l)return e||new rt(0);var o=!e,r=o||t.i!=2,a=t.i;o&&(e=new rt(s*3));var c=function(Ae){var Pe=e.length;if(Ae>Pe){var Fe=new rt(Math.max(Pe*2,Ae));Fe.set(e),e=Fe}},h=t.f||0,u=t.p||0,l=t.b||0,p=t.l,f=t.d,y=t.m,v=t.n,g=s*8;do{if(!p){h=ct(m,u,1);var w=ct(m,u+1,3);if(u+=3,w)if(w==1)p=Go,f=Ho,y=9,v=5;else if(w==2){var S=ct(m,u,31)+257,M=ct(m,u+10,15)+4,I=S+ct(m,u+5,31)+1;u+=14;for(var L=new rt(I),R=new rt(19),F=0;F<M;++F)R[qo[F]]=ct(m,u+F*3,7);u+=M*3;for(var _=fe(R),T=(1<<_)-1,P=Wt(R,_,1),F=0;F<I;){var A=P[ct(m,u,T)];u+=A&15;var x=A>>4;if(x<16)L[F++]=x;else{var C=0,W=0;for(x==16?(W=3+ct(m,u,3),u+=2,C=L[F-1]):x==17?(W=3+ct(m,u,7),u+=3):x==18&&(W=11+ct(m,u,127),u+=7);W--;)L[F++]=C}}var O=L.subarray(0,S),N=L.subarray(S);y=fe(O),v=fe(N),p=Wt(O,y,1),f=Wt(N,v,1)}else lt(1);else{var x=Uo(u)+4,b=m[x-4]|m[x-3]<<8,E=x+b;if(E>s){a&&lt(0);break}r&&c(l+b),e.set(m.subarray(x,E),l),t.b=l+=b,t.p=u=E*8,t.f=h;continue}if(u>g){a&&lt(0);break}}r&&c(l+131072);for(var Q=(1<<y)-1,Z=(1<<v)-1,k=u;;k=u){var C=p[me(m,u)&Q],st=C>>4;if(u+=C&15,u>g){a&&lt(0);break}if(C||lt(2),st<256)e[l++]=st;else if(st==256){k=u,p=null;break}else{var Tt=st-254;if(st>264){var F=st-257,ft=vn[F];Tt=ct(m,u,(1<<ft)-1)+xn[F],u+=ft}var Mt=f[me(m,u)&Z],zt=Mt>>4;Mt||lt(3),u+=Mt&15;var N=jo[zt];if(zt>3){var ft=yn[zt];N+=me(m,u)&(1<<ft)-1,u+=ft}if(u>g){a&&lt(0);break}r&&c(l+131072);var Te=l+Tt;if(l<N){var Me=i-N,Mn=Math.min(N,Te);for(Me+l<0&&lt(3);l<Mn;++l)e[l]=n[Me+l]}for(;l<Te;++l)e[l]=e[l-N]}}t.l=p,t.p=k,t.b=l,t.f=h,p&&(h=1,t.m=y,t.d=f,t.n=v)}while(!h);return l!=e.length&&o?Xo(e,0,l):e.subarray(0,l)},Ko=new rt(0),Zo=function(m,t){return((m[0]&15)!=8||m[0]>>4>7||(m[0]<<8|m[1])%31)&&lt(6,"invalid zlib data"),(m[1]>>5&1)==1&&lt(6,"invalid zlib data: "+(m[1]&32?"need":"unexpected")+" dictionary"),(m[1]>>3&4)+2};function Qo(m,t){return $o(m.subarray(Zo(m),-4),{i:2},t,t)}var Jo=typeof TextDecoder<"u"&&new TextDecoder,tr=0;try{Jo.decode(Ko,{stream:!0}),tr=1}catch{}function En(m,t,e){const n=e.length-m-1;if(t>=e[n])return n-1;if(t<=e[m])return m;let s=m,i=n,o=Math.floor((s+i)/2);for(;t<e[o]||t>=e[o+1];)t<e[o]?i=o:s=o,o=Math.floor((s+i)/2);return o}function er(m,t,e,n){const s=[],i=[],o=[];s[0]=1;for(let r=1;r<=e;++r){i[r]=t-n[m+1-r],o[r]=n[m+r]-t;let a=0;for(let c=0;c<r;++c){const h=o[c+1],u=i[r-c],l=s[c]/(h+u);s[c]=a+h*l,a=u*l}s[r]=a}return s}function nr(m,t,e,n){const s=En(m,n,t),i=er(s,n,m,t),o=new jt(0,0,0,0);for(let r=0;r<=m;++r){const a=e[s-m+r],c=i[r],h=a.w*c;o.x+=a.x*h,o.y+=a.y*h,o.z+=a.z*h,o.w+=a.w*c}return o}function sr(m,t,e,n,s){const i=[];for(let u=0;u<=e;++u)i[u]=0;const o=[];for(let u=0;u<=n;++u)o[u]=i.slice(0);const r=[];for(let u=0;u<=e;++u)r[u]=i.slice(0);r[0][0]=1;const a=i.slice(0),c=i.slice(0);for(let u=1;u<=e;++u){a[u]=t-s[m+1-u],c[u]=s[m+u]-t;let l=0;for(let p=0;p<u;++p){const f=c[p+1],y=a[u-p];r[u][p]=f+y;const v=r[p][u-1]/r[u][p];r[p][u]=l+f*v,l=y*v}r[u][u]=l}for(let u=0;u<=e;++u)o[0][u]=r[u][e];for(let u=0;u<=e;++u){let l=0,p=1;const f=[];for(let y=0;y<=e;++y)f[y]=i.slice(0);f[0][0]=1;for(let y=1;y<=n;++y){let v=0;const g=u-y,w=e-y;u>=y&&(f[p][0]=f[l][0]/r[w+1][g],v=f[p][0]*r[g][w]);const x=g>=-1?1:-g,b=u-1<=w?y-1:e-u;for(let S=x;S<=b;++S)f[p][S]=(f[l][S]-f[l][S-1])/r[w+1][g+S],v+=f[p][S]*r[g+S][w];u<=w&&(f[p][y]=-f[l][y-1]/r[w+1][u],v+=f[p][y]*r[u][w]),o[y][u]=v;const E=l;l=p,p=E}}let h=e;for(let u=1;u<=n;++u){for(let l=0;l<=e;++l)o[u][l]*=h;h*=e-u}return o}function ir(m,t,e,n,s){const i=s<m?s:m,o=[],r=En(m,n,t),a=sr(r,n,m,i,t),c=[];for(let h=0;h<e.length;++h){const u=e[h].clone(),l=u.w;u.x*=l,u.y*=l,u.z*=l,c[h]=u}for(let h=0;h<=i;++h){const u=c[r-m].clone().multiplyScalar(a[h][0]);for(let l=1;l<=m;++l)u.add(c[r-m+l].clone().multiplyScalar(a[h][l]));o[h]=u}for(let h=i+1;h<=s+1;++h)o[h]=new jt(0,0,0);return o}function or(m,t){let e=1;for(let s=2;s<=m;++s)e*=s;let n=1;for(let s=2;s<=t;++s)n*=s;for(let s=2;s<=m-t;++s)n*=s;return e/n}function rr(m){const t=m.length,e=[],n=[];for(let i=0;i<t;++i){const o=m[i];e[i]=new nt(o.x,o.y,o.z),n[i]=o.w}const s=[];for(let i=0;i<t;++i){const o=e[i].clone();for(let r=1;r<=i;++r)o.sub(s[i-r].clone().multiplyScalar(or(i,r)*n[r]));s[i]=o.divideScalar(n[0])}return s}function ar(m,t,e,n,s){const i=ir(m,t,e,n,s);return rr(i)}class cr extends Rn{constructor(t,e,n,s,i){super();const o=e?e.length-1:0,r=n?n.length:0;this.degree=t,this.knots=e,this.controlPoints=[],this.startKnot=s||0,this.endKnot=i||o;for(let a=0;a<r;++a){const c=n[a];this.controlPoints[a]=new jt(c.x,c.y,c.z,c.w)}}getPoint(t,e=new nt){const n=e,s=this.knots[this.startKnot]+t*(this.knots[this.endKnot]-this.knots[this.startKnot]),i=nr(this.degree,this.knots,this.controlPoints,s);return i.w!==1&&i.divideScalar(i.w),n.set(i.x,i.y,i.z)}getTangent(t,e=new nt){const n=e,s=this.knots[0]+t*(this.knots[this.knots.length-1]-this.knots[0]),i=ar(this.degree,this.knots,this.controlPoints,s,1);return n.copy(i[1]).normalize(),n}toJSON(){const t=super.toJSON();return t.degree=this.degree,t.knots=[...this.knots],t.controlPoints=this.controlPoints.map(e=>e.toArray()),t.startKnot=this.startKnot,t.endKnot=this.endKnot,t}fromJSON(t){return super.fromJSON(t),this.degree=t.degree,this.knots=[...t.knots],this.controlPoints=t.controlPoints.map(e=>new jt(e[0],e[1],e[2],e[3])),this.startKnot=t.startKnot,this.endKnot=t.endKnot,this}}let D,X,J;class lr extends we{constructor(t){super(t)}load(t,e,n,s){const i=this,o=i.path===""?Ln.extractUrlBase(t):i.path,r=new kn(this.manager);r.setPath(i.path),r.setResponseType("arraybuffer"),r.setRequestHeader(i.requestHeader),r.setWithCredentials(i.withCredentials),r.load(t,function(a){try{e(i.parse(a,o))}catch(c){s?s(c):console.error(c),i.manager.itemError(t)}},n,s)}parse(t,e){if(mr(t))D=new fr().parse(t);else{const s=Tn(t);if(!vr(s))throw new Error("THREE.FBXLoader: Unknown format.");if(nn(s)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+nn(s));D=new pr().parse(s)}const n=new Nn(this.manager).setPath(this.resourcePath||e).setCrossOrigin(this.crossOrigin);return new hr(n,this.manager).parse(D)}}class hr{constructor(t,e){this.textureLoader=t,this.manager=e}parse(){X=this.parseConnections();const t=this.parseImages(),e=this.parseTextures(t),n=this.parseMaterials(e),s=this.parseDeformers(),i=new ur().parse(s);return this.parseScene(s,i,n),J}parseConnections(){const t=new Map;return"Connections"in D&&D.Connections.connections.forEach(function(n){const s=n[0],i=n[1],o=n[2];t.has(s)||t.set(s,{parents:[],children:[]});const r={ID:i,relationship:o};t.get(s).parents.push(r),t.has(i)||t.set(i,{parents:[],children:[]});const a={ID:s,relationship:o};t.get(i).children.push(a)}),t}parseImages(){const t={},e={};if("Video"in D.Objects){const n=D.Objects.Video;for(const s in n){const i=n[s],o=parseInt(s);if(t[o]=i.RelativeFilename||i.Filename,"Content"in i){const r=i.Content instanceof ArrayBuffer&&i.Content.byteLength>0,a=typeof i.Content=="string"&&i.Content!=="";if(r||a){const c=this.parseImage(n[s]);e[i.RelativeFilename||i.Filename]=c}}}}for(const n in t){const s=t[n];e[s]!==void 0?t[n]=e[s]:t[n]=t[n].split("\\").pop()}return t}parseImage(t){const e=t.Content,n=t.RelativeFilename||t.Filename,s=n.slice(n.lastIndexOf(".")+1).toLowerCase();let i;switch(s){case"bmp":i="image/bmp";break;case"jpg":case"jpeg":i="image/jpeg";break;case"png":i="image/png";break;case"tif":i="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",n),i="image/tga";break;default:console.warn('FBXLoader: Image type "'+s+'" is not supported.');return}if(typeof e=="string")return"data:"+i+";base64,"+e;{const o=new Uint8Array(e);return window.URL.createObjectURL(new Blob([o],{type:i}))}}parseTextures(t){const e=new Map;if("Texture"in D.Objects){const n=D.Objects.Texture;for(const s in n){const i=this.parseTexture(n[s],t);e.set(parseInt(s),i)}}return e}parseTexture(t,e){const n=this.loadTexture(t,e);n.ID=t.id,n.name=t.attrName;const s=t.WrapModeU,i=t.WrapModeV,o=s!==void 0?s.value:0,r=i!==void 0?i.value:0;if(n.wrapS=o===0?Ie:ze,n.wrapT=r===0?Ie:ze,"Scaling"in t){const a=t.Scaling.value;n.repeat.x=a[0],n.repeat.y=a[1]}if("Translation"in t){const a=t.Translation.value;n.offset.x=a[0],n.offset.y=a[1]}return n}loadTexture(t,e){const n=new Set(["tga","tif","tiff","exr","dds","hdr","ktx2"]),s=t.FileName.split(".").pop().toLowerCase(),i=n.has(s)?this.manager.getHandler(`.${s}`):this.textureLoader;if(!i)return console.warn(`FBXLoader: ${s.toUpperCase()} loader not found, creating placeholder texture for`,t.RelativeFilename),new _n;const o=i.path;o||i.setPath(this.textureLoader.path);const r=X.get(t.id).children;let a;r!==void 0&&r.length>0&&e[r[0].ID]!==void 0&&(a=e[r[0].ID],(a.indexOf("blob:")===0||a.indexOf("data:")===0)&&i.setPath(void 0));const c=i.load(a);return i.setPath(o),c}parseMaterials(t){const e=new Map;if("Material"in D.Objects){const n=D.Objects.Material;for(const s in n){const i=this.parseMaterial(n[s],t);i!==null&&e.set(parseInt(s),i)}}return e}parseMaterial(t,e){const n=t.id,s=t.attrName;let i=t.ShadingModel;if(typeof i=="object"&&(i=i.value),!X.has(n))return null;const o=this.parseParameters(t,e,n);let r;switch(i.toLowerCase()){case"phong":r=new $t;break;case"lambert":r=new On;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',i),r=new $t;break}return r.setValues(o),r.name=s,r}parseParameters(t,e,n){const s={};t.BumpFactor&&(s.bumpScale=t.BumpFactor.value),t.Diffuse?s.color=Ct.toWorkingColorSpace(new bt().fromArray(t.Diffuse.value),it):t.DiffuseColor&&(t.DiffuseColor.type==="Color"||t.DiffuseColor.type==="ColorRGB")&&(s.color=Ct.toWorkingColorSpace(new bt().fromArray(t.DiffuseColor.value),it)),t.DisplacementFactor&&(s.displacementScale=t.DisplacementFactor.value),t.Emissive?s.emissive=Ct.toWorkingColorSpace(new bt().fromArray(t.Emissive.value),it):t.EmissiveColor&&(t.EmissiveColor.type==="Color"||t.EmissiveColor.type==="ColorRGB")&&(s.emissive=Ct.toWorkingColorSpace(new bt().fromArray(t.EmissiveColor.value),it)),t.EmissiveFactor&&(s.emissiveIntensity=parseFloat(t.EmissiveFactor.value)),s.opacity=1-(t.TransparencyFactor?parseFloat(t.TransparencyFactor.value):0),(s.opacity===1||s.opacity===0)&&(s.opacity=t.Opacity?parseFloat(t.Opacity.value):null,s.opacity===null&&(s.opacity=1-(t.TransparentColor?parseFloat(t.TransparentColor.value[0]):0))),s.opacity<1&&(s.transparent=!0),t.ReflectionFactor&&(s.reflectivity=t.ReflectionFactor.value),t.Shininess&&(s.shininess=t.Shininess.value),t.Specular?s.specular=Ct.toWorkingColorSpace(new bt().fromArray(t.Specular.value),it):t.SpecularColor&&t.SpecularColor.type==="Color"&&(s.specular=Ct.toWorkingColorSpace(new bt().fromArray(t.SpecularColor.value),it));const i=this;return X.get(n).children.forEach(function(o){const r=o.relationship;switch(r){case"Bump":s.bumpMap=i.getTexture(e,o.ID);break;case"Maya|TEX_ao_map":s.aoMap=i.getTexture(e,o.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":s.map=i.getTexture(e,o.ID),s.map!==void 0&&(s.map.colorSpace=it);break;case"DisplacementColor":s.displacementMap=i.getTexture(e,o.ID);break;case"EmissiveColor":s.emissiveMap=i.getTexture(e,o.ID),s.emissiveMap!==void 0&&(s.emissiveMap.colorSpace=it);break;case"NormalMap":case"Maya|TEX_normal_map":s.normalMap=i.getTexture(e,o.ID);break;case"ReflectionColor":s.envMap=i.getTexture(e,o.ID),s.envMap!==void 0&&(s.envMap.mapping=Dn,s.envMap.colorSpace=it);break;case"SpecularColor":s.specularMap=i.getTexture(e,o.ID),s.specularMap!==void 0&&(s.specularMap.colorSpace=it);break;case"TransparentColor":case"TransparencyFactor":s.alphaMap=i.getTexture(e,o.ID),s.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",r);break}}),s}getTexture(t,e){return"LayeredTexture"in D.Objects&&e in D.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),e=X.get(e).children[0].ID),t.get(e)}parseDeformers(){const t={},e={};if("Deformer"in D.Objects){const n=D.Objects.Deformer;for(const s in n){const i=n[s],o=X.get(parseInt(s));if(i.attrType==="Skin"){const r=this.parseSkeleton(o,n);r.ID=s,o.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),r.geometryID=o.parents[0].ID,t[s]=r}else if(i.attrType==="BlendShape"){const r={id:s};r.rawTargets=this.parseMorphTargets(o,n),r.id=s,o.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),e[s]=r}}}return{skeletons:t,morphTargets:e}}parseSkeleton(t,e){const n=[];return t.children.forEach(function(s){const i=e[s.ID];if(i.attrType!=="Cluster")return;const o={ID:s.ID,indices:[],weights:[],transformLink:new U().fromArray(i.TransformLink.a)};"Indexes"in i&&(o.indices=i.Indexes.a,o.weights=i.Weights.a),n.push(o)}),{rawBones:n,bones:[]}}parseMorphTargets(t,e){const n=[];for(let s=0;s<t.children.length;s++){const i=t.children[s],o=e[i.ID],r={name:o.attrName,initialWeight:o.DeformPercent,id:o.id,fullWeights:o.FullWeights.a};if(o.attrType!=="BlendShapeChannel")return;r.geoID=X.get(parseInt(i.ID)).children.filter(function(a){return a.relationship===void 0})[0].ID,n.push(r)}return n}parseScene(t,e,n){J=new Be;const s=this.parseModels(t.skeletons,e,n),i=D.Objects.Model,o=this;s.forEach(function(a){const c=i[a.ID];o.setLookAtProperties(a,c),X.get(a.ID).parents.forEach(function(u){const l=s.get(u.ID);l!==void 0&&l.add(a)}),a.parent===null&&J.add(a)}),this.bindSkeleton(t.skeletons,e,s),this.addGlobalSceneSettings(),J.traverse(function(a){if(a.userData.transformData){a.parent&&(a.userData.transformData.parentMatrix=a.parent.matrix,a.userData.transformData.parentMatrixWorld=a.parent.matrixWorld);const c=Cn(a.userData.transformData);a.applyMatrix4(c),a.updateWorldMatrix()}});const r=new dr().parse();J.children.length===1&&J.children[0].isGroup&&(J.children[0].animations=r,J=J.children[0]),J.animations=r}parseModels(t,e,n){const s=new Map,i=D.Objects.Model;for(const o in i){const r=parseInt(o),a=i[o],c=X.get(r);let h=this.buildSkeleton(c,t,r,a.attrName);if(!h){switch(a.attrType){case"Camera":h=this.createCamera(c);break;case"Light":h=this.createLight(c);break;case"Mesh":h=this.createMesh(c,e,n);break;case"NurbsCurve":h=this.createCurve(c,e);break;case"LimbNode":case"Root":h=new Re;break;case"Null":default:h=new Be;break}h.name=a.attrName?se.sanitizeNodeName(a.attrName):"",h.userData.originalName=a.attrName,h.ID=r}this.getTransformData(h,a),s.set(r,h)}return s}buildSkeleton(t,e,n,s){let i=null;return t.parents.forEach(function(o){for(const r in e){const a=e[r];a.rawBones.forEach(function(c,h){if(c.ID===o.ID){const u=i;i=new Re,i.matrixWorld.copy(c.transformLink),i.name=s?se.sanitizeNodeName(s):"",i.userData.originalName=s,i.ID=n,a.bones[h]=i,u!==null&&i.add(u)}})}}),i}createCamera(t){let e,n;if(t.children.forEach(function(s){const i=D.Objects.NodeAttribute[s.ID];i!==void 0&&(n=i)}),n===void 0)e=new Kt;else{let s=0;n.CameraProjectionType!==void 0&&n.CameraProjectionType.value===1&&(s=1);let i=1;n.NearPlane!==void 0&&(i=n.NearPlane.value/1e3);let o=1e3;n.FarPlane!==void 0&&(o=n.FarPlane.value/1e3);let r=window.innerWidth,a=window.innerHeight;n.AspectWidth!==void 0&&n.AspectHeight!==void 0&&(r=n.AspectWidth.value,a=n.AspectHeight.value);const c=r/a;let h=45;n.FieldOfView!==void 0&&(h=n.FieldOfView.value);const u=n.FocalLength?n.FocalLength.value:null;switch(s){case 0:e=new qn(h,c,i,o),u!==null&&e.setFocalLength(u);break;case 1:console.warn("THREE.FBXLoader: Orthographic cameras not supported yet."),e=new Kt;break;default:console.warn("THREE.FBXLoader: Unknown camera type "+s+"."),e=new Kt;break}}return e}createLight(t){let e,n;if(t.children.forEach(function(s){const i=D.Objects.NodeAttribute[s.ID];i!==void 0&&(n=i)}),n===void 0)e=new Kt;else{let s;n.LightType===void 0?s=0:s=n.LightType.value;let i=16777215;n.Color!==void 0&&(i=Ct.toWorkingColorSpace(new bt().fromArray(n.Color.value),it));let o=n.Intensity===void 0?1:n.Intensity.value/100;n.CastLightOnObject!==void 0&&n.CastLightOnObject.value===0&&(o=0);let r=0;n.FarAttenuationEnd!==void 0&&(n.EnableFarAttenuation!==void 0&&n.EnableFarAttenuation.value===0?r=0:r=n.FarAttenuationEnd.value);const a=1;switch(s){case 0:e=new Le(i,o,r,a);break;case 1:e=new Wn(i,o);break;case 2:let c=Math.PI/3;n.InnerAngle!==void 0&&(c=tt.degToRad(n.InnerAngle.value));let h=0;n.OuterAngle!==void 0&&(h=tt.degToRad(n.OuterAngle.value),h=Math.max(h,1)),e=new Vn(i,o,r,c,h,a);break;default:console.warn("THREE.FBXLoader: Unknown light type "+n.LightType.value+", defaulting to a PointLight."),e=new Le(i,o);break}n.CastShadows!==void 0&&n.CastShadows.value===1&&(e.castShadow=!0)}return e}createMesh(t,e,n){let s,i=null,o=null;const r=[];if(t.children.forEach(function(a){e.has(a.ID)&&(i=e.get(a.ID)),n.has(a.ID)&&r.push(n.get(a.ID))}),r.length>1?o=r:r.length>0?o=r[0]:(o=new $t({name:we.DEFAULT_MATERIAL_NAME,color:13421772}),r.push(o)),"color"in i.attributes&&r.forEach(function(a){a.vertexColors=!0}),i.groups.length>0){let a=!1;for(let c=0,h=i.groups.length;c<h;c++){const u=i.groups[c];(u.materialIndex<0||u.materialIndex>=r.length)&&(u.materialIndex=r.length,a=!0)}if(a){const c=new $t;r.push(c)}}return i.FBX_Deformer?(s=new jn(i,o),s.normalizeSkinWeights()):s=new sn(i,o),s}createCurve(t,e){const n=t.children.reduce(function(i,o){return e.has(o.ID)&&(i=e.get(o.ID)),i},null),s=new Gn({name:we.DEFAULT_MATERIAL_NAME,color:3342591,linewidth:1});return new Hn(n,s)}getTransformData(t,e){const n={};"InheritType"in e&&(n.inheritType=parseInt(e.InheritType.value)),"RotationOrder"in e?n.eulerOrder=Ht(e.RotationOrder.value):n.eulerOrder=Ht(0),"Lcl_Translation"in e&&(n.translation=e.Lcl_Translation.value),"PreRotation"in e&&(n.preRotation=e.PreRotation.value),"Lcl_Rotation"in e&&(n.rotation=e.Lcl_Rotation.value),"PostRotation"in e&&(n.postRotation=e.PostRotation.value),"Lcl_Scaling"in e&&(n.scale=e.Lcl_Scaling.value),"ScalingOffset"in e&&(n.scalingOffset=e.ScalingOffset.value),"ScalingPivot"in e&&(n.scalingPivot=e.ScalingPivot.value),"RotationOffset"in e&&(n.rotationOffset=e.RotationOffset.value),"RotationPivot"in e&&(n.rotationPivot=e.RotationPivot.value),t.userData.transformData=n}setLookAtProperties(t,e){"LookAtProperty"in e&&X.get(t.ID).children.forEach(function(s){if(s.relationship==="LookAtProperty"){const i=D.Objects.Model[s.ID];if("Lcl_Translation"in i){const o=i.Lcl_Translation.value;t.target!==void 0?(t.target.position.fromArray(o),J.add(t.target)):t.lookAt(new nt().fromArray(o))}}})}bindSkeleton(t,e,n){const s=this.parsePoseNodes();for(const i in t){const o=t[i];X.get(parseInt(o.ID)).parents.forEach(function(a){if(e.has(a.ID)){const c=a.ID;X.get(c).parents.forEach(function(u){n.has(u.ID)&&n.get(u.ID).bind(new Un(o.bones),s[u.ID])})}})}}parsePoseNodes(){const t={};if("Pose"in D.Objects){const e=D.Objects.Pose;for(const n in e)if(e[n].attrType==="BindPose"&&e[n].NbPoseNodes>0){const s=e[n].PoseNode;Array.isArray(s)?s.forEach(function(i){t[i.Node]=new U().fromArray(i.Matrix.a)}):t[s.Node]=new U().fromArray(s.Matrix.a)}}return t}addGlobalSceneSettings(){if("GlobalSettings"in D){if("AmbientColor"in D.GlobalSettings){const t=D.GlobalSettings.AmbientColor.value,e=t[0],n=t[1],s=t[2];if(e!==0||n!==0||s!==0){const i=new bt().setRGB(e,n,s,it);J.add(new Xn(i,1))}}"UnitScaleFactor"in D.GlobalSettings&&(J.userData.unitScaleFactor=D.GlobalSettings.UnitScaleFactor.value)}}}class ur{constructor(){this.negativeMaterialIndices=!1}parse(t){const e=new Map;if("Geometry"in D.Objects){const n=D.Objects.Geometry;for(const s in n){const i=X.get(parseInt(s)),o=this.parseGeometry(i,n[s],t);e.set(parseInt(s),o)}}return this.negativeMaterialIndices===!0&&console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),e}parseGeometry(t,e,n){switch(e.attrType){case"Mesh":return this.parseMeshGeometry(t,e,n);case"NurbsCurve":return this.parseNurbsGeometry(e)}}parseMeshGeometry(t,e,n){const s=n.skeletons,i=[],o=t.parents.map(function(u){return D.Objects.Model[u.ID]});if(o.length===0)return;const r=t.children.reduce(function(u,l){return s[l.ID]!==void 0&&(u=s[l.ID]),u},null);t.children.forEach(function(u){n.morphTargets[u.ID]!==void 0&&i.push(n.morphTargets[u.ID])});const a=o[0],c={};"RotationOrder"in a&&(c.eulerOrder=Ht(a.RotationOrder.value)),"InheritType"in a&&(c.inheritType=parseInt(a.InheritType.value)),"GeometricTranslation"in a&&(c.translation=a.GeometricTranslation.value),"GeometricRotation"in a&&(c.rotation=a.GeometricRotation.value),"GeometricScaling"in a&&(c.scale=a.GeometricScaling.value);const h=Cn(c);return this.genGeometry(e,r,i,h)}genGeometry(t,e,n,s){const i=new ae;t.attrName&&(i.name=t.attrName);const o=this.parseGeoNode(t,e),r=this.genBuffers(o),a=new Bt(r.vertex,3);if(a.applyMatrix4(s),i.setAttribute("position",a),r.colors.length>0&&i.setAttribute("color",new Bt(r.colors,3)),e&&(i.setAttribute("skinIndex",new Yn(r.weightsIndices,4)),i.setAttribute("skinWeight",new Bt(r.vertexWeights,4)),i.FBX_Deformer=e),r.normal.length>0){const c=new $n().getNormalMatrix(s),h=new Bt(r.normal,3);h.applyNormalMatrix(c),i.setAttribute("normal",h)}if(r.uvs.forEach(function(c,h){const u=h===0?"uv":`uv${h}`;i.setAttribute(u,new Bt(r.uvs[h],2))}),o.material&&o.material.mappingType!=="AllSame"){let c=r.materialIndex[0],h=0;if(r.materialIndex.forEach(function(u,l){u!==c&&(i.addGroup(h,l-h,c),c=u,h=l)}),i.groups.length>0){const u=i.groups[i.groups.length-1],l=u.start+u.count;l!==r.materialIndex.length&&i.addGroup(l,r.materialIndex.length-l,c)}i.groups.length===0&&i.addGroup(0,r.materialIndex.length,r.materialIndex[0])}return this.addMorphTargets(i,t,n,s),i}parseGeoNode(t,e){const n={};if(n.vertexPositions=t.Vertices!==void 0?t.Vertices.a:[],n.vertexIndices=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],t.LayerElementColor&&(n.color=this.parseVertexColors(t.LayerElementColor[0])),t.LayerElementMaterial&&(n.material=this.parseMaterialIndices(t.LayerElementMaterial[0])),t.LayerElementNormal&&(n.normal=this.parseNormals(t.LayerElementNormal[0])),t.LayerElementUV){n.uv=[];let s=0;for(;t.LayerElementUV[s];)t.LayerElementUV[s].UV&&n.uv.push(this.parseUVs(t.LayerElementUV[s])),s++}return n.weightTable={},e!==null&&(n.skeleton=e,e.rawBones.forEach(function(s,i){s.indices.forEach(function(o,r){n.weightTable[o]===void 0&&(n.weightTable[o]=[]),n.weightTable[o].push({id:i,weight:s.weights[r]})})})),n}genBuffers(t){const e={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let n=0,s=0,i=!1,o=[],r=[],a=[],c=[],h=[],u=[];const l=this;return t.vertexIndices.forEach(function(p,f){let y,v=!1;p<0&&(p=p^-1,v=!0);let g=[],w=[];if(o.push(p*3,p*3+1,p*3+2),t.color){const x=ne(f,n,p,t.color);a.push(x[0],x[1],x[2])}if(t.skeleton){if(t.weightTable[p]!==void 0&&t.weightTable[p].forEach(function(x){w.push(x.weight),g.push(x.id)}),w.length>4){i||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),i=!0);const x=[0,0,0,0],b=[0,0,0,0];w.forEach(function(E,S){let M=E,I=g[S];b.forEach(function(L,R,F){if(M>L){F[R]=M,M=L;const _=x[R];x[R]=I,I=_}})}),g=x,w=b}for(;w.length<4;)w.push(0),g.push(0);for(let x=0;x<4;++x)h.push(w[x]),u.push(g[x])}if(t.normal){const x=ne(f,n,p,t.normal);r.push(x[0],x[1],x[2])}t.material&&t.material.mappingType!=="AllSame"&&(y=ne(f,n,p,t.material)[0],y<0&&(l.negativeMaterialIndices=!0,y=0)),t.uv&&t.uv.forEach(function(x,b){const E=ne(f,n,p,x);c[b]===void 0&&(c[b]=[]),c[b].push(E[0]),c[b].push(E[1])}),s++,v&&(l.genFace(e,t,o,y,r,a,c,h,u,s),n++,s=0,o=[],r=[],a=[],c=[],h=[],u=[])}),e}getNormalNewell(t){const e=new nt(0,0,0);for(let n=0;n<t.length;n++){const s=t[n],i=t[(n+1)%t.length];e.x+=(s.y-i.y)*(s.z+i.z),e.y+=(s.z-i.z)*(s.x+i.x),e.z+=(s.x-i.x)*(s.y+i.y)}return e.normalize(),e}getNormalTangentAndBitangent(t){const e=this.getNormalNewell(t),s=(Math.abs(e.z)>.5?new nt(0,1,0):new nt(0,0,1)).cross(e).normalize(),i=e.clone().cross(s).normalize();return{normal:e,tangent:s,bitangent:i}}flattenVertex(t,e,n){return new Kn(t.dot(e),t.dot(n))}genFace(t,e,n,s,i,o,r,a,c,h){let u;if(h>3){const l=[],p=e.baseVertexPositions||e.vertexPositions;for(let g=0;g<n.length;g+=3)l.push(new nt(p[n[g]],p[n[g+1]],p[n[g+2]]));const{tangent:f,bitangent:y}=this.getNormalTangentAndBitangent(l),v=[];for(const g of l)v.push(this.flattenVertex(g,f,y));u=Zn.triangulateShape(v,[])}else u=[[0,1,2]];for(const[l,p,f]of u)t.vertex.push(e.vertexPositions[n[l*3]]),t.vertex.push(e.vertexPositions[n[l*3+1]]),t.vertex.push(e.vertexPositions[n[l*3+2]]),t.vertex.push(e.vertexPositions[n[p*3]]),t.vertex.push(e.vertexPositions[n[p*3+1]]),t.vertex.push(e.vertexPositions[n[p*3+2]]),t.vertex.push(e.vertexPositions[n[f*3]]),t.vertex.push(e.vertexPositions[n[f*3+1]]),t.vertex.push(e.vertexPositions[n[f*3+2]]),e.skeleton&&(t.vertexWeights.push(a[l*4]),t.vertexWeights.push(a[l*4+1]),t.vertexWeights.push(a[l*4+2]),t.vertexWeights.push(a[l*4+3]),t.vertexWeights.push(a[p*4]),t.vertexWeights.push(a[p*4+1]),t.vertexWeights.push(a[p*4+2]),t.vertexWeights.push(a[p*4+3]),t.vertexWeights.push(a[f*4]),t.vertexWeights.push(a[f*4+1]),t.vertexWeights.push(a[f*4+2]),t.vertexWeights.push(a[f*4+3]),t.weightsIndices.push(c[l*4]),t.weightsIndices.push(c[l*4+1]),t.weightsIndices.push(c[l*4+2]),t.weightsIndices.push(c[l*4+3]),t.weightsIndices.push(c[p*4]),t.weightsIndices.push(c[p*4+1]),t.weightsIndices.push(c[p*4+2]),t.weightsIndices.push(c[p*4+3]),t.weightsIndices.push(c[f*4]),t.weightsIndices.push(c[f*4+1]),t.weightsIndices.push(c[f*4+2]),t.weightsIndices.push(c[f*4+3])),e.color&&(t.colors.push(o[l*3]),t.colors.push(o[l*3+1]),t.colors.push(o[l*3+2]),t.colors.push(o[p*3]),t.colors.push(o[p*3+1]),t.colors.push(o[p*3+2]),t.colors.push(o[f*3]),t.colors.push(o[f*3+1]),t.colors.push(o[f*3+2])),e.material&&e.material.mappingType!=="AllSame"&&(t.materialIndex.push(s),t.materialIndex.push(s),t.materialIndex.push(s)),e.normal&&(t.normal.push(i[l*3]),t.normal.push(i[l*3+1]),t.normal.push(i[l*3+2]),t.normal.push(i[p*3]),t.normal.push(i[p*3+1]),t.normal.push(i[p*3+2]),t.normal.push(i[f*3]),t.normal.push(i[f*3+1]),t.normal.push(i[f*3+2])),e.uv&&e.uv.forEach(function(y,v){t.uvs[v]===void 0&&(t.uvs[v]=[]),t.uvs[v].push(r[v][l*2]),t.uvs[v].push(r[v][l*2+1]),t.uvs[v].push(r[v][p*2]),t.uvs[v].push(r[v][p*2+1]),t.uvs[v].push(r[v][f*2]),t.uvs[v].push(r[v][f*2+1])})}addMorphTargets(t,e,n,s){if(n.length===0)return;t.morphTargetsRelative=!0,t.morphAttributes.position=[];const i=this;n.forEach(function(o){o.rawTargets.forEach(function(r){const a=D.Objects.Geometry[r.geoID];a!==void 0&&i.genMorphGeometry(t,e,a,s,r.name)})})}genMorphGeometry(t,e,n,s,i){const o=e.Vertices!==void 0?e.Vertices.a:[],r=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],a=n.Vertices!==void 0?n.Vertices.a:[],c=n.Indexes!==void 0?n.Indexes.a:[],h=t.attributes.position.count*3,u=new Float32Array(h);for(let y=0;y<c.length;y++){const v=c[y]*3;u[v]=a[y*3],u[v+1]=a[y*3+1],u[v+2]=a[y*3+2]}const l={vertexIndices:r,vertexPositions:u,baseVertexPositions:o},p=this.genBuffers(l),f=new Bt(p.vertex,3);f.name=i||n.attrName,f.applyMatrix4(s),t.morphAttributes.position.push(f)}parseNormals(t){const e=t.MappingInformationType,n=t.ReferenceInformationType,s=t.Normals.a;let i=[];return n==="IndexToDirect"&&("NormalIndex"in t?i=t.NormalIndex.a:"NormalsIndex"in t&&(i=t.NormalsIndex.a)),{dataSize:3,buffer:s,indices:i,mappingType:e,referenceType:n}}parseUVs(t){const e=t.MappingInformationType,n=t.ReferenceInformationType,s=t.UV.a;let i=[];return n==="IndexToDirect"&&(i=t.UVIndex.a),{dataSize:2,buffer:s,indices:i,mappingType:e,referenceType:n}}parseVertexColors(t){const e=t.MappingInformationType,n=t.ReferenceInformationType,s=t.Colors.a;let i=[];n==="IndexToDirect"&&(i=t.ColorIndex.a);for(let o=0,r=new bt;o<s.length;o+=4)r.fromArray(s,o),Ct.toWorkingColorSpace(r,it),r.toArray(s,o);return{dataSize:4,buffer:s,indices:i,mappingType:e,referenceType:n}}parseMaterialIndices(t){const e=t.MappingInformationType,n=t.ReferenceInformationType;if(e==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:n};const s=t.Materials.a,i=[];for(let o=0;o<s.length;++o)i.push(o);return{dataSize:1,buffer:s,indices:i,mappingType:e,referenceType:n}}parseNurbsGeometry(t){const e=parseInt(t.Order);if(isNaN(e))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",t.Order,t.id),new ae;const n=e-1,s=t.KnotVector.a,i=[],o=t.Points.a;for(let u=0,l=o.length;u<l;u+=4)i.push(new jt().fromArray(o,u));let r,a;if(t.Form==="Closed")i.push(i[0]);else if(t.Form==="Periodic"){r=n,a=s.length-1-r;for(let u=0;u<n;++u)i.push(i[u])}const h=new cr(n,s,i,r,a).getPoints(i.length*12);return new ae().setFromPoints(h)}}class dr{parse(){const t=[],e=this.parseClips();if(e!==void 0)for(const n in e){const s=e[n],i=this.addClip(s);t.push(i)}return t}parseClips(){if(D.Objects.AnimationCurve===void 0)return;const t=this.parseAnimationCurveNodes();this.parseAnimationCurves(t);const e=this.parseAnimationLayers(t);return this.parseAnimStacks(e)}parseAnimationCurveNodes(){const t=D.Objects.AnimationCurveNode,e=new Map;for(const n in t){const s=t[n];if(s.attrName.match(/S|R|T|DeformPercent/)!==null){const i={id:s.id,attr:s.attrName,curves:{}};e.set(i.id,i)}}return e}parseAnimationCurves(t){const e=D.Objects.AnimationCurve;for(const n in e){const s={id:e[n].id,times:e[n].KeyTime.a.map(yr),values:e[n].KeyValueFloat.a},i=X.get(s.id);if(i!==void 0){const o=i.parents[0].ID,r=i.parents[0].relationship;r.match(/X/)?t.get(o).curves.x=s:r.match(/Y/)?t.get(o).curves.y=s:r.match(/Z/)?t.get(o).curves.z=s:r.match(/DeformPercent/)&&t.has(o)&&(t.get(o).curves.morph=s)}}}parseAnimationLayers(t){const e=D.Objects.AnimationLayer,n=new Map;for(const s in e){const i=[],o=X.get(parseInt(s));o!==void 0&&(o.children.forEach(function(a,c){if(t.has(a.ID)){const h=t.get(a.ID);if(h.curves.x!==void 0||h.curves.y!==void 0||h.curves.z!==void 0){if(i[c]===void 0){const u=X.get(a.ID).parents.filter(function(l){return l.relationship!==void 0})[0].ID;if(u!==void 0){const l=D.Objects.Model[u.toString()];if(l===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",a);return}const p={modelName:l.attrName?se.sanitizeNodeName(l.attrName):"",ID:l.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};J.traverse(function(f){f.ID===l.id&&(p.transform=f.matrix,f.userData.transformData&&(p.eulerOrder=f.userData.transformData.eulerOrder))}),p.transform||(p.transform=new U),"PreRotation"in l&&(p.preRotation=l.PreRotation.value),"PostRotation"in l&&(p.postRotation=l.PostRotation.value),i[c]=p}}i[c]&&(i[c][h.attr]=h)}else if(h.curves.morph!==void 0){if(i[c]===void 0){const u=X.get(a.ID).parents.filter(function(g){return g.relationship!==void 0})[0].ID,l=X.get(u).parents[0].ID,p=X.get(l).parents[0].ID,f=X.get(p).parents[0].ID,y=D.Objects.Model[f],v={modelName:y.attrName?se.sanitizeNodeName(y.attrName):"",morphName:D.Objects.Deformer[u].attrName};i[c]=v}i[c][h.attr]=h}}}),n.set(parseInt(s),i))}return n}parseAnimStacks(t){const e=D.Objects.AnimationStack,n={};for(const s in e){const i=X.get(parseInt(s)).children;i.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const o=t.get(i[0].ID);n[s]={name:e[s].attrName,layer:o}}return n}addClip(t){let e=[];const n=this;return t.layer.forEach(function(s){e=e.concat(n.generateTracks(s))}),new Qn(t.name,-1,e)}generateTracks(t){const e=[];let n=new nt,s=new nt;if(t.transform&&t.transform.decompose(n,new xt,s),n=n.toArray(),s=s.toArray(),t.T!==void 0&&Object.keys(t.T.curves).length>0){const i=this.generateVectorTrack(t.modelName,t.T.curves,n,"position");i!==void 0&&e.push(i)}if(t.R!==void 0&&Object.keys(t.R.curves).length>0){const i=this.generateRotationTrack(t.modelName,t.R.curves,t.preRotation,t.postRotation,t.eulerOrder);i!==void 0&&e.push(i)}if(t.S!==void 0&&Object.keys(t.S.curves).length>0){const i=this.generateVectorTrack(t.modelName,t.S.curves,s,"scale");i!==void 0&&e.push(i)}if(t.DeformPercent!==void 0){const i=this.generateMorphTrack(t);i!==void 0&&e.push(i)}return e}generateVectorTrack(t,e,n,s){const i=this.getTimesForAllAxes(e),o=this.getKeyframeTrackValues(i,e,n);return new Jn(t+"."+s,i,o)}generateRotationTrack(t,e,n,s,i){let o,r;if(e.x!==void 0&&e.y!==void 0&&e.z!==void 0){const l=this.interpolateRotations(e.x,e.y,e.z,i);o=l[0],r=l[1]}const a=Ht(0);n!==void 0&&(n=n.map(tt.degToRad),n.push(a),n=new Pt().fromArray(n),n=new xt().setFromEuler(n)),s!==void 0&&(s=s.map(tt.degToRad),s.push(a),s=new Pt().fromArray(s),s=new xt().setFromEuler(s).invert());const c=new xt,h=new Pt,u=[];if(!r||!o)return new ke(t+".quaternion",[0],[0]);for(let l=0;l<r.length;l+=3)h.set(r[l],r[l+1],r[l+2],i),c.setFromEuler(h),n!==void 0&&c.premultiply(n),s!==void 0&&c.multiply(s),l>2&&new xt().fromArray(u,(l-3)/3*4).dot(c)<0&&c.set(-c.x,-c.y,-c.z,-c.w),c.toArray(u,l/3*4);return new ke(t+".quaternion",o,u)}generateMorphTrack(t){const e=t.DeformPercent.curves.morph,n=e.values.map(function(i){return i/100}),s=J.getObjectByName(t.modelName).morphTargetDictionary[t.morphName];return new ts(t.modelName+".morphTargetInfluences["+s+"]",e.times,n)}getTimesForAllAxes(t){let e=[];if(t.x!==void 0&&(e=e.concat(t.x.times)),t.y!==void 0&&(e=e.concat(t.y.times)),t.z!==void 0&&(e=e.concat(t.z.times)),e=e.sort(function(n,s){return n-s}),e.length>1){let n=1,s=e[0];for(let i=1;i<e.length;i++){const o=e[i];o!==s&&(e[n]=o,s=o,n++)}e=e.slice(0,n)}return e}getKeyframeTrackValues(t,e,n){const s=n,i=[];let o=-1,r=-1,a=-1;return t.forEach(function(c){if(e.x&&(o=e.x.times.indexOf(c)),e.y&&(r=e.y.times.indexOf(c)),e.z&&(a=e.z.times.indexOf(c)),o!==-1){const h=e.x.values[o];i.push(h),s[0]=h}else i.push(s[0]);if(r!==-1){const h=e.y.values[r];i.push(h),s[1]=h}else i.push(s[1]);if(a!==-1){const h=e.z.values[a];i.push(h),s[2]=h}else i.push(s[2])}),i}interpolateRotations(t,e,n,s){const i=[],o=[];i.push(t.times[0]),o.push(tt.degToRad(t.values[0])),o.push(tt.degToRad(e.values[0])),o.push(tt.degToRad(n.values[0]));for(let r=1;r<t.values.length;r++){const a=[t.values[r-1],e.values[r-1],n.values[r-1]];if(isNaN(a[0])||isNaN(a[1])||isNaN(a[2]))continue;const c=a.map(tt.degToRad),h=[t.values[r],e.values[r],n.values[r]];if(isNaN(h[0])||isNaN(h[1])||isNaN(h[2]))continue;const u=h.map(tt.degToRad),l=[h[0]-a[0],h[1]-a[1],h[2]-a[2]],p=[Math.abs(l[0]),Math.abs(l[1]),Math.abs(l[2])];if(p[0]>=180||p[1]>=180||p[2]>=180){const y=Math.max(...p)/180,v=new Pt(...c,s),g=new Pt(...u,s),w=new xt().setFromEuler(v),x=new xt().setFromEuler(g);w.dot(x)&&x.set(-x.x,-x.y,-x.z,-x.w);const b=t.times[r-1],E=t.times[r]-b,S=new xt,M=new Pt;for(let I=0;I<1;I+=1/y)S.copy(w.clone().slerp(x.clone(),I)),i.push(b+I*E),M.setFromQuaternion(S,s),o.push(M.x),o.push(M.y),o.push(M.z)}else i.push(t.times[r]),o.push(tt.degToRad(t.values[r])),o.push(tt.degToRad(e.values[r])),o.push(tt.degToRad(n.values[r]))}return[i,o]}}class pr{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(t){this.nodeStack.push(t),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(t,e){this.currentProp=t,this.currentPropName=e}parse(t){this.currentIndent=0,this.allNodes=new Sn,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const e=this,n=t.split(/[\r\n]+/);return n.forEach(function(s,i){const o=s.match(/^[\s\t]*;/),r=s.match(/^[\s\t]*$/);if(o||r)return;const a=s.match("^\\t{"+e.currentIndent+"}(\\w+):(.*){",""),c=s.match("^\\t{"+e.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),h=s.match("^\\t{"+(e.currentIndent-1)+"}}");a?e.parseNodeBegin(s,a):c?e.parseNodeProperty(s,c,n[++i]):h?e.popStack():s.match(/^[^\s\t}]/)&&e.parseNodePropertyContinued(s)}),this.allNodes}parseNodeBegin(t,e){const n=e[1].trim().replace(/^"/,"").replace(/"$/,""),s=e[2].split(",").map(function(a){return a.trim().replace(/^"/,"").replace(/"$/,"")}),i={name:n},o=this.parseNodeAttr(s),r=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(n,i):n in r?(n==="PoseNode"?r.PoseNode.push(i):r[n].id!==void 0&&(r[n]={},r[n][r[n].id]=r[n]),o.id!==""&&(r[n][o.id]=i)):typeof o.id=="number"?(r[n]={},r[n][o.id]=i):n!=="Properties70"&&(n==="PoseNode"?r[n]=[i]:r[n]=i),typeof o.id=="number"&&(i.id=o.id),o.name!==""&&(i.attrName=o.name),o.type!==""&&(i.attrType=o.type),this.pushStack(i)}parseNodeAttr(t){let e=t[0];t[0]!==""&&(e=parseInt(t[0]),isNaN(e)&&(e=t[0]));let n="",s="";return t.length>1&&(n=t[1].replace(/^(\w+)::/,""),s=t[2]),{id:e,name:n,type:s}}parseNodeProperty(t,e,n){let s=e[1].replace(/^"/,"").replace(/"$/,"").trim(),i=e[2].replace(/^"/,"").replace(/"$/,"").trim();s==="Content"&&i===","&&(i=n.replace(/"/g,"").replace(/,$/,"").trim());const o=this.getCurrentNode();if(o.name==="Properties70"){this.parseNodeSpecialProperty(t,s,i);return}if(s==="C"){const a=i.split(",").slice(1),c=parseInt(a[0]),h=parseInt(a[1]);let u=i.split(",").slice(3);u=u.map(function(l){return l.trim().replace(/^"/,"")}),s="connections",i=[c,h],gr(i,u),o[s]===void 0&&(o[s]=[])}s==="Node"&&(o.id=i),s in o&&Array.isArray(o[s])?o[s].push(i):s!=="a"?o[s]=i:o.a=i,this.setCurrentProp(o,s),s==="a"&&i.slice(-1)!==","&&(o.a=ye(i))}parseNodePropertyContinued(t){const e=this.getCurrentNode();e.a+=t,t.slice(-1)!==","&&(e.a=ye(e.a))}parseNodeSpecialProperty(t,e,n){const s=n.split('",').map(function(h){return h.trim().replace(/^\"/,"").replace(/\s/,"_")}),i=s[0],o=s[1],r=s[2],a=s[3];let c=s[4];switch(o){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":c=parseFloat(c);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":c=ye(c);break}this.getPrevNode()[i]={type:o,type2:r,flag:a,value:c},this.setCurrentProp(this.getPrevNode(),i)}}class fr{parse(t){const e=new en(t);e.skip(23);const n=e.getUint32();if(n<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+n);const s=new Sn;for(;!this.endOfContent(e);){const i=this.parseNode(e,n);i!==null&&s.add(i.name,i)}return s}endOfContent(t){return t.size()%16===0?(t.getOffset()+160+16&-16)>=t.size():t.getOffset()+160+16>=t.size()}parseNode(t,e){const n={},s=e>=7500?t.getUint64():t.getUint32(),i=e>=7500?t.getUint64():t.getUint32();e>=7500?t.getUint64():t.getUint32();const o=t.getUint8(),r=t.getString(o);if(s===0)return null;const a=[];for(let l=0;l<i;l++)a.push(this.parseProperty(t));const c=a.length>0?a[0]:"",h=a.length>1?a[1]:"",u=a.length>2?a[2]:"";for(n.singleProperty=i===1&&t.getOffset()===s;s>t.getOffset();){const l=this.parseNode(t,e);l!==null&&this.parseSubNode(r,n,l)}return n.propertyList=a,typeof c=="number"&&(n.id=c),h!==""&&(n.attrName=h),u!==""&&(n.attrType=u),r!==""&&(n.name=r),n}parseSubNode(t,e,n){if(n.singleProperty===!0){const s=n.propertyList[0];Array.isArray(s)?(e[n.name]=n,n.a=s):e[n.name]=s}else if(t==="Connections"&&n.name==="C"){const s=[];n.propertyList.forEach(function(i,o){o!==0&&s.push(i)}),e.connections===void 0&&(e.connections=[]),e.connections.push(s)}else if(n.name==="Properties70")Object.keys(n).forEach(function(i){e[i]=n[i]});else if(t==="Properties70"&&n.name==="P"){let s=n.propertyList[0],i=n.propertyList[1];const o=n.propertyList[2],r=n.propertyList[3];let a;s.indexOf("Lcl ")===0&&(s=s.replace("Lcl ","Lcl_")),i.indexOf("Lcl ")===0&&(i=i.replace("Lcl ","Lcl_")),i==="Color"||i==="ColorRGB"||i==="Vector"||i==="Vector3D"||i.indexOf("Lcl_")===0?a=[n.propertyList[4],n.propertyList[5],n.propertyList[6]]:a=n.propertyList[4],e[s]={type:i,type2:o,flag:r,value:a}}else e[n.name]===void 0?typeof n.id=="number"?(e[n.name]={},e[n.name][n.id]=n):e[n.name]=n:n.name==="PoseNode"?(Array.isArray(e[n.name])||(e[n.name]=[e[n.name]]),e[n.name].push(n)):e[n.name][n.id]===void 0&&(e[n.name][n.id]=n)}parseProperty(t){const e=t.getString(1);let n;switch(e){case"C":return t.getBoolean();case"D":return t.getFloat64();case"F":return t.getFloat32();case"I":return t.getInt32();case"L":return t.getInt64();case"R":return n=t.getUint32(),t.getArrayBuffer(n);case"S":return n=t.getUint32(),t.getString(n);case"Y":return t.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const s=t.getUint32(),i=t.getUint32(),o=t.getUint32();if(i===0)switch(e){case"b":case"c":return t.getBooleanArray(s);case"d":return t.getFloat64Array(s);case"f":return t.getFloat32Array(s);case"i":return t.getInt32Array(s);case"l":return t.getInt64Array(s)}const r=Qo(new Uint8Array(t.getArrayBuffer(o))),a=new en(r.buffer);switch(e){case"b":case"c":return a.getBooleanArray(s);case"d":return a.getFloat64Array(s);case"f":return a.getFloat32Array(s);case"i":return a.getInt32Array(s);case"l":return a.getInt64Array(s)}break;default:throw new Error("THREE.FBXLoader: Unknown property type "+e)}}}class en{constructor(t,e){this.dv=new DataView(t),this.offset=0,this.littleEndian=e!==void 0?e:!0,this._textDecoder=new TextDecoder}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(t){this.offset+=t}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(t){const e=[];for(let n=0;n<t;n++)e.push(this.getBoolean());return e}getUint8(){const t=this.dv.getUint8(this.offset);return this.offset+=1,t}getInt16(){const t=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,t}getInt32(){const t=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,t}getInt32Array(t){const e=[];for(let n=0;n<t;n++)e.push(this.getInt32());return e}getUint32(){const t=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,t}getInt64(){let t,e;return this.littleEndian?(t=this.getUint32(),e=this.getUint32()):(e=this.getUint32(),t=this.getUint32()),e&2147483648?(e=~e&4294967295,t=~t&4294967295,t===4294967295&&(e=e+1&4294967295),t=t+1&4294967295,-(e*4294967296+t)):e*4294967296+t}getInt64Array(t){const e=[];for(let n=0;n<t;n++)e.push(this.getInt64());return e}getUint64(){let t,e;return this.littleEndian?(t=this.getUint32(),e=this.getUint32()):(e=this.getUint32(),t=this.getUint32()),e*4294967296+t}getFloat32(){const t=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,t}getFloat32Array(t){const e=[];for(let n=0;n<t;n++)e.push(this.getFloat32());return e}getFloat64(){const t=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,t}getFloat64Array(t){const e=[];for(let n=0;n<t;n++)e.push(this.getFloat64());return e}getArrayBuffer(t){const e=this.dv.buffer.slice(this.offset,this.offset+t);return this.offset+=t,e}getString(t){const e=this.offset;let n=new Uint8Array(this.dv.buffer,e,t);this.skip(t);const s=n.indexOf(0);return s>=0&&(n=new Uint8Array(this.dv.buffer,e,s)),this._textDecoder.decode(n)}}class Sn{add(t,e){this[t]=e}}function mr(m){const t="Kaydara FBX Binary  \0";return m.byteLength>=t.length&&t===Tn(m,0,t.length)}function vr(m){const t=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let e=0;function n(s){const i=m[s-1];return m=m.slice(e+s),e++,i}for(let s=0;s<t.length;++s)if(n(1)===t[s])return!1;return!0}function nn(m){const t=/FBXVersion: (\d+)/,e=m.match(t);if(e)return parseInt(e[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function yr(m){return m/46186158e3}const wr=[];function ne(m,t,e,n){let s;switch(n.mappingType){case"ByPolygonVertex":s=m;break;case"ByPolygon":s=t;break;case"ByVertice":s=e;break;case"AllSame":s=n.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+n.mappingType)}n.referenceType==="IndexToDirect"&&(s=n.indices[s]);const i=s*n.dataSize,o=i+n.dataSize;return xr(wr,n.buffer,i,o)}const ve=new Pt,kt=new nt;function Cn(m){const t=new U,e=new U,n=new U,s=new U,i=new U,o=new U,r=new U,a=new U,c=new U,h=new U,u=new U,l=new U,p=m.inheritType?m.inheritType:0;m.translation&&t.setPosition(kt.fromArray(m.translation));const f=Ht(0);if(m.preRotation){const F=m.preRotation.map(tt.degToRad);F.push(f),e.makeRotationFromEuler(ve.fromArray(F))}if(m.rotation){const F=m.rotation.map(tt.degToRad);F.push(m.eulerOrder||f),n.makeRotationFromEuler(ve.fromArray(F))}if(m.postRotation){const F=m.postRotation.map(tt.degToRad);F.push(f),s.makeRotationFromEuler(ve.fromArray(F)),s.invert()}m.scale&&i.scale(kt.fromArray(m.scale)),m.scalingOffset&&r.setPosition(kt.fromArray(m.scalingOffset)),m.scalingPivot&&o.setPosition(kt.fromArray(m.scalingPivot)),m.rotationOffset&&a.setPosition(kt.fromArray(m.rotationOffset)),m.rotationPivot&&c.setPosition(kt.fromArray(m.rotationPivot)),m.parentMatrixWorld&&(u.copy(m.parentMatrix),h.copy(m.parentMatrixWorld));const y=e.clone().multiply(n).multiply(s),v=new U;v.extractRotation(h);const g=new U;g.copyPosition(h);const w=g.clone().invert().multiply(h),x=v.clone().invert().multiply(w),b=i,E=new U;if(p===0)E.copy(v).multiply(y).multiply(x).multiply(b);else if(p===1)E.copy(v).multiply(x).multiply(y).multiply(b);else{const _=new U().scale(new nt().setFromMatrixScale(u)).clone().invert(),T=x.clone().multiply(_);E.copy(v).multiply(y).multiply(T).multiply(b)}const S=c.clone().invert(),M=o.clone().invert();let I=t.clone().multiply(a).multiply(c).multiply(e).multiply(n).multiply(s).multiply(S).multiply(r).multiply(o).multiply(i).multiply(M);const L=new U().copyPosition(I),R=h.clone().multiply(L);return l.copyPosition(R),I=l.clone().multiply(E),I.premultiply(h.invert()),I}function Ht(m){m=m||0;const t=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return m===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),t[0]):t[m]}function ye(m){return m.split(",").map(function(e){return parseFloat(e)})}function Tn(m,t,e){return t===void 0&&(t=0),e===void 0&&(e=m.byteLength),new TextDecoder().decode(new Uint8Array(m,t,e))}function gr(m,t){for(let e=0,n=m.length,s=t.length;e<s;e++,n++)m[n]=t[e]}function xr(m,t,e,n){for(let s=e,i=0;s<n;s++,i++)m[i]=t[s];return m}const br=(m,t={})=>{const e=t.manager||new es,n=new lr(e);return n.setResourcePath(t.sourcePath?mn(t.sourcePath):m.split("/").slice(0,-1).join("/")+"/textures/"),new Promise((s,i)=>{const o=Date.now();n.load(m,r=>{const a=((Date.now()-o)/1e3).toFixed(1);console.log(` ${t.name||m} loaded in ${a}s`),s(r)},r=>{r.lengthComputable&&t.onProgress&&t.onProgress(r.loaded/r.total*100)},r=>{e.removeHandler(/.*/),i(new Error(`Failed to load ${m}: ${r.message}`))})})},Er=[{path:"TZ/model.fbx",name:"TZ",loader:br,sourcePath:"TZ/tex/"}];(async()=>(Gt.assets=await Oo(Er),Gt.initialize()))();
