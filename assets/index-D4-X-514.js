var xs=Object.defineProperty;var As=(f,e,t)=>e in f?xs(f,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):f[e]=t;var G=(f,e,t)=>As(f,typeof e!="symbol"?e+"":e,t);import*as V from"three";import{Mesh as Yt,ShaderMaterial as Ts,BackSide as Es,UniformsUtils as bs,BoxGeometry as Ss,Vector3 as Z,TrianglesDrawMode as Ms,TriangleFanDrawMode as Ot,TriangleStripDrawMode as Bn,Quaternion as ye,Matrix4 as W,Loader as vt,LoaderUtils as Ue,FileLoader as $t,MeshPhysicalMaterial as we,Vector2 as Zt,Color as se,LinearSRGBColorSpace as Re,SRGBColorSpace as ee,SpotLight as zn,PointLight as Dt,DirectionalLight as kn,InstancedMesh as Rs,InstancedBufferAttribute as Cs,Object3D as je,TextureLoader as On,ImageBitmapLoader as Is,BufferAttribute as Et,InterleavedBuffer as Ls,InterleavedBufferAttribute as Ps,LinearMipmapLinearFilter as Dn,NearestMipmapLinearFilter as Fs,LinearMipmapNearestFilter as _s,NearestMipmapNearestFilter as Ns,LinearFilter as Gt,NearestFilter as Gn,RepeatWrapping as nt,MirroredRepeatWrapping as Bs,ClampToEdgeWrapping as qt,PointsMaterial as zs,Material as bt,LineBasicMaterial as qn,MeshStandardMaterial as Hn,DoubleSide as ks,MeshBasicMaterial as Qe,PropertyBinding as st,BufferGeometry as yt,SkinnedMesh as jn,LineSegments as Os,Line as Vn,LineLoop as Ds,Points as Gs,Group as Je,PerspectiveCamera as Un,MathUtils as ne,OrthographicCamera as qs,Skeleton as Wn,AnimationClip as Xn,Bone as Ht,InterpolateDiscrete as Hs,InterpolateLinear as Kn,Texture as jt,VectorKeyframeTrack as Vt,NumberKeyframeTrack as Ut,QuaternionKeyframeTrack as wt,ColorManagement as ve,FrontSide as js,Interpolant as Vs,Box3 as Us,Sphere as Ws,LoadingManager as Yn,Vector4 as it,Curve as Xs,Euler as Be,MeshPhongMaterial as ht,MeshLambertMaterial as Ks,EquirectangularReflectionMapping as Ys,AmbientLight as $s,Float32BufferAttribute as De,Uint16BufferAttribute as Zs,Matrix3 as Qs,ShapeUtils as Js}from"three";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function t(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(s){if(s.ep)return;s.ep=!0;const i=t(s);fetch(s.href,i)}})();class pe{constructor(e){e===void 0&&(e=[0,0,0,0,0,0,0,0,0]),this.elements=e}identity(){const e=this.elements;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1}setZero(){const e=this.elements;e[0]=0,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e[8]=0}setTrace(e){const t=this.elements;t[0]=e.x,t[4]=e.y,t[8]=e.z}getTrace(e){e===void 0&&(e=new d);const t=this.elements;return e.x=t[0],e.y=t[4],e.z=t[8],e}vmult(e,t){t===void 0&&(t=new d);const n=this.elements,s=e.x,i=e.y,o=e.z;return t.x=n[0]*s+n[1]*i+n[2]*o,t.y=n[3]*s+n[4]*i+n[5]*o,t.z=n[6]*s+n[7]*i+n[8]*o,t}smult(e){for(let t=0;t<this.elements.length;t++)this.elements[t]*=e}mmult(e,t){t===void 0&&(t=new pe);const n=this.elements,s=e.elements,i=t.elements,o=n[0],r=n[1],a=n[2],c=n[3],h=n[4],l=n[5],u=n[6],p=n[7],m=n[8],y=s[0],g=s[1],w=s[2],v=s[3],x=s[4],A=s[5],T=s[6],E=s[7],M=s[8];return i[0]=o*y+r*v+a*T,i[1]=o*g+r*x+a*E,i[2]=o*w+r*A+a*M,i[3]=c*y+h*v+l*T,i[4]=c*g+h*x+l*E,i[5]=c*w+h*A+l*M,i[6]=u*y+p*v+m*T,i[7]=u*g+p*x+m*E,i[8]=u*w+p*A+m*M,t}scale(e,t){t===void 0&&(t=new pe);const n=this.elements,s=t.elements;for(let i=0;i!==3;i++)s[3*i+0]=e.x*n[3*i+0],s[3*i+1]=e.y*n[3*i+1],s[3*i+2]=e.z*n[3*i+2];return t}solve(e,t){t===void 0&&(t=new d);const n=3,s=4,i=[];let o,r;for(o=0;o<n*s;o++)i.push(0);for(o=0;o<3;o++)for(r=0;r<3;r++)i[o+s*r]=this.elements[o+3*r];i[3+4*0]=e.x,i[3+4*1]=e.y,i[3+4*2]=e.z;let a=3;const c=a;let h;const l=4;let u;do{if(o=c-a,i[o+s*o]===0){for(r=o+1;r<c;r++)if(i[o+s*r]!==0){h=l;do u=l-h,i[u+s*o]+=i[u+s*r];while(--h);break}}if(i[o+s*o]!==0)for(r=o+1;r<c;r++){const p=i[o+s*r]/i[o+s*o];h=l;do u=l-h,i[u+s*r]=u<=o?0:i[u+s*r]-i[u+s*o]*p;while(--h)}}while(--a);if(t.z=i[2*s+3]/i[2*s+2],t.y=(i[1*s+3]-i[1*s+2]*t.z)/i[1*s+1],t.x=(i[0*s+3]-i[0*s+2]*t.z-i[0*s+1]*t.y)/i[0*s+0],isNaN(t.x)||isNaN(t.y)||isNaN(t.z)||t.x===1/0||t.y===1/0||t.z===1/0)throw`Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;return t}e(e,t,n){if(n===void 0)return this.elements[t+3*e];this.elements[t+3*e]=n}copy(e){for(let t=0;t<e.elements.length;t++)this.elements[t]=e.elements[t];return this}toString(){let e="";const t=",";for(let n=0;n<9;n++)e+=this.elements[n]+t;return e}reverse(e){e===void 0&&(e=new pe);const t=3,n=6,s=ei;let i,o;for(i=0;i<3;i++)for(o=0;o<3;o++)s[i+n*o]=this.elements[i+3*o];s[3+6*0]=1,s[3+6*1]=0,s[3+6*2]=0,s[4+6*0]=0,s[4+6*1]=1,s[4+6*2]=0,s[5+6*0]=0,s[5+6*1]=0,s[5+6*2]=1;let r=3;const a=r;let c;const h=n;let l;do{if(i=a-r,s[i+n*i]===0){for(o=i+1;o<a;o++)if(s[i+n*o]!==0){c=h;do l=h-c,s[l+n*i]+=s[l+n*o];while(--c);break}}if(s[i+n*i]!==0)for(o=i+1;o<a;o++){const u=s[i+n*o]/s[i+n*i];c=h;do l=h-c,s[l+n*o]=l<=i?0:s[l+n*o]-s[l+n*i]*u;while(--c)}}while(--r);i=2;do{o=i-1;do{const u=s[i+n*o]/s[i+n*i];c=n;do l=n-c,s[l+n*o]=s[l+n*o]-s[l+n*i]*u;while(--c)}while(o--)}while(--i);i=2;do{const u=1/s[i+n*i];c=n;do l=n-c,s[l+n*i]=s[l+n*i]*u;while(--c)}while(i--);i=2;do{o=2;do{if(l=s[t+o+n*i],isNaN(l)||l===1/0)throw`Could not reverse! A=[${this.toString()}]`;e.e(i,o,l)}while(o--)}while(i--);return e}setRotationFromQuaternion(e){const t=e.x,n=e.y,s=e.z,i=e.w,o=t+t,r=n+n,a=s+s,c=t*o,h=t*r,l=t*a,u=n*r,p=n*a,m=s*a,y=i*o,g=i*r,w=i*a,v=this.elements;return v[3*0+0]=1-(u+m),v[3*0+1]=h-w,v[3*0+2]=l+g,v[3*1+0]=h+w,v[3*1+1]=1-(c+m),v[3*1+2]=p-y,v[3*2+0]=l-g,v[3*2+1]=p+y,v[3*2+2]=1-(c+u),this}transpose(e){e===void 0&&(e=new pe);const t=this.elements,n=e.elements;let s;return n[0]=t[0],n[4]=t[4],n[8]=t[8],s=t[1],n[1]=t[3],n[3]=s,s=t[2],n[2]=t[6],n[6]=s,s=t[5],n[5]=t[7],n[7]=s,e}}const ei=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class d{constructor(e,t,n){e===void 0&&(e=0),t===void 0&&(t=0),n===void 0&&(n=0),this.x=e,this.y=t,this.z=n}cross(e,t){t===void 0&&(t=new d);const n=e.x,s=e.y,i=e.z,o=this.x,r=this.y,a=this.z;return t.x=r*i-a*s,t.y=a*n-o*i,t.z=o*s-r*n,t}set(e,t,n){return this.x=e,this.y=t,this.z=n,this}setZero(){this.x=this.y=this.z=0}vadd(e,t){if(t)t.x=e.x+this.x,t.y=e.y+this.y,t.z=e.z+this.z;else return new d(this.x+e.x,this.y+e.y,this.z+e.z)}vsub(e,t){if(t)t.x=this.x-e.x,t.y=this.y-e.y,t.z=this.z-e.z;else return new d(this.x-e.x,this.y-e.y,this.z-e.z)}crossmat(){return new pe([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const e=this.x,t=this.y,n=this.z,s=Math.sqrt(e*e+t*t+n*n);if(s>0){const i=1/s;this.x*=i,this.y*=i,this.z*=i}else this.x=0,this.y=0,this.z=0;return s}unit(e){e===void 0&&(e=new d);const t=this.x,n=this.y,s=this.z;let i=Math.sqrt(t*t+n*n+s*s);return i>0?(i=1/i,e.x=t*i,e.y=n*i,e.z=s*i):(e.x=1,e.y=0,e.z=0),e}length(){const e=this.x,t=this.y,n=this.z;return Math.sqrt(e*e+t*t+n*n)}lengthSquared(){return this.dot(this)}distanceTo(e){const t=this.x,n=this.y,s=this.z,i=e.x,o=e.y,r=e.z;return Math.sqrt((i-t)*(i-t)+(o-n)*(o-n)+(r-s)*(r-s))}distanceSquared(e){const t=this.x,n=this.y,s=this.z,i=e.x,o=e.y,r=e.z;return(i-t)*(i-t)+(o-n)*(o-n)+(r-s)*(r-s)}scale(e,t){t===void 0&&(t=new d);const n=this.x,s=this.y,i=this.z;return t.x=e*n,t.y=e*s,t.z=e*i,t}vmul(e,t){return t===void 0&&(t=new d),t.x=e.x*this.x,t.y=e.y*this.y,t.z=e.z*this.z,t}addScaledVector(e,t,n){return n===void 0&&(n=new d),n.x=this.x+e*t.x,n.y=this.y+e*t.y,n.z=this.z+e*t.z,n}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}isZero(){return this.x===0&&this.y===0&&this.z===0}negate(e){return e===void 0&&(e=new d),e.x=-this.x,e.y=-this.y,e.z=-this.z,e}tangents(e,t){const n=this.length();if(n>0){const s=ti,i=1/n;s.set(this.x*i,this.y*i,this.z*i);const o=ni;Math.abs(s.x)<.9?(o.set(1,0,0),s.cross(o,e)):(o.set(0,1,0),s.cross(o,e)),s.cross(e,t)}else e.set(1,0,0),t.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}lerp(e,t,n){const s=this.x,i=this.y,o=this.z;n.x=s+(e.x-s)*t,n.y=i+(e.y-i)*t,n.z=o+(e.z-o)*t}almostEquals(e,t){return t===void 0&&(t=1e-6),!(Math.abs(this.x-e.x)>t||Math.abs(this.y-e.y)>t||Math.abs(this.z-e.z)>t)}almostZero(e){return e===void 0&&(e=1e-6),!(Math.abs(this.x)>e||Math.abs(this.y)>e||Math.abs(this.z)>e)}isAntiparallelTo(e,t){return this.negate(ln),ln.almostEquals(e,t)}clone(){return new d(this.x,this.y,this.z)}}d.ZERO=new d(0,0,0);d.UNIT_X=new d(1,0,0);d.UNIT_Y=new d(0,1,0);d.UNIT_Z=new d(0,0,1);const ti=new d,ni=new d,ln=new d;class ae{constructor(e){e===void 0&&(e={}),this.lowerBound=new d,this.upperBound=new d,e.lowerBound&&this.lowerBound.copy(e.lowerBound),e.upperBound&&this.upperBound.copy(e.upperBound)}setFromPoints(e,t,n,s){const i=this.lowerBound,o=this.upperBound,r=n;i.copy(e[0]),r&&r.vmult(i,i),o.copy(i);for(let a=1;a<e.length;a++){let c=e[a];r&&(r.vmult(c,hn),c=hn),c.x>o.x&&(o.x=c.x),c.x<i.x&&(i.x=c.x),c.y>o.y&&(o.y=c.y),c.y<i.y&&(i.y=c.y),c.z>o.z&&(o.z=c.z),c.z<i.z&&(i.z=c.z)}return t&&(t.vadd(i,i),t.vadd(o,o)),s&&(i.x-=s,i.y-=s,i.z-=s,o.x+=s,o.y+=s,o.z+=s),this}copy(e){return this.lowerBound.copy(e.lowerBound),this.upperBound.copy(e.upperBound),this}clone(){return new ae().copy(this)}extend(e){this.lowerBound.x=Math.min(this.lowerBound.x,e.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,e.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,e.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,e.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,e.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,e.upperBound.z)}overlaps(e){const t=this.lowerBound,n=this.upperBound,s=e.lowerBound,i=e.upperBound,o=s.x<=n.x&&n.x<=i.x||t.x<=i.x&&i.x<=n.x,r=s.y<=n.y&&n.y<=i.y||t.y<=i.y&&i.y<=n.y,a=s.z<=n.z&&n.z<=i.z||t.z<=i.z&&i.z<=n.z;return o&&r&&a}volume(){const e=this.lowerBound,t=this.upperBound;return(t.x-e.x)*(t.y-e.y)*(t.z-e.z)}contains(e){const t=this.lowerBound,n=this.upperBound,s=e.lowerBound,i=e.upperBound;return t.x<=s.x&&n.x>=i.x&&t.y<=s.y&&n.y>=i.y&&t.z<=s.z&&n.z>=i.z}getCorners(e,t,n,s,i,o,r,a){const c=this.lowerBound,h=this.upperBound;e.copy(c),t.set(h.x,c.y,c.z),n.set(h.x,h.y,c.z),s.set(c.x,h.y,h.z),i.set(h.x,c.y,h.z),o.set(c.x,h.y,c.z),r.set(c.x,c.y,h.z),a.copy(h)}toLocalFrame(e,t){const n=un,s=n[0],i=n[1],o=n[2],r=n[3],a=n[4],c=n[5],h=n[6],l=n[7];this.getCorners(s,i,o,r,a,c,h,l);for(let u=0;u!==8;u++){const p=n[u];e.pointToLocal(p,p)}return t.setFromPoints(n)}toWorldFrame(e,t){const n=un,s=n[0],i=n[1],o=n[2],r=n[3],a=n[4],c=n[5],h=n[6],l=n[7];this.getCorners(s,i,o,r,a,c,h,l);for(let u=0;u!==8;u++){const p=n[u];e.pointToWorld(p,p)}return t.setFromPoints(n)}overlapsRay(e){const{direction:t,from:n}=e,s=1/t.x,i=1/t.y,o=1/t.z,r=(this.lowerBound.x-n.x)*s,a=(this.upperBound.x-n.x)*s,c=(this.lowerBound.y-n.y)*i,h=(this.upperBound.y-n.y)*i,l=(this.lowerBound.z-n.z)*o,u=(this.upperBound.z-n.z)*o,p=Math.max(Math.max(Math.min(r,a),Math.min(c,h)),Math.min(l,u)),m=Math.min(Math.min(Math.max(r,a),Math.max(c,h)),Math.max(l,u));return!(m<0||p>m)}}const hn=new d,un=[new d,new d,new d,new d,new d,new d,new d,new d];class dn{constructor(){this.matrix=[]}get(e,t){let{index:n}=e,{index:s}=t;if(s>n){const i=s;s=n,n=i}return this.matrix[(n*(n+1)>>1)+s-1]}set(e,t,n){let{index:s}=e,{index:i}=t;if(i>s){const o=i;i=s,s=o}this.matrix[(s*(s+1)>>1)+i-1]=n?1:0}reset(){for(let e=0,t=this.matrix.length;e!==t;e++)this.matrix[e]=0}setNumObjects(e){this.matrix.length=e*(e-1)>>1}}class $n{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;return n[e]===void 0&&(n[e]=[]),n[e].includes(t)||n[e].push(t),this}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return!!(n[e]!==void 0&&n[e].includes(t))}hasAnyEventListener(e){return this._listeners===void 0?!1:this._listeners[e]!==void 0}removeEventListener(e,t){if(this._listeners===void 0)return this;const n=this._listeners;if(n[e]===void 0)return this;const s=n[e].indexOf(t);return s!==-1&&n[e].splice(s,1),this}dispatchEvent(e){if(this._listeners===void 0)return this;const n=this._listeners[e.type];if(n!==void 0){e.target=this;for(let s=0,i=n.length;s<i;s++)n[s].call(this,e)}return this}}class ${constructor(e,t,n,s){e===void 0&&(e=0),t===void 0&&(t=0),n===void 0&&(n=0),s===void 0&&(s=1),this.x=e,this.y=t,this.z=n,this.w=s}set(e,t,n,s){return this.x=e,this.y=t,this.z=n,this.w=s,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(e,t){const n=Math.sin(t*.5);return this.x=e.x*n,this.y=e.y*n,this.z=e.z*n,this.w=Math.cos(t*.5),this}toAxisAngle(e){e===void 0&&(e=new d),this.normalize();const t=2*Math.acos(this.w),n=Math.sqrt(1-this.w*this.w);return n<.001?(e.x=this.x,e.y=this.y,e.z=this.z):(e.x=this.x/n,e.y=this.y/n,e.z=this.z/n),[e,t]}setFromVectors(e,t){if(e.isAntiparallelTo(t)){const n=si,s=ii;e.tangents(n,s),this.setFromAxisAngle(n,Math.PI)}else{const n=e.cross(t);this.x=n.x,this.y=n.y,this.z=n.z,this.w=Math.sqrt(e.length()**2*t.length()**2)+e.dot(t),this.normalize()}return this}mult(e,t){t===void 0&&(t=new $);const n=this.x,s=this.y,i=this.z,o=this.w,r=e.x,a=e.y,c=e.z,h=e.w;return t.x=n*h+o*r+s*c-i*a,t.y=s*h+o*a+i*r-n*c,t.z=i*h+o*c+n*a-s*r,t.w=o*h-n*r-s*a-i*c,t}inverse(e){e===void 0&&(e=new $);const t=this.x,n=this.y,s=this.z,i=this.w;this.conjugate(e);const o=1/(t*t+n*n+s*s+i*i);return e.x*=o,e.y*=o,e.z*=o,e.w*=o,e}conjugate(e){return e===void 0&&(e=new $),e.x=-this.x,e.y=-this.y,e.z=-this.z,e.w=this.w,e}normalize(){let e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return e===0?(this.x=0,this.y=0,this.z=0,this.w=0):(e=1/e,this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}normalizeFast(){const e=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return e===0?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}vmult(e,t){t===void 0&&(t=new d);const n=e.x,s=e.y,i=e.z,o=this.x,r=this.y,a=this.z,c=this.w,h=c*n+r*i-a*s,l=c*s+a*n-o*i,u=c*i+o*s-r*n,p=-o*n-r*s-a*i;return t.x=h*c+p*-o+l*-a-u*-r,t.y=l*c+p*-r+u*-o-h*-a,t.z=u*c+p*-a+h*-r-l*-o,t}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}toEuler(e,t){t===void 0&&(t="YZX");let n,s,i;const o=this.x,r=this.y,a=this.z,c=this.w;switch(t){case"YZX":const h=o*r+a*c;if(h>.499&&(n=2*Math.atan2(o,c),s=Math.PI/2,i=0),h<-.499&&(n=-2*Math.atan2(o,c),s=-Math.PI/2,i=0),n===void 0){const l=o*o,u=r*r,p=a*a;n=Math.atan2(2*r*c-2*o*a,1-2*u-2*p),s=Math.asin(2*h),i=Math.atan2(2*o*c-2*r*a,1-2*l-2*p)}break;default:throw new Error(`Euler order ${t} not supported yet.`)}e.y=n,e.z=s,e.x=i}setFromEuler(e,t,n,s){s===void 0&&(s="XYZ");const i=Math.cos(e/2),o=Math.cos(t/2),r=Math.cos(n/2),a=Math.sin(e/2),c=Math.sin(t/2),h=Math.sin(n/2);return s==="XYZ"?(this.x=a*o*r+i*c*h,this.y=i*c*r-a*o*h,this.z=i*o*h+a*c*r,this.w=i*o*r-a*c*h):s==="YXZ"?(this.x=a*o*r+i*c*h,this.y=i*c*r-a*o*h,this.z=i*o*h-a*c*r,this.w=i*o*r+a*c*h):s==="ZXY"?(this.x=a*o*r-i*c*h,this.y=i*c*r+a*o*h,this.z=i*o*h+a*c*r,this.w=i*o*r-a*c*h):s==="ZYX"?(this.x=a*o*r-i*c*h,this.y=i*c*r+a*o*h,this.z=i*o*h-a*c*r,this.w=i*o*r+a*c*h):s==="YZX"?(this.x=a*o*r+i*c*h,this.y=i*c*r+a*o*h,this.z=i*o*h-a*c*r,this.w=i*o*r-a*c*h):s==="XZY"&&(this.x=a*o*r-i*c*h,this.y=i*c*r-a*o*h,this.z=i*o*h+a*c*r,this.w=i*o*r+a*c*h),this}clone(){return new $(this.x,this.y,this.z,this.w)}slerp(e,t,n){n===void 0&&(n=new $);const s=this.x,i=this.y,o=this.z,r=this.w;let a=e.x,c=e.y,h=e.z,l=e.w,u,p,m,y,g;return p=s*a+i*c+o*h+r*l,p<0&&(p=-p,a=-a,c=-c,h=-h,l=-l),1-p>1e-6?(u=Math.acos(p),m=Math.sin(u),y=Math.sin((1-t)*u)/m,g=Math.sin(t*u)/m):(y=1-t,g=t),n.x=y*s+g*a,n.y=y*i+g*c,n.z=y*o+g*h,n.w=y*r+g*l,n}integrate(e,t,n,s){s===void 0&&(s=new $);const i=e.x*n.x,o=e.y*n.y,r=e.z*n.z,a=this.x,c=this.y,h=this.z,l=this.w,u=t*.5;return s.x+=u*(i*l+o*h-r*c),s.y+=u*(o*l+r*a-i*h),s.z+=u*(r*l+i*c-o*a),s.w+=u*(-i*a-o*c-r*h),s}}const si=new d,ii=new d,oi={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class F{constructor(e){e===void 0&&(e={}),this.id=F.idCounter++,this.type=e.type||0,this.boundingSphereRadius=0,this.collisionResponse=e.collisionResponse?e.collisionResponse:!0,this.collisionFilterGroup=e.collisionFilterGroup!==void 0?e.collisionFilterGroup:1,this.collisionFilterMask=e.collisionFilterMask!==void 0?e.collisionFilterMask:-1,this.material=e.material?e.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(e,t){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(e,t,n,s){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}F.idCounter=0;F.types=oi;class H{constructor(e){e===void 0&&(e={}),this.position=new d,this.quaternion=new $,e.position&&this.position.copy(e.position),e.quaternion&&this.quaternion.copy(e.quaternion)}pointToLocal(e,t){return H.pointToLocalFrame(this.position,this.quaternion,e,t)}pointToWorld(e,t){return H.pointToWorldFrame(this.position,this.quaternion,e,t)}vectorToWorldFrame(e,t){return t===void 0&&(t=new d),this.quaternion.vmult(e,t),t}static pointToLocalFrame(e,t,n,s){return s===void 0&&(s=new d),n.vsub(e,s),t.conjugate(pn),pn.vmult(s,s),s}static pointToWorldFrame(e,t,n,s){return s===void 0&&(s=new d),t.vmult(n,s),s.vadd(e,s),s}static vectorToWorldFrame(e,t,n){return n===void 0&&(n=new d),e.vmult(t,n),n}static vectorToLocalFrame(e,t,n,s){return s===void 0&&(s=new d),t.w*=-1,t.vmult(n,s),t.w*=-1,s}}const pn=new $;class et extends F{constructor(e){e===void 0&&(e={});const{vertices:t=[],faces:n=[],normals:s=[],axes:i,boundingSphereRadius:o}=e;super({type:F.types.CONVEXPOLYHEDRON}),this.vertices=t,this.faces=n,this.faceNormals=s,this.faceNormals.length===0&&this.computeNormals(),o?this.boundingSphereRadius=o:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=i?i.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const e=this.faces,t=this.vertices,n=this.uniqueEdges;n.length=0;const s=new d;for(let i=0;i!==e.length;i++){const o=e[i],r=o.length;for(let a=0;a!==r;a++){const c=(a+1)%r;t[o[a]].vsub(t[o[c]],s),s.normalize();let h=!1;for(let l=0;l!==n.length;l++)if(n[l].almostEquals(s)||n[l].almostEquals(s)){h=!0;break}h||n.push(s.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let e=0;e<this.faces.length;e++){for(let s=0;s<this.faces[e].length;s++)if(!this.vertices[this.faces[e][s]])throw new Error(`Vertex ${this.faces[e][s]} not found!`);const t=this.faceNormals[e]||new d;this.getFaceNormal(e,t),t.negate(t),this.faceNormals[e]=t;const n=this.vertices[this.faces[e][0]];if(t.dot(n)<0){console.error(`.faceNormals[${e}] = Vec3(${t.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let s=0;s<this.faces[e].length;s++)console.warn(`.vertices[${this.faces[e][s]}] = Vec3(${this.vertices[this.faces[e][s]].toString()})`)}}}getFaceNormal(e,t){const n=this.faces[e],s=this.vertices[n[0]],i=this.vertices[n[1]],o=this.vertices[n[2]];et.computeNormal(s,i,o,t)}static computeNormal(e,t,n,s){const i=new d,o=new d;t.vsub(e,o),n.vsub(t,i),i.cross(o,s),s.isZero()||s.normalize()}clipAgainstHull(e,t,n,s,i,o,r,a,c){const h=new d;let l=-1,u=-Number.MAX_VALUE;for(let m=0;m<n.faces.length;m++){h.copy(n.faceNormals[m]),i.vmult(h,h);const y=h.dot(o);y>u&&(u=y,l=m)}const p=[];for(let m=0;m<n.faces[l].length;m++){const y=n.vertices[n.faces[l][m]],g=new d;g.copy(y),i.vmult(g,g),s.vadd(g,g),p.push(g)}l>=0&&this.clipFaceAgainstHull(o,e,t,p,r,a,c)}findSeparatingAxis(e,t,n,s,i,o,r,a){const c=new d,h=new d,l=new d,u=new d,p=new d,m=new d;let y=Number.MAX_VALUE;const g=this;if(g.uniqueAxes)for(let w=0;w!==g.uniqueAxes.length;w++){n.vmult(g.uniqueAxes[w],c);const v=g.testSepAxis(c,e,t,n,s,i);if(v===!1)return!1;v<y&&(y=v,o.copy(c))}else{const w=r?r.length:g.faces.length;for(let v=0;v<w;v++){const x=r?r[v]:v;c.copy(g.faceNormals[x]),n.vmult(c,c);const A=g.testSepAxis(c,e,t,n,s,i);if(A===!1)return!1;A<y&&(y=A,o.copy(c))}}if(e.uniqueAxes)for(let w=0;w!==e.uniqueAxes.length;w++){i.vmult(e.uniqueAxes[w],h);const v=g.testSepAxis(h,e,t,n,s,i);if(v===!1)return!1;v<y&&(y=v,o.copy(h))}else{const w=a?a.length:e.faces.length;for(let v=0;v<w;v++){const x=a?a[v]:v;h.copy(e.faceNormals[x]),i.vmult(h,h);const A=g.testSepAxis(h,e,t,n,s,i);if(A===!1)return!1;A<y&&(y=A,o.copy(h))}}for(let w=0;w!==g.uniqueEdges.length;w++){n.vmult(g.uniqueEdges[w],u);for(let v=0;v!==e.uniqueEdges.length;v++)if(i.vmult(e.uniqueEdges[v],p),u.cross(p,m),!m.almostZero()){m.normalize();const x=g.testSepAxis(m,e,t,n,s,i);if(x===!1)return!1;x<y&&(y=x,o.copy(m))}}return s.vsub(t,l),l.dot(o)>0&&o.negate(o),!0}testSepAxis(e,t,n,s,i,o){const r=this;et.project(r,e,n,s,St),et.project(t,e,i,o,Mt);const a=St[0],c=St[1],h=Mt[0],l=Mt[1];if(a<l||h<c)return!1;const u=a-l,p=h-c;return u<p?u:p}calculateLocalInertia(e,t){const n=new d,s=new d;this.computeLocalAABB(s,n);const i=n.x-s.x,o=n.y-s.y,r=n.z-s.z;t.x=1/12*e*(2*o*2*o+2*r*2*r),t.y=1/12*e*(2*i*2*i+2*r*2*r),t.z=1/12*e*(2*o*2*o+2*i*2*i)}getPlaneConstantOfFace(e){const t=this.faces[e],n=this.faceNormals[e],s=this.vertices[t[0]];return-n.dot(s)}clipFaceAgainstHull(e,t,n,s,i,o,r){const a=new d,c=new d,h=new d,l=new d,u=new d,p=new d,m=new d,y=new d,g=this,w=[],v=s,x=w;let A=-1,T=Number.MAX_VALUE;for(let P=0;P<g.faces.length;P++){a.copy(g.faceNormals[P]),n.vmult(a,a);const L=a.dot(e);L<T&&(T=L,A=P)}if(A<0)return;const E=g.faces[A];E.connectedFaces=[];for(let P=0;P<g.faces.length;P++)for(let L=0;L<g.faces[P].length;L++)E.indexOf(g.faces[P][L])!==-1&&P!==A&&E.connectedFaces.indexOf(P)===-1&&E.connectedFaces.push(P);const M=E.length;for(let P=0;P<M;P++){const L=g.vertices[E[P]],k=g.vertices[E[(P+1)%M]];L.vsub(k,c),h.copy(c),n.vmult(h,h),t.vadd(h,h),l.copy(this.faceNormals[A]),n.vmult(l,l),t.vadd(l,l),h.cross(l,u),u.negate(u),p.copy(L),n.vmult(p,p),t.vadd(p,p);const S=E.connectedFaces[P];m.copy(this.faceNormals[S]);const I=this.getPlaneConstantOfFace(S);y.copy(m),n.vmult(y,y);const R=I-y.dot(t);for(this.clipFaceAgainstPlane(v,x,y,R);v.length;)v.shift();for(;x.length;)v.push(x.shift())}m.copy(this.faceNormals[A]);const C=this.getPlaneConstantOfFace(A);y.copy(m),n.vmult(y,y);const N=C-y.dot(t);for(let P=0;P<v.length;P++){let L=y.dot(v[P])+N;if(L<=i&&(console.log(`clamped: depth=${L} to minDist=${i}`),L=i),L<=o){const k=v[P];if(L<=1e-6){const S={point:k,normal:y,depth:L};r.push(S)}}}}clipFaceAgainstPlane(e,t,n,s){let i,o;const r=e.length;if(r<2)return t;let a=e[e.length-1],c=e[0];i=n.dot(a)+s;for(let h=0;h<r;h++){if(c=e[h],o=n.dot(c)+s,i<0)if(o<0){const l=new d;l.copy(c),t.push(l)}else{const l=new d;a.lerp(c,i/(i-o),l),t.push(l)}else if(o<0){const l=new d;a.lerp(c,i/(i-o),l),t.push(l),t.push(c)}a=c,i=o}return t}computeWorldVertices(e,t){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new d);const n=this.vertices,s=this.worldVertices;for(let i=0;i!==this.vertices.length;i++)t.vmult(n[i],s[i]),e.vadd(s[i],s[i]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(e,t){const n=this.vertices;e.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),t.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let s=0;s<this.vertices.length;s++){const i=n[s];i.x<e.x?e.x=i.x:i.x>t.x&&(t.x=i.x),i.y<e.y?e.y=i.y:i.y>t.y&&(t.y=i.y),i.z<e.z?e.z=i.z:i.z>t.z&&(t.z=i.z)}}computeWorldFaceNormals(e){const t=this.faceNormals.length;for(;this.worldFaceNormals.length<t;)this.worldFaceNormals.push(new d);const n=this.faceNormals,s=this.worldFaceNormals;for(let i=0;i!==t;i++)e.vmult(n[i],s[i]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let e=0;const t=this.vertices;for(let n=0;n!==t.length;n++){const s=t[n].lengthSquared();s>e&&(e=s)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,n,s){const i=this.vertices;let o,r,a,c,h,l,u=new d;for(let p=0;p<i.length;p++){u.copy(i[p]),t.vmult(u,u),e.vadd(u,u);const m=u;(o===void 0||m.x<o)&&(o=m.x),(c===void 0||m.x>c)&&(c=m.x),(r===void 0||m.y<r)&&(r=m.y),(h===void 0||m.y>h)&&(h=m.y),(a===void 0||m.z<a)&&(a=m.z),(l===void 0||m.z>l)&&(l=m.z)}n.set(o,r,a),s.set(c,h,l)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(e){e===void 0&&(e=new d);const t=this.vertices;for(let n=0;n<t.length;n++)e.vadd(t[n],e);return e.scale(1/t.length,e),e}transformAllPoints(e,t){const n=this.vertices.length,s=this.vertices;if(t){for(let i=0;i<n;i++){const o=s[i];t.vmult(o,o)}for(let i=0;i<this.faceNormals.length;i++){const o=this.faceNormals[i];t.vmult(o,o)}}if(e)for(let i=0;i<n;i++){const o=s[i];o.vadd(e,o)}}pointIsInside(e){const t=this.vertices,n=this.faces,s=this.faceNormals,i=new d;this.getAveragePointLocal(i);for(let o=0;o<this.faces.length;o++){let r=s[o];const a=t[n[o][0]],c=new d;e.vsub(a,c);const h=r.dot(c),l=new d;i.vsub(a,l);const u=r.dot(l);if(h<0&&u>0||h>0&&u<0)return!1}return-1}static project(e,t,n,s,i){const o=e.vertices.length,r=ri;let a=0,c=0;const h=ai,l=e.vertices;h.setZero(),H.vectorToLocalFrame(n,s,t,r),H.pointToLocalFrame(n,s,h,h);const u=h.dot(r);c=a=l[0].dot(r);for(let p=1;p<o;p++){const m=l[p].dot(r);m>a&&(a=m),m<c&&(c=m)}if(c-=u,a-=u,c>a){const p=c;c=a,a=p}i[0]=a,i[1]=c}}const St=[],Mt=[];new d;const ri=new d,ai=new d;let Qt=class Zn extends F{constructor(e){super({type:F.types.BOX}),this.halfExtents=e,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const e=this.halfExtents.x,t=this.halfExtents.y,n=this.halfExtents.z,s=d,i=[new s(-e,-t,-n),new s(e,-t,-n),new s(e,t,-n),new s(-e,t,-n),new s(-e,-t,n),new s(e,-t,n),new s(e,t,n),new s(-e,t,n)],o=[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],r=[new s(0,0,1),new s(0,1,0),new s(1,0,0)],a=new et({vertices:i,faces:o,axes:r});this.convexPolyhedronRepresentation=a,a.material=this.material}calculateLocalInertia(e,t){return t===void 0&&(t=new d),Zn.calculateInertia(this.halfExtents,e,t),t}static calculateInertia(e,t,n){const s=e;n.x=1/12*t*(2*s.y*2*s.y+2*s.z*2*s.z),n.y=1/12*t*(2*s.x*2*s.x+2*s.z*2*s.z),n.z=1/12*t*(2*s.y*2*s.y+2*s.x*2*s.x)}getSideNormals(e,t){const n=e,s=this.halfExtents;if(n[0].set(s.x,0,0),n[1].set(0,s.y,0),n[2].set(0,0,s.z),n[3].set(-s.x,0,0),n[4].set(0,-s.y,0),n[5].set(0,0,-s.z),t!==void 0)for(let i=0;i!==n.length;i++)t.vmult(n[i],n[i]);return n}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(e,t,n){const s=this.halfExtents,i=[[s.x,s.y,s.z],[-s.x,s.y,s.z],[-s.x,-s.y,s.z],[-s.x,-s.y,-s.z],[s.x,-s.y,-s.z],[s.x,s.y,-s.z],[-s.x,s.y,-s.z],[s.x,-s.y,s.z]];for(let o=0;o<i.length;o++)Ce.set(i[o][0],i[o][1],i[o][2]),t.vmult(Ce,Ce),e.vadd(Ce,Ce),n(Ce.x,Ce.y,Ce.z)}calculateWorldAABB(e,t,n,s){const i=this.halfExtents;fe[0].set(i.x,i.y,i.z),fe[1].set(-i.x,i.y,i.z),fe[2].set(-i.x,-i.y,i.z),fe[3].set(-i.x,-i.y,-i.z),fe[4].set(i.x,-i.y,-i.z),fe[5].set(i.x,i.y,-i.z),fe[6].set(-i.x,i.y,-i.z),fe[7].set(i.x,-i.y,i.z);const o=fe[0];t.vmult(o,o),e.vadd(o,o),s.copy(o),n.copy(o);for(let r=1;r<8;r++){const a=fe[r];t.vmult(a,a),e.vadd(a,a);const c=a.x,h=a.y,l=a.z;c>s.x&&(s.x=c),h>s.y&&(s.y=h),l>s.z&&(s.z=l),c<n.x&&(n.x=c),h<n.y&&(n.y=h),l<n.z&&(n.z=l)}}};const Ce=new d,fe=[new d,new d,new d,new d,new d,new d,new d,new d],Jt={DYNAMIC:1,STATIC:2,KINEMATIC:4},en={AWAKE:0,SLEEPY:1,SLEEPING:2};class _ extends $n{constructor(e){e===void 0&&(e={}),super(),this.id=_.idCounter++,this.index=-1,this.world=null,this.vlambda=new d,this.collisionFilterGroup=typeof e.collisionFilterGroup=="number"?e.collisionFilterGroup:1,this.collisionFilterMask=typeof e.collisionFilterMask=="number"?e.collisionFilterMask:-1,this.collisionResponse=typeof e.collisionResponse=="boolean"?e.collisionResponse:!0,this.position=new d,this.previousPosition=new d,this.interpolatedPosition=new d,this.initPosition=new d,e.position&&(this.position.copy(e.position),this.previousPosition.copy(e.position),this.interpolatedPosition.copy(e.position),this.initPosition.copy(e.position)),this.velocity=new d,e.velocity&&this.velocity.copy(e.velocity),this.initVelocity=new d,this.force=new d;const t=typeof e.mass=="number"?e.mass:0;this.mass=t,this.invMass=t>0?1/t:0,this.material=e.material||null,this.linearDamping=typeof e.linearDamping=="number"?e.linearDamping:.01,this.type=t<=0?_.STATIC:_.DYNAMIC,typeof e.type==typeof _.STATIC&&(this.type=e.type),this.allowSleep=typeof e.allowSleep<"u"?e.allowSleep:!0,this.sleepState=_.AWAKE,this.sleepSpeedLimit=typeof e.sleepSpeedLimit<"u"?e.sleepSpeedLimit:.1,this.sleepTimeLimit=typeof e.sleepTimeLimit<"u"?e.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new d,this.quaternion=new $,this.initQuaternion=new $,this.previousQuaternion=new $,this.interpolatedQuaternion=new $,e.quaternion&&(this.quaternion.copy(e.quaternion),this.initQuaternion.copy(e.quaternion),this.previousQuaternion.copy(e.quaternion),this.interpolatedQuaternion.copy(e.quaternion)),this.angularVelocity=new d,e.angularVelocity&&this.angularVelocity.copy(e.angularVelocity),this.initAngularVelocity=new d,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new d,this.invInertia=new d,this.invInertiaWorld=new pe,this.invMassSolve=0,this.invInertiaSolve=new d,this.invInertiaWorldSolve=new pe,this.fixedRotation=typeof e.fixedRotation<"u"?e.fixedRotation:!1,this.angularDamping=typeof e.angularDamping<"u"?e.angularDamping:.01,this.linearFactor=new d(1,1,1),e.linearFactor&&this.linearFactor.copy(e.linearFactor),this.angularFactor=new d(1,1,1),e.angularFactor&&this.angularFactor.copy(e.angularFactor),this.aabb=new ae,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new d,this.isTrigger=!!e.isTrigger,e.shape&&this.addShape(e.shape),this.updateMassProperties()}wakeUp(){const e=this.sleepState;this.sleepState=_.AWAKE,this.wakeUpAfterNarrowphase=!1,e===_.SLEEPING&&this.dispatchEvent(_.wakeupEvent)}sleep(){this.sleepState=_.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(e){if(this.allowSleep){const t=this.sleepState,n=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),s=this.sleepSpeedLimit**2;t===_.AWAKE&&n<s?(this.sleepState=_.SLEEPY,this.timeLastSleepy=e,this.dispatchEvent(_.sleepyEvent)):t===_.SLEEPY&&n>s?this.wakeUp():t===_.SLEEPY&&e-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(_.sleepEvent))}}updateSolveMassProperties(){this.sleepState===_.SLEEPING||this.type===_.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(e,t){return t===void 0&&(t=new d),e.vsub(this.position,t),this.quaternion.conjugate().vmult(t,t),t}vectorToLocalFrame(e,t){return t===void 0&&(t=new d),this.quaternion.conjugate().vmult(e,t),t}pointToWorldFrame(e,t){return t===void 0&&(t=new d),this.quaternion.vmult(e,t),t.vadd(this.position,t),t}vectorToWorldFrame(e,t){return t===void 0&&(t=new d),this.quaternion.vmult(e,t),t}addShape(e,t,n){const s=new d,i=new $;return t&&s.copy(t),n&&i.copy(n),this.shapes.push(e),this.shapeOffsets.push(s),this.shapeOrientations.push(i),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=this,this}removeShape(e){const t=this.shapes.indexOf(e);return t===-1?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(t,1),this.shapeOffsets.splice(t,1),this.shapeOrientations.splice(t,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=null,this)}updateBoundingRadius(){const e=this.shapes,t=this.shapeOffsets,n=e.length;let s=0;for(let i=0;i!==n;i++){const o=e[i];o.updateBoundingSphereRadius();const r=t[i].length(),a=o.boundingSphereRadius;r+a>s&&(s=r+a)}this.boundingRadius=s}updateAABB(){const e=this.shapes,t=this.shapeOffsets,n=this.shapeOrientations,s=e.length,i=ci,o=li,r=this.quaternion,a=this.aabb,c=hi;for(let h=0;h!==s;h++){const l=e[h];r.vmult(t[h],i),i.vadd(this.position,i),r.mult(n[h],o),l.calculateWorldAABB(i,o,c.lowerBound,c.upperBound),h===0?a.copy(c):a.extend(c)}this.aabbNeedsUpdate=!1}updateInertiaWorld(e){const t=this.invInertia;if(!(t.x===t.y&&t.y===t.z&&!e)){const n=ui,s=di;n.setRotationFromQuaternion(this.quaternion),n.transpose(s),n.scale(t,n),n.mmult(s,this.invInertiaWorld)}}applyForce(e,t){if(t===void 0&&(t=new d),this.type!==_.DYNAMIC)return;this.sleepState===_.SLEEPING&&this.wakeUp();const n=pi;t.cross(e,n),this.force.vadd(e,this.force),this.torque.vadd(n,this.torque)}applyLocalForce(e,t){if(t===void 0&&(t=new d),this.type!==_.DYNAMIC)return;const n=fi,s=mi;this.vectorToWorldFrame(e,n),this.vectorToWorldFrame(t,s),this.applyForce(n,s)}applyTorque(e){this.type===_.DYNAMIC&&(this.sleepState===_.SLEEPING&&this.wakeUp(),this.torque.vadd(e,this.torque))}applyImpulse(e,t){if(t===void 0&&(t=new d),this.type!==_.DYNAMIC)return;this.sleepState===_.SLEEPING&&this.wakeUp();const n=t,s=gi;s.copy(e),s.scale(this.invMass,s),this.velocity.vadd(s,this.velocity);const i=yi;n.cross(e,i),this.invInertiaWorld.vmult(i,i),this.angularVelocity.vadd(i,this.angularVelocity)}applyLocalImpulse(e,t){if(t===void 0&&(t=new d),this.type!==_.DYNAMIC)return;const n=vi,s=wi;this.vectorToWorldFrame(e,n),this.vectorToWorldFrame(t,s),this.applyImpulse(n,s)}updateMassProperties(){const e=xi;this.invMass=this.mass>0?1/this.mass:0;const t=this.inertia,n=this.fixedRotation;this.updateAABB(),e.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),Qt.calculateInertia(e,this.mass,t),this.invInertia.set(t.x>0&&!n?1/t.x:0,t.y>0&&!n?1/t.y:0,t.z>0&&!n?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(e,t){const n=new d;return e.vsub(this.position,n),this.angularVelocity.cross(n,t),this.velocity.vadd(t,t),t}integrate(e,t,n){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),!(this.type===_.DYNAMIC||this.type===_.KINEMATIC)||this.sleepState===_.SLEEPING)return;const s=this.velocity,i=this.angularVelocity,o=this.position,r=this.force,a=this.torque,c=this.quaternion,h=this.invMass,l=this.invInertiaWorld,u=this.linearFactor,p=h*e;s.x+=r.x*p*u.x,s.y+=r.y*p*u.y,s.z+=r.z*p*u.z;const m=l.elements,y=this.angularFactor,g=a.x*y.x,w=a.y*y.y,v=a.z*y.z;i.x+=e*(m[0]*g+m[1]*w+m[2]*v),i.y+=e*(m[3]*g+m[4]*w+m[5]*v),i.z+=e*(m[6]*g+m[7]*w+m[8]*v),o.x+=s.x*e,o.y+=s.y*e,o.z+=s.z*e,c.integrate(this.angularVelocity,e,this.angularFactor,c),t&&(n?c.normalizeFast():c.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}_.idCounter=0;_.COLLIDE_EVENT_NAME="collide";_.DYNAMIC=Jt.DYNAMIC;_.STATIC=Jt.STATIC;_.KINEMATIC=Jt.KINEMATIC;_.AWAKE=en.AWAKE;_.SLEEPY=en.SLEEPY;_.SLEEPING=en.SLEEPING;_.wakeupEvent={type:"wakeup"};_.sleepyEvent={type:"sleepy"};_.sleepEvent={type:"sleep"};const ci=new d,li=new $,hi=new ae,ui=new pe,di=new pe;new pe;const pi=new d,fi=new d,mi=new d,gi=new d,yi=new d,vi=new d,wi=new d,xi=new d;class Ai{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(e,t,n){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(e,t){return!(!(e.collisionFilterGroup&t.collisionFilterMask)||!(t.collisionFilterGroup&e.collisionFilterMask)||(e.type&_.STATIC||e.sleepState===_.SLEEPING)&&(t.type&_.STATIC||t.sleepState===_.SLEEPING))}intersectionTest(e,t,n,s){this.useBoundingBoxes?this.doBoundingBoxBroadphase(e,t,n,s):this.doBoundingSphereBroadphase(e,t,n,s)}doBoundingSphereBroadphase(e,t,n,s){const i=Ti;t.position.vsub(e.position,i);const o=(e.boundingRadius+t.boundingRadius)**2;i.lengthSquared()<o&&(n.push(e),s.push(t))}doBoundingBoxBroadphase(e,t,n,s){e.aabbNeedsUpdate&&e.updateAABB(),t.aabbNeedsUpdate&&t.updateAABB(),e.aabb.overlaps(t.aabb)&&(n.push(e),s.push(t))}makePairsUnique(e,t){const n=Ei,s=bi,i=Si,o=e.length;for(let r=0;r!==o;r++)s[r]=e[r],i[r]=t[r];e.length=0,t.length=0;for(let r=0;r!==o;r++){const a=s[r].id,c=i[r].id,h=a<c?`${a},${c}`:`${c},${a}`;n[h]=r,n.keys.push(h)}for(let r=0;r!==n.keys.length;r++){const a=n.keys.pop(),c=n[a];e.push(s[c]),t.push(i[c]),delete n[a]}}setWorld(e){}static boundingSphereCheck(e,t){const n=new d;e.position.vsub(t.position,n);const s=e.shapes[0],i=t.shapes[0];return Math.pow(s.boundingSphereRadius+i.boundingSphereRadius,2)>n.lengthSquared()}aabbQuery(e,t,n){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const Ti=new d;new d;new $;new d;const Ei={keys:[]},bi=[],Si=[];new d;new d;new d;class Qn extends Ai{constructor(){super()}collisionPairs(e,t,n){const s=e.bodies,i=s.length;let o,r;for(let a=0;a!==i;a++)for(let c=0;c!==a;c++)o=s[a],r=s[c],this.needBroadphaseCollision(o,r)&&this.intersectionTest(o,r,t,n)}aabbQuery(e,t,n){n===void 0&&(n=[]);for(let s=0;s<e.bodies.length;s++){const i=e.bodies[s];i.aabbNeedsUpdate&&i.updateAABB(),i.aabb.overlaps(t)&&n.push(i)}return n}}class xt{constructor(){this.rayFromWorld=new d,this.rayToWorld=new d,this.hitNormalWorld=new d,this.hitPointWorld=new d,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(e,t,n,s,i,o,r){this.rayFromWorld.copy(e),this.rayToWorld.copy(t),this.hitNormalWorld.copy(n),this.hitPointWorld.copy(s),this.shape=i,this.body=o,this.distance=r}}let Jn,es,ts,ns,ss,is,os;const tn={CLOSEST:1,ANY:2,ALL:4};Jn=F.types.SPHERE;es=F.types.PLANE;ts=F.types.BOX;ns=F.types.CYLINDER;ss=F.types.CONVEXPOLYHEDRON;is=F.types.HEIGHTFIELD;os=F.types.TRIMESH;class Y{get[Jn](){return this._intersectSphere}get[es](){return this._intersectPlane}get[ts](){return this._intersectBox}get[ns](){return this._intersectConvex}get[ss](){return this._intersectConvex}get[is](){return this._intersectHeightfield}get[os](){return this._intersectTrimesh}constructor(e,t){e===void 0&&(e=new d),t===void 0&&(t=new d),this.from=e.clone(),this.to=t.clone(),this.direction=new d,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=Y.ANY,this.result=new xt,this.hasHit=!1,this.callback=n=>{}}intersectWorld(e,t){return this.mode=t.mode||Y.ANY,this.result=t.result||new xt,this.skipBackfaces=!!t.skipBackfaces,this.collisionFilterMask=typeof t.collisionFilterMask<"u"?t.collisionFilterMask:-1,this.collisionFilterGroup=typeof t.collisionFilterGroup<"u"?t.collisionFilterGroup:-1,this.checkCollisionResponse=typeof t.checkCollisionResponse<"u"?t.checkCollisionResponse:!0,t.from&&this.from.copy(t.from),t.to&&this.to.copy(t.to),this.callback=t.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(fn),Rt.length=0,e.broadphase.aabbQuery(e,fn,Rt),this.intersectBodies(Rt),this.hasHit}intersectBody(e,t){t&&(this.result=t,this.updateDirection());const n=this.checkCollisionResponse;if(n&&!e.collisionResponse||!(this.collisionFilterGroup&e.collisionFilterMask)||!(e.collisionFilterGroup&this.collisionFilterMask))return;const s=Mi,i=Ri;for(let o=0,r=e.shapes.length;o<r;o++){const a=e.shapes[o];if(!(n&&!a.collisionResponse)&&(e.quaternion.mult(e.shapeOrientations[o],i),e.quaternion.vmult(e.shapeOffsets[o],s),s.vadd(e.position,s),this.intersectShape(a,i,s,e),this.result.shouldStop))break}}intersectBodies(e,t){t&&(this.result=t,this.updateDirection());for(let n=0,s=e.length;!this.result.shouldStop&&n<s;n++)this.intersectBody(e[n])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(e,t,n,s){const i=this.from;if(qi(i,this.direction,n)>e.boundingSphereRadius)return;const r=this[e.type];r&&r.call(this,e,t,n,s,e)}_intersectBox(e,t,n,s,i){return this._intersectConvex(e.convexPolyhedronRepresentation,t,n,s,i)}_intersectPlane(e,t,n,s,i){const o=this.from,r=this.to,a=this.direction,c=new d(0,0,1);t.vmult(c,c);const h=new d;o.vsub(n,h);const l=h.dot(c);r.vsub(n,h);const u=h.dot(c);if(l*u>0||o.distanceTo(r)<l)return;const p=c.dot(a);if(Math.abs(p)<this.precision)return;const m=new d,y=new d,g=new d;o.vsub(n,m);const w=-c.dot(m)/p;a.scale(w,y),o.vadd(y,g),this.reportIntersection(c,g,i,s,-1)}getAABB(e){const{lowerBound:t,upperBound:n}=e,s=this.to,i=this.from;t.x=Math.min(s.x,i.x),t.y=Math.min(s.y,i.y),t.z=Math.min(s.z,i.z),n.x=Math.max(s.x,i.x),n.y=Math.max(s.y,i.y),n.z=Math.max(s.z,i.z)}_intersectHeightfield(e,t,n,s,i){e.data,e.elementSize;const o=Ci;o.from.copy(this.from),o.to.copy(this.to),H.pointToLocalFrame(n,t,o.from,o.from),H.pointToLocalFrame(n,t,o.to,o.to),o.updateDirection();const r=Ii;let a,c,h,l;a=c=0,h=l=e.data.length-1;const u=new ae;o.getAABB(u),e.getIndexOfPosition(u.lowerBound.x,u.lowerBound.y,r,!0),a=Math.max(a,r[0]),c=Math.max(c,r[1]),e.getIndexOfPosition(u.upperBound.x,u.upperBound.y,r,!0),h=Math.min(h,r[0]+1),l=Math.min(l,r[1]+1);for(let p=a;p<h;p++)for(let m=c;m<l;m++){if(this.result.shouldStop)return;if(e.getAabbAtIndex(p,m,u),!!u.overlapsRay(o)){if(e.getConvexTrianglePillar(p,m,!1),H.pointToWorldFrame(n,t,e.pillarOffset,ut),this._intersectConvex(e.pillarConvex,t,ut,s,i,mn),this.result.shouldStop)return;e.getConvexTrianglePillar(p,m,!0),H.pointToWorldFrame(n,t,e.pillarOffset,ut),this._intersectConvex(e.pillarConvex,t,ut,s,i,mn)}}}_intersectSphere(e,t,n,s,i){const o=this.from,r=this.to,a=e.radius,c=(r.x-o.x)**2+(r.y-o.y)**2+(r.z-o.z)**2,h=2*((r.x-o.x)*(o.x-n.x)+(r.y-o.y)*(o.y-n.y)+(r.z-o.z)*(o.z-n.z)),l=(o.x-n.x)**2+(o.y-n.y)**2+(o.z-n.z)**2-a**2,u=h**2-4*c*l,p=Li,m=Pi;if(!(u<0))if(u===0)o.lerp(r,u,p),p.vsub(n,m),m.normalize(),this.reportIntersection(m,p,i,s,-1);else{const y=(-h-Math.sqrt(u))/(2*c),g=(-h+Math.sqrt(u))/(2*c);if(y>=0&&y<=1&&(o.lerp(r,y,p),p.vsub(n,m),m.normalize(),this.reportIntersection(m,p,i,s,-1)),this.result.shouldStop)return;g>=0&&g<=1&&(o.lerp(r,g,p),p.vsub(n,m),m.normalize(),this.reportIntersection(m,p,i,s,-1))}}_intersectConvex(e,t,n,s,i,o){const r=Fi,a=gn,c=o&&o.faceList||null,h=e.faces,l=e.vertices,u=e.faceNormals,p=this.direction,m=this.from,y=this.to,g=m.distanceTo(y),w=c?c.length:h.length,v=this.result;for(let x=0;!v.shouldStop&&x<w;x++){const A=c?c[x]:x,T=h[A],E=u[A],M=t,C=n;a.copy(l[T[0]]),M.vmult(a,a),a.vadd(C,a),a.vsub(m,a),M.vmult(E,r);const N=p.dot(r);if(Math.abs(N)<this.precision)continue;const P=r.dot(a)/N;if(!(P<0)){p.scale(P,oe),oe.vadd(m,oe),he.copy(l[T[0]]),M.vmult(he,he),C.vadd(he,he);for(let L=1;!v.shouldStop&&L<T.length-1;L++){me.copy(l[T[L]]),ge.copy(l[T[L+1]]),M.vmult(me,me),M.vmult(ge,ge),C.vadd(me,me),C.vadd(ge,ge);const k=oe.distanceTo(m);!(Y.pointInTriangle(oe,he,me,ge)||Y.pointInTriangle(oe,me,he,ge))||k>g||this.reportIntersection(r,oe,i,s,A)}}}}_intersectTrimesh(e,t,n,s,i,o){const r=_i,a=Di,c=Gi,h=gn,l=Ni,u=Bi,p=zi,m=Oi,y=ki,g=e.indices;e.vertices;const w=this.from,v=this.to,x=this.direction;c.position.copy(n),c.quaternion.copy(t),H.vectorToLocalFrame(n,t,x,l),H.pointToLocalFrame(n,t,w,u),H.pointToLocalFrame(n,t,v,p),p.x*=e.scale.x,p.y*=e.scale.y,p.z*=e.scale.z,u.x*=e.scale.x,u.y*=e.scale.y,u.z*=e.scale.z,p.vsub(u,l),l.normalize();const A=u.distanceSquared(p);e.tree.rayQuery(this,c,a);for(let T=0,E=a.length;!this.result.shouldStop&&T!==E;T++){const M=a[T];e.getNormal(M,r),e.getVertex(g[M*3],he),he.vsub(u,h);const C=l.dot(r),N=r.dot(h)/C;if(N<0)continue;l.scale(N,oe),oe.vadd(u,oe),e.getVertex(g[M*3+1],me),e.getVertex(g[M*3+2],ge);const P=oe.distanceSquared(u);!(Y.pointInTriangle(oe,me,he,ge)||Y.pointInTriangle(oe,he,me,ge))||P>A||(H.vectorToWorldFrame(t,r,y),H.pointToWorldFrame(n,t,oe,m),this.reportIntersection(y,m,i,s,M))}a.length=0}reportIntersection(e,t,n,s,i){const o=this.from,r=this.to,a=o.distanceTo(t),c=this.result;if(!(this.skipBackfaces&&e.dot(this.direction)>0))switch(c.hitFaceIndex=typeof i<"u"?i:-1,this.mode){case Y.ALL:this.hasHit=!0,c.set(o,r,e,t,n,s,a),c.hasHit=!0,this.callback(c);break;case Y.CLOSEST:(a<c.distance||!c.hasHit)&&(this.hasHit=!0,c.hasHit=!0,c.set(o,r,e,t,n,s,a));break;case Y.ANY:this.hasHit=!0,c.hasHit=!0,c.set(o,r,e,t,n,s,a),c.shouldStop=!0;break}}static pointInTriangle(e,t,n,s){s.vsub(t,ze),n.vsub(t,Xe),e.vsub(t,Ct);const i=ze.dot(ze),o=ze.dot(Xe),r=ze.dot(Ct),a=Xe.dot(Xe),c=Xe.dot(Ct);let h,l;return(h=a*r-o*c)>=0&&(l=i*c-o*r)>=0&&h+l<i*a-o*o}}Y.CLOSEST=tn.CLOSEST;Y.ANY=tn.ANY;Y.ALL=tn.ALL;const fn=new ae,Rt=[],Xe=new d,Ct=new d,Mi=new d,Ri=new $,oe=new d,he=new d,me=new d,ge=new d;new d;new xt;const mn={faceList:[0]},ut=new d,Ci=new Y,Ii=[],Li=new d,Pi=new d,Fi=new d;new d;new d;const gn=new d,_i=new d,Ni=new d,Bi=new d,zi=new d,ki=new d,Oi=new d;new ae;const Di=[],Gi=new H,ze=new d,dt=new d;function qi(f,e,t){t.vsub(f,ze);const n=ze.dot(e);return e.scale(n,dt),dt.vadd(f,dt),t.distanceTo(dt)}class Hi{static defaults(e,t){e===void 0&&(e={});for(let n in t)n in e||(e[n]=t[n]);return e}}class yn{constructor(){this.spatial=new d,this.rotational=new d}multiplyElement(e){return e.spatial.dot(this.spatial)+e.rotational.dot(this.rotational)}multiplyVectors(e,t){return e.dot(this.spatial)+t.dot(this.rotational)}}class at{constructor(e,t,n,s){n===void 0&&(n=-1e6),s===void 0&&(s=1e6),this.id=at.idCounter++,this.minForce=n,this.maxForce=s,this.bi=e,this.bj=t,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new yn,this.jacobianElementB=new yn,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(e,t,n){const s=t,i=e,o=n;this.a=4/(o*(1+4*s)),this.b=4*s/(1+4*s),this.eps=4/(o*o*i*(1+4*s))}computeB(e,t,n){const s=this.computeGW(),i=this.computeGq(),o=this.computeGiMf();return-i*e-s*t-o*n}computeGq(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,s=this.bj,i=n.position,o=s.position;return e.spatial.dot(i)+t.spatial.dot(o)}computeGW(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,s=this.bj,i=n.velocity,o=s.velocity,r=n.angularVelocity,a=s.angularVelocity;return e.multiplyVectors(i,r)+t.multiplyVectors(o,a)}computeGWlambda(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,s=this.bj,i=n.vlambda,o=s.vlambda,r=n.wlambda,a=s.wlambda;return e.multiplyVectors(i,r)+t.multiplyVectors(o,a)}computeGiMf(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,s=this.bj,i=n.force,o=n.torque,r=s.force,a=s.torque,c=n.invMassSolve,h=s.invMassSolve;return i.scale(c,vn),r.scale(h,wn),n.invInertiaWorldSolve.vmult(o,xn),s.invInertiaWorldSolve.vmult(a,An),e.multiplyVectors(vn,xn)+t.multiplyVectors(wn,An)}computeGiMGt(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,s=this.bj,i=n.invMassSolve,o=s.invMassSolve,r=n.invInertiaWorldSolve,a=s.invInertiaWorldSolve;let c=i+o;return r.vmult(e.rotational,pt),c+=pt.dot(e.rotational),a.vmult(t.rotational,pt),c+=pt.dot(t.rotational),c}addToWlambda(e){const t=this.jacobianElementA,n=this.jacobianElementB,s=this.bi,i=this.bj,o=ji;s.vlambda.addScaledVector(s.invMassSolve*e,t.spatial,s.vlambda),i.vlambda.addScaledVector(i.invMassSolve*e,n.spatial,i.vlambda),s.invInertiaWorldSolve.vmult(t.rotational,o),s.wlambda.addScaledVector(e,o,s.wlambda),i.invInertiaWorldSolve.vmult(n.rotational,o),i.wlambda.addScaledVector(e,o,i.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}at.idCounter=0;const vn=new d,wn=new d,xn=new d,An=new d,pt=new d,ji=new d;class Vi extends at{constructor(e,t,n){n===void 0&&(n=1e6),super(e,t,0,n),this.restitution=0,this.ri=new d,this.rj=new d,this.ni=new d}computeB(e){const t=this.a,n=this.b,s=this.bi,i=this.bj,o=this.ri,r=this.rj,a=Ui,c=Wi,h=s.velocity,l=s.angularVelocity;s.force,s.torque;const u=i.velocity,p=i.angularVelocity;i.force,i.torque;const m=Xi,y=this.jacobianElementA,g=this.jacobianElementB,w=this.ni;o.cross(w,a),r.cross(w,c),w.negate(y.spatial),a.negate(y.rotational),g.spatial.copy(w),g.rotational.copy(c),m.copy(i.position),m.vadd(r,m),m.vsub(s.position,m),m.vsub(o,m);const v=w.dot(m),x=this.restitution+1,A=x*u.dot(w)-x*h.dot(w)+p.dot(c)-l.dot(a),T=this.computeGiMf();return-v*t-A*n-e*T}getImpactVelocityAlongNormal(){const e=Ki,t=Yi,n=$i,s=Zi,i=Qi;return this.bi.position.vadd(this.ri,n),this.bj.position.vadd(this.rj,s),this.bi.getVelocityAtWorldPoint(n,e),this.bj.getVelocityAtWorldPoint(s,t),e.vsub(t,i),this.ni.dot(i)}}const Ui=new d,Wi=new d,Xi=new d,Ki=new d,Yi=new d,$i=new d,Zi=new d,Qi=new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;class Tn extends at{constructor(e,t,n){super(e,t,-n,n),this.ri=new d,this.rj=new d,this.t=new d}computeB(e){this.a;const t=this.b;this.bi,this.bj;const n=this.ri,s=this.rj,i=Ji,o=eo,r=this.t;n.cross(r,i),s.cross(r,o);const a=this.jacobianElementA,c=this.jacobianElementB;r.negate(a.spatial),i.negate(a.rotational),c.spatial.copy(r),c.rotational.copy(o);const h=this.computeGW(),l=this.computeGiMf();return-h*t-e*l}}const Ji=new d,eo=new d;class At{constructor(e,t,n){n=Hi.defaults(n,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=At.idCounter++,this.materials=[e,t],this.friction=n.friction,this.restitution=n.restitution,this.contactEquationStiffness=n.contactEquationStiffness,this.contactEquationRelaxation=n.contactEquationRelaxation,this.frictionEquationStiffness=n.frictionEquationStiffness,this.frictionEquationRelaxation=n.frictionEquationRelaxation}}At.idCounter=0;class ct{constructor(e){e===void 0&&(e={});let t="";typeof e=="string"&&(t=e,e={}),this.name=t,this.id=ct.idCounter++,this.friction=typeof e.friction<"u"?e.friction:-1,this.restitution=typeof e.restitution<"u"?e.restitution:-1}}ct.idCounter=0;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new Y;new d;new d;new d;new d(1,0,0),new d(0,1,0),new d(0,0,1);new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;class to extends F{constructor(e){if(super({type:F.types.SPHERE}),this.radius=e!==void 0?e:1,this.radius<0)throw new Error("The sphere radius cannot be negative.");this.updateBoundingSphereRadius()}calculateLocalInertia(e,t){t===void 0&&(t=new d);const n=2*e*this.radius*this.radius/5;return t.x=n,t.y=n,t.z=n,t}volume(){return 4*Math.PI*Math.pow(this.radius,3)/3}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateWorldAABB(e,t,n,s){const i=this.radius,o=["x","y","z"];for(let r=0;r<o.length;r++){const a=o[r];n[a]=e[a]-i,s[a]=e[a]+i}}}new d;new d;new d;new d;new d;new d;new d;new d;new d;class no extends F{constructor(){super({type:F.types.PLANE}),this.worldNormal=new d,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}computeWorldNormal(e){const t=this.worldNormal;t.set(0,0,1),e.vmult(t,t),this.worldNormalNeedsUpdate=!1}calculateLocalInertia(e,t){return t===void 0&&(t=new d),t}volume(){return Number.MAX_VALUE}calculateWorldAABB(e,t,n,s){Ae.set(0,0,1),t.vmult(Ae,Ae);const i=Number.MAX_VALUE;n.set(-i,-i,-i),s.set(i,i,i),Ae.x===1?s.x=e.x:Ae.x===-1&&(n.x=e.x),Ae.y===1?s.y=e.y:Ae.y===-1&&(n.y=e.y),Ae.z===1?s.z=e.z:Ae.z===-1&&(n.z=e.z)}updateBoundingSphereRadius(){this.boundingSphereRadius=Number.MAX_VALUE}}const Ae=new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new ae;new d;new ae;new d;new d;new d;new d;new d;new d;new d;new ae;new d;new H;new ae;class so{constructor(){this.equations=[]}solve(e,t){return 0}addEquation(e){e.enabled&&!e.bi.isTrigger&&!e.bj.isTrigger&&this.equations.push(e)}removeEquation(e){const t=this.equations,n=t.indexOf(e);n!==-1&&t.splice(n,1)}removeAllEquations(){this.equations.length=0}}class io extends so{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(e,t){let n=0;const s=this.iterations,i=this.tolerance*this.tolerance,o=this.equations,r=o.length,a=t.bodies,c=a.length,h=e;let l,u,p,m,y,g;if(r!==0)for(let A=0;A!==c;A++)a[A].updateSolveMassProperties();const w=ro,v=ao,x=oo;w.length=r,v.length=r,x.length=r;for(let A=0;A!==r;A++){const T=o[A];x[A]=0,v[A]=T.computeB(h),w[A]=1/T.computeC()}if(r!==0){for(let E=0;E!==c;E++){const M=a[E],C=M.vlambda,N=M.wlambda;C.set(0,0,0),N.set(0,0,0)}for(n=0;n!==s;n++){m=0;for(let E=0;E!==r;E++){const M=o[E];l=v[E],u=w[E],g=x[E],y=M.computeGWlambda(),p=u*(l-y-M.eps*g),g+p<M.minForce?p=M.minForce-g:g+p>M.maxForce&&(p=M.maxForce-g),x[E]+=p,m+=p>0?p:-p,M.addToWlambda(p)}if(m*m<i)break}for(let E=0;E!==c;E++){const M=a[E],C=M.velocity,N=M.angularVelocity;M.vlambda.vmul(M.linearFactor,M.vlambda),C.vadd(M.vlambda,C),M.wlambda.vmul(M.angularFactor,M.wlambda),N.vadd(M.wlambda,N)}let A=o.length;const T=1/h;for(;A--;)o[A].multiplier=x[A]*T}return n}}const oo=[],ro=[],ao=[];class co{constructor(){this.objects=[],this.type=Object}release(){const e=arguments.length;for(let t=0;t!==e;t++)this.objects.push(t<0||arguments.length<=t?void 0:arguments[t]);return this}get(){return this.objects.length===0?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(e){const t=this.objects;for(;t.length>e;)t.pop();for(;t.length<e;)t.push(this.constructObject());return this}}class lo extends co{constructor(){super(...arguments),this.type=d}constructObject(){return new d}}const U={sphereSphere:F.types.SPHERE,spherePlane:F.types.SPHERE|F.types.PLANE,boxBox:F.types.BOX|F.types.BOX,sphereBox:F.types.SPHERE|F.types.BOX,planeBox:F.types.PLANE|F.types.BOX,convexConvex:F.types.CONVEXPOLYHEDRON,sphereConvex:F.types.SPHERE|F.types.CONVEXPOLYHEDRON,planeConvex:F.types.PLANE|F.types.CONVEXPOLYHEDRON,boxConvex:F.types.BOX|F.types.CONVEXPOLYHEDRON,sphereHeightfield:F.types.SPHERE|F.types.HEIGHTFIELD,boxHeightfield:F.types.BOX|F.types.HEIGHTFIELD,convexHeightfield:F.types.CONVEXPOLYHEDRON|F.types.HEIGHTFIELD,sphereParticle:F.types.PARTICLE|F.types.SPHERE,planeParticle:F.types.PLANE|F.types.PARTICLE,boxParticle:F.types.BOX|F.types.PARTICLE,convexParticle:F.types.PARTICLE|F.types.CONVEXPOLYHEDRON,cylinderCylinder:F.types.CYLINDER,sphereCylinder:F.types.SPHERE|F.types.CYLINDER,planeCylinder:F.types.PLANE|F.types.CYLINDER,boxCylinder:F.types.BOX|F.types.CYLINDER,convexCylinder:F.types.CONVEXPOLYHEDRON|F.types.CYLINDER,heightfieldCylinder:F.types.HEIGHTFIELD|F.types.CYLINDER,particleCylinder:F.types.PARTICLE|F.types.CYLINDER,sphereTrimesh:F.types.SPHERE|F.types.TRIMESH,planeTrimesh:F.types.PLANE|F.types.TRIMESH};class ho{get[U.sphereSphere](){return this.sphereSphere}get[U.spherePlane](){return this.spherePlane}get[U.boxBox](){return this.boxBox}get[U.sphereBox](){return this.sphereBox}get[U.planeBox](){return this.planeBox}get[U.convexConvex](){return this.convexConvex}get[U.sphereConvex](){return this.sphereConvex}get[U.planeConvex](){return this.planeConvex}get[U.boxConvex](){return this.boxConvex}get[U.sphereHeightfield](){return this.sphereHeightfield}get[U.boxHeightfield](){return this.boxHeightfield}get[U.convexHeightfield](){return this.convexHeightfield}get[U.sphereParticle](){return this.sphereParticle}get[U.planeParticle](){return this.planeParticle}get[U.boxParticle](){return this.boxParticle}get[U.convexParticle](){return this.convexParticle}get[U.cylinderCylinder](){return this.convexConvex}get[U.sphereCylinder](){return this.sphereConvex}get[U.planeCylinder](){return this.planeConvex}get[U.boxCylinder](){return this.boxConvex}get[U.convexCylinder](){return this.convexConvex}get[U.heightfieldCylinder](){return this.heightfieldCylinder}get[U.particleCylinder](){return this.particleCylinder}get[U.sphereTrimesh](){return this.sphereTrimesh}get[U.planeTrimesh](){return this.planeTrimesh}constructor(e){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new lo,this.world=e,this.currentContactMaterial=e.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(e,t,n,s,i,o){let r;this.contactPointPool.length?(r=this.contactPointPool.pop(),r.bi=e,r.bj=t):r=new Vi(e,t),r.enabled=e.collisionResponse&&t.collisionResponse&&n.collisionResponse&&s.collisionResponse;const a=this.currentContactMaterial;r.restitution=a.restitution,r.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);const c=n.material||e.material,h=s.material||t.material;return c&&h&&c.restitution>=0&&h.restitution>=0&&(r.restitution=c.restitution*h.restitution),r.si=i||n,r.sj=o||s,r}createFrictionEquationsFromContact(e,t){const n=e.bi,s=e.bj,i=e.si,o=e.sj,r=this.world,a=this.currentContactMaterial;let c=a.friction;const h=i.material||n.material,l=o.material||s.material;if(h&&l&&h.friction>=0&&l.friction>=0&&(c=h.friction*l.friction),c>0){const u=c*(r.frictionGravity||r.gravity).length();let p=n.invMass+s.invMass;p>0&&(p=1/p);const m=this.frictionEquationPool,y=m.length?m.pop():new Tn(n,s,u*p),g=m.length?m.pop():new Tn(n,s,u*p);return y.bi=g.bi=n,y.bj=g.bj=s,y.minForce=g.minForce=-u*p,y.maxForce=g.maxForce=u*p,y.ri.copy(e.ri),y.rj.copy(e.rj),g.ri.copy(e.ri),g.rj.copy(e.rj),e.ni.tangents(y.t,g.t),y.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),g.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),y.enabled=g.enabled=e.enabled,t.push(y,g),!0}return!1}createFrictionFromAverage(e){let t=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(t,this.frictionResult)||e===1)return;const n=this.frictionResult[this.frictionResult.length-2],s=this.frictionResult[this.frictionResult.length-1];_e.setZero(),Ge.setZero(),qe.setZero();const i=t.bi;t.bj;for(let r=0;r!==e;r++)t=this.result[this.result.length-1-r],t.bi!==i?(_e.vadd(t.ni,_e),Ge.vadd(t.ri,Ge),qe.vadd(t.rj,qe)):(_e.vsub(t.ni,_e),Ge.vadd(t.rj,Ge),qe.vadd(t.ri,qe));const o=1/e;Ge.scale(o,n.ri),qe.scale(o,n.rj),s.ri.copy(n.ri),s.rj.copy(n.rj),_e.normalize(),_e.tangents(n.t,s.t)}getContacts(e,t,n,s,i,o,r){this.contactPointPool=i,this.frictionEquationPool=r,this.result=s,this.frictionResult=o;const a=fo,c=mo,h=uo,l=po;for(let u=0,p=e.length;u!==p;u++){const m=e[u],y=t[u];let g=null;m.material&&y.material&&(g=n.getContactMaterial(m.material,y.material)||null);const w=m.type&_.KINEMATIC&&y.type&_.STATIC||m.type&_.STATIC&&y.type&_.KINEMATIC||m.type&_.KINEMATIC&&y.type&_.KINEMATIC;for(let v=0;v<m.shapes.length;v++){m.quaternion.mult(m.shapeOrientations[v],a),m.quaternion.vmult(m.shapeOffsets[v],h),h.vadd(m.position,h);const x=m.shapes[v];for(let A=0;A<y.shapes.length;A++){y.quaternion.mult(y.shapeOrientations[A],c),y.quaternion.vmult(y.shapeOffsets[A],l),l.vadd(y.position,l);const T=y.shapes[A];if(!(x.collisionFilterMask&T.collisionFilterGroup&&T.collisionFilterMask&x.collisionFilterGroup)||h.distanceTo(l)>x.boundingSphereRadius+T.boundingSphereRadius)continue;let E=null;x.material&&T.material&&(E=n.getContactMaterial(x.material,T.material)||null),this.currentContactMaterial=E||g||n.defaultContactMaterial;const M=x.type|T.type,C=this[M];if(C){let N=!1;x.type<T.type?N=C.call(this,x,T,h,l,a,c,m,y,x,T,w):N=C.call(this,T,x,l,h,c,a,y,m,x,T,w),N&&w&&(n.shapeOverlapKeeper.set(x.id,T.id),n.bodyOverlapKeeper.set(m.id,y.id))}}}}}sphereSphere(e,t,n,s,i,o,r,a,c,h,l){if(l)return n.distanceSquared(s)<(e.radius+t.radius)**2;const u=this.createContactEquation(r,a,e,t,c,h);s.vsub(n,u.ni),u.ni.normalize(),u.ri.copy(u.ni),u.rj.copy(u.ni),u.ri.scale(e.radius,u.ri),u.rj.scale(-t.radius,u.rj),u.ri.vadd(n,u.ri),u.ri.vsub(r.position,u.ri),u.rj.vadd(s,u.rj),u.rj.vsub(a.position,u.rj),this.result.push(u),this.createFrictionEquationsFromContact(u,this.frictionResult)}spherePlane(e,t,n,s,i,o,r,a,c,h,l){const u=this.createContactEquation(r,a,e,t,c,h);if(u.ni.set(0,0,1),o.vmult(u.ni,u.ni),u.ni.negate(u.ni),u.ni.normalize(),u.ni.scale(e.radius,u.ri),n.vsub(s,ft),u.ni.scale(u.ni.dot(ft),En),ft.vsub(En,u.rj),-ft.dot(u.ni)<=e.radius){if(l)return!0;const p=u.ri,m=u.rj;p.vadd(n,p),p.vsub(r.position,p),m.vadd(s,m),m.vsub(a.position,m),this.result.push(u),this.createFrictionEquationsFromContact(u,this.frictionResult)}}boxBox(e,t,n,s,i,o,r,a,c,h,l){return e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t.convexPolyhedronRepresentation,n,s,i,o,r,a,e,t,l)}sphereBox(e,t,n,s,i,o,r,a,c,h,l){const u=this.v3pool,p=qo;n.vsub(s,mt),t.getSideNormals(p,o);const m=e.radius;let y=!1;const g=jo,w=Vo,v=Uo;let x=null,A=0,T=0,E=0,M=null;for(let b=0,j=p.length;b!==j&&y===!1;b++){const O=Oo;O.copy(p[b]);const z=O.length();O.normalize();const te=mt.dot(O);if(te<z+m&&te>0){const J=Do,B=Go;J.copy(p[(b+1)%3]),B.copy(p[(b+2)%3]);const re=J.length(),Pe=B.length();J.normalize(),B.normalize();const xe=mt.dot(J),Fe=mt.dot(B);if(xe<re&&xe>-re&&Fe<Pe&&Fe>-Pe){const Oe=Math.abs(te-z-m);if((M===null||Oe<M)&&(M=Oe,T=xe,E=Fe,x=z,g.copy(O),w.copy(J),v.copy(B),A++,l))return!0}}}if(A){y=!0;const b=this.createContactEquation(r,a,e,t,c,h);g.scale(-m,b.ri),b.ni.copy(g),b.ni.negate(b.ni),g.scale(x,g),w.scale(T,w),g.vadd(w,g),v.scale(E,v),g.vadd(v,b.rj),b.ri.vadd(n,b.ri),b.ri.vsub(r.position,b.ri),b.rj.vadd(s,b.rj),b.rj.vsub(a.position,b.rj),this.result.push(b),this.createFrictionEquationsFromContact(b,this.frictionResult)}let C=u.get();const N=Ho;for(let b=0;b!==2&&!y;b++)for(let j=0;j!==2&&!y;j++)for(let O=0;O!==2&&!y;O++)if(C.set(0,0,0),b?C.vadd(p[0],C):C.vsub(p[0],C),j?C.vadd(p[1],C):C.vsub(p[1],C),O?C.vadd(p[2],C):C.vsub(p[2],C),s.vadd(C,N),N.vsub(n,N),N.lengthSquared()<m*m){if(l)return!0;y=!0;const z=this.createContactEquation(r,a,e,t,c,h);z.ri.copy(N),z.ri.normalize(),z.ni.copy(z.ri),z.ri.scale(m,z.ri),z.rj.copy(C),z.ri.vadd(n,z.ri),z.ri.vsub(r.position,z.ri),z.rj.vadd(s,z.rj),z.rj.vsub(a.position,z.rj),this.result.push(z),this.createFrictionEquationsFromContact(z,this.frictionResult)}u.release(C),C=null;const P=u.get(),L=u.get(),k=u.get(),S=u.get(),I=u.get(),R=p.length;for(let b=0;b!==R&&!y;b++)for(let j=0;j!==R&&!y;j++)if(b%3!==j%3){p[j].cross(p[b],P),P.normalize(),p[b].vadd(p[j],L),k.copy(n),k.vsub(L,k),k.vsub(s,k);const O=k.dot(P);P.scale(O,S);let z=0;for(;z===b%3||z===j%3;)z++;I.copy(n),I.vsub(S,I),I.vsub(L,I),I.vsub(s,I);const te=Math.abs(O),J=I.length();if(te<p[z].length()&&J<m){if(l)return!0;y=!0;const B=this.createContactEquation(r,a,e,t,c,h);L.vadd(S,B.rj),B.rj.copy(B.rj),I.negate(B.ni),B.ni.normalize(),B.ri.copy(B.rj),B.ri.vadd(s,B.ri),B.ri.vsub(n,B.ri),B.ri.normalize(),B.ri.scale(m,B.ri),B.ri.vadd(n,B.ri),B.ri.vsub(r.position,B.ri),B.rj.vadd(s,B.rj),B.rj.vsub(a.position,B.rj),this.result.push(B),this.createFrictionEquationsFromContact(B,this.frictionResult)}}u.release(P,L,k,S,I)}planeBox(e,t,n,s,i,o,r,a,c,h,l){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,t.convexPolyhedronRepresentation.id=t.id,this.planeConvex(e,t.convexPolyhedronRepresentation,n,s,i,o,r,a,e,t,l)}convexConvex(e,t,n,s,i,o,r,a,c,h,l,u,p){const m=rr;if(!(n.distanceTo(s)>e.boundingSphereRadius+t.boundingSphereRadius)&&e.findSeparatingAxis(t,n,i,s,o,m,u,p)){const y=[],g=ar;e.clipAgainstHull(n,i,t,s,o,m,-100,100,y);let w=0;for(let v=0;v!==y.length;v++){if(l)return!0;const x=this.createContactEquation(r,a,e,t,c,h),A=x.ri,T=x.rj;m.negate(x.ni),y[v].normal.negate(g),g.scale(y[v].depth,g),y[v].point.vadd(g,A),T.copy(y[v].point),A.vsub(n,A),T.vsub(s,T),A.vadd(n,A),A.vsub(r.position,A),T.vadd(s,T),T.vsub(a.position,T),this.result.push(x),w++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(x,this.frictionResult)}this.enableFrictionReduction&&w&&this.createFrictionFromAverage(w)}}sphereConvex(e,t,n,s,i,o,r,a,c,h,l){const u=this.v3pool;n.vsub(s,Wo);const p=t.faceNormals,m=t.faces,y=t.vertices,g=e.radius;let w=!1;for(let v=0;v!==y.length;v++){const x=y[v],A=$o;o.vmult(x,A),s.vadd(A,A);const T=Yo;if(A.vsub(n,T),T.lengthSquared()<g*g){if(l)return!0;w=!0;const E=this.createContactEquation(r,a,e,t,c,h);E.ri.copy(T),E.ri.normalize(),E.ni.copy(E.ri),E.ri.scale(g,E.ri),A.vsub(s,E.rj),E.ri.vadd(n,E.ri),E.ri.vsub(r.position,E.ri),E.rj.vadd(s,E.rj),E.rj.vsub(a.position,E.rj),this.result.push(E),this.createFrictionEquationsFromContact(E,this.frictionResult);return}}for(let v=0,x=m.length;v!==x&&w===!1;v++){const A=p[v],T=m[v],E=Zo;o.vmult(A,E);const M=Qo;o.vmult(y[T[0]],M),M.vadd(s,M);const C=Jo;E.scale(-g,C),n.vadd(C,C);const N=er;C.vsub(M,N);const P=N.dot(E),L=tr;if(n.vsub(M,L),P<0&&L.dot(E)>0){const k=[];for(let S=0,I=T.length;S!==I;S++){const R=u.get();o.vmult(y[T[S]],R),s.vadd(R,R),k.push(R)}if(ko(k,E,n)){if(l)return!0;w=!0;const S=this.createContactEquation(r,a,e,t,c,h);E.scale(-g,S.ri),E.negate(S.ni);const I=u.get();E.scale(-P,I);const R=u.get();E.scale(-g,R),n.vsub(s,S.rj),S.rj.vadd(R,S.rj),S.rj.vadd(I,S.rj),S.rj.vadd(s,S.rj),S.rj.vsub(a.position,S.rj),S.ri.vadd(n,S.ri),S.ri.vsub(r.position,S.ri),u.release(I),u.release(R),this.result.push(S),this.createFrictionEquationsFromContact(S,this.frictionResult);for(let b=0,j=k.length;b!==j;b++)u.release(k[b]);return}else for(let S=0;S!==T.length;S++){const I=u.get(),R=u.get();o.vmult(y[T[(S+1)%T.length]],I),o.vmult(y[T[(S+2)%T.length]],R),s.vadd(I,I),s.vadd(R,R);const b=Xo;R.vsub(I,b);const j=Ko;b.unit(j);const O=u.get(),z=u.get();n.vsub(I,z);const te=z.dot(j);j.scale(te,O),O.vadd(I,O);const J=u.get();if(O.vsub(n,J),te>0&&te*te<b.lengthSquared()&&J.lengthSquared()<g*g){if(l)return!0;const B=this.createContactEquation(r,a,e,t,c,h);O.vsub(s,B.rj),O.vsub(n,B.ni),B.ni.normalize(),B.ni.scale(g,B.ri),B.rj.vadd(s,B.rj),B.rj.vsub(a.position,B.rj),B.ri.vadd(n,B.ri),B.ri.vsub(r.position,B.ri),this.result.push(B),this.createFrictionEquationsFromContact(B,this.frictionResult);for(let re=0,Pe=k.length;re!==Pe;re++)u.release(k[re]);u.release(I),u.release(R),u.release(O),u.release(J),u.release(z);return}u.release(I),u.release(R),u.release(O),u.release(J),u.release(z)}for(let S=0,I=k.length;S!==I;S++)u.release(k[S])}}}planeConvex(e,t,n,s,i,o,r,a,c,h,l){const u=nr,p=sr;p.set(0,0,1),i.vmult(p,p);let m=0;const y=ir;for(let g=0;g!==t.vertices.length;g++)if(u.copy(t.vertices[g]),o.vmult(u,u),s.vadd(u,u),u.vsub(n,y),p.dot(y)<=0){if(l)return!0;const v=this.createContactEquation(r,a,e,t,c,h),x=or;p.scale(p.dot(y),x),u.vsub(x,x),x.vsub(n,v.ri),v.ni.copy(p),u.vsub(s,v.rj),v.ri.vadd(n,v.ri),v.ri.vsub(r.position,v.ri),v.rj.vadd(s,v.rj),v.rj.vsub(a.position,v.rj),this.result.push(v),m++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(v,this.frictionResult)}this.enableFrictionReduction&&m&&this.createFrictionFromAverage(m)}boxConvex(e,t,n,s,i,o,r,a,c,h,l){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t,n,s,i,o,r,a,e,t,l)}sphereHeightfield(e,t,n,s,i,o,r,a,c,h,l){const u=t.data,p=e.radius,m=t.elementSize,y=wr,g=vr;H.pointToLocalFrame(s,o,n,g);let w=Math.floor((g.x-p)/m)-1,v=Math.ceil((g.x+p)/m)+1,x=Math.floor((g.y-p)/m)-1,A=Math.ceil((g.y+p)/m)+1;if(v<0||A<0||w>u.length||x>u[0].length)return;w<0&&(w=0),v<0&&(v=0),x<0&&(x=0),A<0&&(A=0),w>=u.length&&(w=u.length-1),v>=u.length&&(v=u.length-1),A>=u[0].length&&(A=u[0].length-1),x>=u[0].length&&(x=u[0].length-1);const T=[];t.getRectMinMax(w,x,v,A,T);const E=T[0],M=T[1];if(g.z-p>M||g.z+p<E)return;const C=this.result;for(let N=w;N<v;N++)for(let P=x;P<A;P++){const L=C.length;let k=!1;if(t.getConvexTrianglePillar(N,P,!1),H.pointToWorldFrame(s,o,t.pillarOffset,y),n.distanceTo(y)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(k=this.sphereConvex(e,t.pillarConvex,n,y,i,o,r,a,e,t,l)),l&&k||(t.getConvexTrianglePillar(N,P,!0),H.pointToWorldFrame(s,o,t.pillarOffset,y),n.distanceTo(y)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(k=this.sphereConvex(e,t.pillarConvex,n,y,i,o,r,a,e,t,l)),l&&k))return!0;if(C.length-L>2)return}}boxHeightfield(e,t,n,s,i,o,r,a,c,h,l){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexHeightfield(e.convexPolyhedronRepresentation,t,n,s,i,o,r,a,e,t,l)}convexHeightfield(e,t,n,s,i,o,r,a,c,h,l){const u=t.data,p=t.elementSize,m=e.boundingSphereRadius,y=gr,g=yr,w=mr;H.pointToLocalFrame(s,o,n,w);let v=Math.floor((w.x-m)/p)-1,x=Math.ceil((w.x+m)/p)+1,A=Math.floor((w.y-m)/p)-1,T=Math.ceil((w.y+m)/p)+1;if(x<0||T<0||v>u.length||A>u[0].length)return;v<0&&(v=0),x<0&&(x=0),A<0&&(A=0),T<0&&(T=0),v>=u.length&&(v=u.length-1),x>=u.length&&(x=u.length-1),T>=u[0].length&&(T=u[0].length-1),A>=u[0].length&&(A=u[0].length-1);const E=[];t.getRectMinMax(v,A,x,T,E);const M=E[0],C=E[1];if(!(w.z-m>C||w.z+m<M))for(let N=v;N<x;N++)for(let P=A;P<T;P++){let L=!1;if(t.getConvexTrianglePillar(N,P,!1),H.pointToWorldFrame(s,o,t.pillarOffset,y),n.distanceTo(y)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(L=this.convexConvex(e,t.pillarConvex,n,y,i,o,r,a,null,null,l,g,null)),l&&L||(t.getConvexTrianglePillar(N,P,!0),H.pointToWorldFrame(s,o,t.pillarOffset,y),n.distanceTo(y)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(L=this.convexConvex(e,t.pillarConvex,n,y,i,o,r,a,null,null,l,g,null)),l&&L))return!0}}sphereParticle(e,t,n,s,i,o,r,a,c,h,l){const u=ur;if(u.set(0,0,1),s.vsub(n,u),u.lengthSquared()<=e.radius*e.radius){if(l)return!0;const m=this.createContactEquation(a,r,t,e,c,h);u.normalize(),m.rj.copy(u),m.rj.scale(e.radius,m.rj),m.ni.copy(u),m.ni.negate(m.ni),m.ri.set(0,0,0),this.result.push(m),this.createFrictionEquationsFromContact(m,this.frictionResult)}}planeParticle(e,t,n,s,i,o,r,a,c,h,l){const u=cr;u.set(0,0,1),r.quaternion.vmult(u,u);const p=lr;if(s.vsub(r.position,p),u.dot(p)<=0){if(l)return!0;const y=this.createContactEquation(a,r,t,e,c,h);y.ni.copy(u),y.ni.negate(y.ni),y.ri.set(0,0,0);const g=hr;u.scale(u.dot(s),g),s.vsub(g,g),y.rj.copy(g),this.result.push(y),this.createFrictionEquationsFromContact(y,this.frictionResult)}}boxParticle(e,t,n,s,i,o,r,a,c,h,l){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexParticle(e.convexPolyhedronRepresentation,t,n,s,i,o,r,a,e,t,l)}convexParticle(e,t,n,s,i,o,r,a,c,h,l){let u=-1;const p=pr,m=fr;let y=null;const g=dr;if(g.copy(s),g.vsub(n,g),i.conjugate(bn),bn.vmult(g,g),e.pointIsInside(g)){e.worldVerticesNeedsUpdate&&e.computeWorldVertices(n,i),e.worldFaceNormalsNeedsUpdate&&e.computeWorldFaceNormals(i);for(let w=0,v=e.faces.length;w!==v;w++){const x=[e.worldVertices[e.faces[w][0]]],A=e.worldFaceNormals[w];s.vsub(x[0],Sn);const T=-A.dot(Sn);if(y===null||Math.abs(T)<Math.abs(y)){if(l)return!0;y=T,u=w,p.copy(A)}}if(u!==-1){const w=this.createContactEquation(a,r,t,e,c,h);p.scale(y,m),m.vadd(s,m),m.vsub(n,m),w.rj.copy(m),p.negate(w.ni),w.ri.set(0,0,0);const v=w.ri,x=w.rj;v.vadd(s,v),v.vsub(a.position,v),x.vadd(n,x),x.vsub(r.position,x),this.result.push(w),this.createFrictionEquationsFromContact(w,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(e,t,n,s,i,o,r,a,c,h,l){return this.convexHeightfield(t,e,s,n,o,i,a,r,c,h,l)}particleCylinder(e,t,n,s,i,o,r,a,c,h,l){return this.convexParticle(t,e,s,n,o,i,a,r,c,h,l)}sphereTrimesh(e,t,n,s,i,o,r,a,c,h,l){const u=Eo,p=bo,m=So,y=Mo,g=Ro,w=Co,v=Fo,x=To,A=xo,T=_o;H.pointToLocalFrame(s,o,n,g);const E=e.radius;v.lowerBound.set(g.x-E,g.y-E,g.z-E),v.upperBound.set(g.x+E,g.y+E,g.z+E),t.getTrianglesInAABB(v,T);const M=Ao,C=e.radius*e.radius;for(let S=0;S<T.length;S++)for(let I=0;I<3;I++)if(t.getVertex(t.indices[T[S]*3+I],M),M.vsub(g,A),A.lengthSquared()<=C){if(x.copy(M),H.pointToWorldFrame(s,o,x,M),M.vsub(n,A),l)return!0;let R=this.createContactEquation(r,a,e,t,c,h);R.ni.copy(A),R.ni.normalize(),R.ri.copy(R.ni),R.ri.scale(e.radius,R.ri),R.ri.vadd(n,R.ri),R.ri.vsub(r.position,R.ri),R.rj.copy(M),R.rj.vsub(a.position,R.rj),this.result.push(R),this.createFrictionEquationsFromContact(R,this.frictionResult)}for(let S=0;S<T.length;S++)for(let I=0;I<3;I++){t.getVertex(t.indices[T[S]*3+I],u),t.getVertex(t.indices[T[S]*3+(I+1)%3],p),p.vsub(u,m),g.vsub(p,w);const R=w.dot(m);g.vsub(u,w);let b=w.dot(m);if(b>0&&R<0&&(g.vsub(u,w),y.copy(m),y.normalize(),b=w.dot(y),y.scale(b,w),w.vadd(u,w),w.distanceTo(g)<e.radius)){if(l)return!0;const O=this.createContactEquation(r,a,e,t,c,h);w.vsub(g,O.ni),O.ni.normalize(),O.ni.scale(e.radius,O.ri),O.ri.vadd(n,O.ri),O.ri.vsub(r.position,O.ri),H.pointToWorldFrame(s,o,w,w),w.vsub(a.position,O.rj),H.vectorToWorldFrame(o,O.ni,O.ni),H.vectorToWorldFrame(o,O.ri,O.ri),this.result.push(O),this.createFrictionEquationsFromContact(O,this.frictionResult)}}const N=Io,P=Lo,L=Po,k=wo;for(let S=0,I=T.length;S!==I;S++){t.getTriangleVertices(T[S],N,P,L),t.getNormal(T[S],k),g.vsub(N,w);let R=w.dot(k);if(k.scale(R,w),g.vsub(w,w),R=w.distanceTo(g),Y.pointInTriangle(w,N,P,L)&&R<e.radius){if(l)return!0;let b=this.createContactEquation(r,a,e,t,c,h);w.vsub(g,b.ni),b.ni.normalize(),b.ni.scale(e.radius,b.ri),b.ri.vadd(n,b.ri),b.ri.vsub(r.position,b.ri),H.pointToWorldFrame(s,o,w,w),w.vsub(a.position,b.rj),H.vectorToWorldFrame(o,b.ni,b.ni),H.vectorToWorldFrame(o,b.ri,b.ri),this.result.push(b),this.createFrictionEquationsFromContact(b,this.frictionResult)}}T.length=0}planeTrimesh(e,t,n,s,i,o,r,a,c,h,l){const u=new d,p=go;p.set(0,0,1),i.vmult(p,p);for(let m=0;m<t.vertices.length/3;m++){t.getVertex(m,u);const y=new d;y.copy(u),H.pointToWorldFrame(s,o,y,u);const g=yo;if(u.vsub(n,g),p.dot(g)<=0){if(l)return!0;const v=this.createContactEquation(r,a,e,t,c,h);v.ni.copy(p);const x=vo;p.scale(g.dot(p),x),u.vsub(x,x),v.ri.copy(x),v.ri.vsub(r.position,v.ri),v.rj.copy(u),v.rj.vsub(a.position,v.rj),this.result.push(v),this.createFrictionEquationsFromContact(v,this.frictionResult)}}}}const _e=new d,Ge=new d,qe=new d,uo=new d,po=new d,fo=new $,mo=new $,go=new d,yo=new d,vo=new d,wo=new d,xo=new d;new d;const Ao=new d,To=new d,Eo=new d,bo=new d,So=new d,Mo=new d,Ro=new d,Co=new d,Io=new d,Lo=new d,Po=new d,Fo=new ae,_o=[],ft=new d,En=new d,No=new d,Bo=new d,zo=new d;function ko(f,e,t){let n=null;const s=f.length;for(let i=0;i!==s;i++){const o=f[i],r=No;f[(i+1)%s].vsub(o,r);const a=Bo;r.cross(e,a);const c=zo;t.vsub(o,c);const h=a.dot(c);if(n===null||h>0&&n===!0||h<=0&&n===!1){n===null&&(n=h>0);continue}else return!1}return!0}const mt=new d,Oo=new d,Do=new d,Go=new d,qo=[new d,new d,new d,new d,new d,new d],Ho=new d,jo=new d,Vo=new d,Uo=new d,Wo=new d,Xo=new d,Ko=new d,Yo=new d,$o=new d,Zo=new d,Qo=new d,Jo=new d,er=new d,tr=new d;new d;new d;const nr=new d,sr=new d,ir=new d,or=new d,rr=new d,ar=new d,cr=new d,lr=new d,hr=new d,ur=new d,bn=new $,dr=new d;new d;const pr=new d,Sn=new d,fr=new d,mr=new d,gr=new d,yr=[0],vr=new d,wr=new d;class Mn{constructor(){this.current=[],this.previous=[]}getKey(e,t){if(t<e){const n=t;t=e,e=n}return e<<16|t}set(e,t){const n=this.getKey(e,t),s=this.current;let i=0;for(;n>s[i];)i++;if(n!==s[i]){for(let o=s.length-1;o>=i;o--)s[o+1]=s[o];s[i]=n}}tick(){const e=this.current;this.current=this.previous,this.previous=e,this.current.length=0}getDiff(e,t){const n=this.current,s=this.previous,i=n.length,o=s.length;let r=0;for(let a=0;a<i;a++){let c=!1;const h=n[a];for(;h>s[r];)r++;c=h===s[r],c||Rn(e,h)}r=0;for(let a=0;a<o;a++){let c=!1;const h=s[a];for(;h>n[r];)r++;c=n[r]===h,c||Rn(t,h)}}}function Rn(f,e){f.push((e&4294901760)>>16,e&65535)}const It=(f,e)=>f<e?`${f}-${e}`:`${e}-${f}`;class xr{constructor(){this.data={keys:[]}}get(e,t){const n=It(e,t);return this.data[n]}set(e,t,n){const s=It(e,t);this.get(e,t)||this.data.keys.push(s),this.data[s]=n}delete(e,t){const n=It(e,t),s=this.data.keys.indexOf(n);s!==-1&&this.data.keys.splice(s,1),delete this.data[n]}reset(){const e=this.data,t=e.keys;for(;t.length>0;){const n=t.pop();delete e[n]}}}class Ar extends $n{constructor(e){e===void 0&&(e={}),super(),this.dt=-1,this.allowSleep=!!e.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=e.quatNormalizeSkip!==void 0?e.quatNormalizeSkip:0,this.quatNormalizeFast=e.quatNormalizeFast!==void 0?e.quatNormalizeFast:!1,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new d,e.gravity&&this.gravity.copy(e.gravity),e.frictionGravity&&(this.frictionGravity=new d,this.frictionGravity.copy(e.frictionGravity)),this.broadphase=e.broadphase!==void 0?e.broadphase:new Qn,this.bodies=[],this.hasActiveBodies=!1,this.solver=e.solver!==void 0?e.solver:new io,this.constraints=[],this.narrowphase=new ho(this),this.collisionMatrix=new dn,this.collisionMatrixPrevious=new dn,this.bodyOverlapKeeper=new Mn,this.shapeOverlapKeeper=new Mn,this.contactmaterials=[],this.contactMaterialTable=new xr,this.defaultMaterial=new ct("default"),this.defaultContactMaterial=new At(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(e,t){return this.contactMaterialTable.get(e.id,t.id)}collisionMatrixTick(){const e=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=e,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(e){this.constraints.push(e)}removeConstraint(e){const t=this.constraints.indexOf(e);t!==-1&&this.constraints.splice(t,1)}rayTest(e,t,n){n instanceof xt?this.raycastClosest(e,t,{skipBackfaces:!0},n):this.raycastAll(e,t,{skipBackfaces:!0},n)}raycastAll(e,t,n,s){return n===void 0&&(n={}),n.mode=Y.ALL,n.from=e,n.to=t,n.callback=s,Lt.intersectWorld(this,n)}raycastAny(e,t,n,s){return n===void 0&&(n={}),n.mode=Y.ANY,n.from=e,n.to=t,n.result=s,Lt.intersectWorld(this,n)}raycastClosest(e,t,n,s){return n===void 0&&(n={}),n.mode=Y.CLOSEST,n.from=e,n.to=t,n.result=s,Lt.intersectWorld(this,n)}addBody(e){this.bodies.includes(e)||(e.index=this.bodies.length,this.bodies.push(e),e.world=this,e.initPosition.copy(e.position),e.initVelocity.copy(e.velocity),e.timeLastSleepy=this.time,e instanceof _&&(e.initAngularVelocity.copy(e.angularVelocity),e.initQuaternion.copy(e.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=e,this.idToBodyMap[e.id]=e,this.dispatchEvent(this.addBodyEvent))}removeBody(e){e.world=null;const t=this.bodies.length-1,n=this.bodies,s=n.indexOf(e);if(s!==-1){n.splice(s,1);for(let i=0;i!==n.length;i++)n[i].index=i;this.collisionMatrix.setNumObjects(t),this.removeBodyEvent.body=e,delete this.idToBodyMap[e.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(e){return this.idToBodyMap[e]}getShapeById(e){const t=this.bodies;for(let n=0;n<t.length;n++){const s=t[n].shapes;for(let i=0;i<s.length;i++){const o=s[i];if(o.id===e)return o}}return null}addContactMaterial(e){this.contactmaterials.push(e),this.contactMaterialTable.set(e.materials[0].id,e.materials[1].id,e)}removeContactMaterial(e){const t=this.contactmaterials.indexOf(e);t!==-1&&(this.contactmaterials.splice(t,1),this.contactMaterialTable.delete(e.materials[0].id,e.materials[1].id))}fixedStep(e,t){e===void 0&&(e=1/60),t===void 0&&(t=10);const n=Q.now()/1e3;if(!this.lastCallTime)this.step(e,void 0,t);else{const s=n-this.lastCallTime;this.step(e,s,t)}this.lastCallTime=n}step(e,t,n){if(n===void 0&&(n=10),t===void 0)this.internalStep(e),this.time+=e;else{this.accumulator+=t;const s=Q.now();let i=0;for(;this.accumulator>=e&&i<n&&(this.internalStep(e),this.accumulator-=e,i++,!(Q.now()-s>e*1e3)););this.accumulator=this.accumulator%e;const o=this.accumulator/e;for(let r=0;r!==this.bodies.length;r++){const a=this.bodies[r];a.previousPosition.lerp(a.position,o,a.interpolatedPosition),a.previousQuaternion.slerp(a.quaternion,o,a.interpolatedQuaternion),a.previousQuaternion.normalize()}this.time+=t}}internalStep(e){this.dt=e;const t=this.contacts,n=Mr,s=Rr,i=this.bodies.length,o=this.bodies,r=this.solver,a=this.gravity,c=this.doProfiling,h=this.profile,l=_.DYNAMIC;let u=-1/0;const p=this.constraints,m=Sr;a.length();const y=a.x,g=a.y,w=a.z;let v=0;for(c&&(u=Q.now()),v=0;v!==i;v++){const S=o[v];if(S.type===l){const I=S.force,R=S.mass;I.x+=R*y,I.y+=R*g,I.z+=R*w}}for(let S=0,I=this.subsystems.length;S!==I;S++)this.subsystems[S].update();c&&(u=Q.now()),n.length=0,s.length=0,this.broadphase.collisionPairs(this,n,s),c&&(h.broadphase=Q.now()-u);let x=p.length;for(v=0;v!==x;v++){const S=p[v];if(!S.collideConnected)for(let I=n.length-1;I>=0;I-=1)(S.bodyA===n[I]&&S.bodyB===s[I]||S.bodyB===n[I]&&S.bodyA===s[I])&&(n.splice(I,1),s.splice(I,1))}this.collisionMatrixTick(),c&&(u=Q.now());const A=br,T=t.length;for(v=0;v!==T;v++)A.push(t[v]);t.length=0;const E=this.frictionEquations.length;for(v=0;v!==E;v++)m.push(this.frictionEquations[v]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(n,s,this,t,A,this.frictionEquations,m),c&&(h.narrowphase=Q.now()-u),c&&(u=Q.now()),v=0;v<this.frictionEquations.length;v++)r.addEquation(this.frictionEquations[v]);const M=t.length;for(let S=0;S!==M;S++){const I=t[S],R=I.bi,b=I.bj,j=I.si,O=I.sj;let z;if(R.material&&b.material?z=this.getContactMaterial(R.material,b.material)||this.defaultContactMaterial:z=this.defaultContactMaterial,z.friction,R.material&&b.material&&(R.material.friction>=0&&b.material.friction>=0&&R.material.friction*b.material.friction,R.material.restitution>=0&&b.material.restitution>=0&&(I.restitution=R.material.restitution*b.material.restitution)),r.addEquation(I),R.allowSleep&&R.type===_.DYNAMIC&&R.sleepState===_.SLEEPING&&b.sleepState===_.AWAKE&&b.type!==_.STATIC){const te=b.velocity.lengthSquared()+b.angularVelocity.lengthSquared(),J=b.sleepSpeedLimit**2;te>=J*2&&(R.wakeUpAfterNarrowphase=!0)}if(b.allowSleep&&b.type===_.DYNAMIC&&b.sleepState===_.SLEEPING&&R.sleepState===_.AWAKE&&R.type!==_.STATIC){const te=R.velocity.lengthSquared()+R.angularVelocity.lengthSquared(),J=R.sleepSpeedLimit**2;te>=J*2&&(b.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(R,b,!0),this.collisionMatrixPrevious.get(R,b)||(Ke.body=b,Ke.contact=I,R.dispatchEvent(Ke),Ke.body=R,b.dispatchEvent(Ke)),this.bodyOverlapKeeper.set(R.id,b.id),this.shapeOverlapKeeper.set(j.id,O.id)}for(this.emitContactEvents(),c&&(h.makeContactConstraints=Q.now()-u,u=Q.now()),v=0;v!==i;v++){const S=o[v];S.wakeUpAfterNarrowphase&&(S.wakeUp(),S.wakeUpAfterNarrowphase=!1)}for(x=p.length,v=0;v!==x;v++){const S=p[v];S.update();for(let I=0,R=S.equations.length;I!==R;I++){const b=S.equations[I];r.addEquation(b)}}r.solve(e,this),c&&(h.solve=Q.now()-u),r.removeAllEquations();const C=Math.pow;for(v=0;v!==i;v++){const S=o[v];if(S.type&l){const I=C(1-S.linearDamping,e),R=S.velocity;R.scale(I,R);const b=S.angularVelocity;if(b){const j=C(1-S.angularDamping,e);b.scale(j,b)}}}this.dispatchEvent(Er),c&&(u=Q.now());const P=this.stepnumber%(this.quatNormalizeSkip+1)===0,L=this.quatNormalizeFast;for(v=0;v!==i;v++)o[v].integrate(e,P,L);this.clearForces(),this.broadphase.dirty=!0,c&&(h.integrate=Q.now()-u),this.stepnumber+=1,this.dispatchEvent(Tr);let k=!0;if(this.allowSleep)for(k=!1,v=0;v!==i;v++){const S=o[v];S.sleepTick(this.time),S.sleepState!==_.SLEEPING&&(k=!0)}this.hasActiveBodies=k}emitContactEvents(){const e=this.hasAnyEventListener("beginContact"),t=this.hasAnyEventListener("endContact");if((e||t)&&this.bodyOverlapKeeper.getDiff(Te,Ee),e){for(let i=0,o=Te.length;i<o;i+=2)Ye.bodyA=this.getBodyById(Te[i]),Ye.bodyB=this.getBodyById(Te[i+1]),this.dispatchEvent(Ye);Ye.bodyA=Ye.bodyB=null}if(t){for(let i=0,o=Ee.length;i<o;i+=2)$e.bodyA=this.getBodyById(Ee[i]),$e.bodyB=this.getBodyById(Ee[i+1]),this.dispatchEvent($e);$e.bodyA=$e.bodyB=null}Te.length=Ee.length=0;const n=this.hasAnyEventListener("beginShapeContact"),s=this.hasAnyEventListener("endShapeContact");if((n||s)&&this.shapeOverlapKeeper.getDiff(Te,Ee),n){for(let i=0,o=Te.length;i<o;i+=2){const r=this.getShapeById(Te[i]),a=this.getShapeById(Te[i+1]);be.shapeA=r,be.shapeB=a,r&&(be.bodyA=r.body),a&&(be.bodyB=a.body),this.dispatchEvent(be)}be.bodyA=be.bodyB=be.shapeA=be.shapeB=null}if(s){for(let i=0,o=Ee.length;i<o;i+=2){const r=this.getShapeById(Ee[i]),a=this.getShapeById(Ee[i+1]);Se.shapeA=r,Se.shapeB=a,r&&(Se.bodyA=r.body),a&&(Se.bodyB=a.body),this.dispatchEvent(Se)}Se.bodyA=Se.bodyB=Se.shapeA=Se.shapeB=null}}clearForces(){const e=this.bodies,t=e.length;for(let n=0;n!==t;n++){const s=e[n];s.force,s.torque,s.force.set(0,0,0),s.torque.set(0,0,0)}}}new ae;const Lt=new Y,Q=globalThis.performance||{};if(!Q.now){let f=Date.now();Q.timing&&Q.timing.navigationStart&&(f=Q.timing.navigationStart),Q.now=()=>Date.now()-f}new d;const Tr={type:"postStep"},Er={type:"preStep"},Ke={type:_.COLLIDE_EVENT_NAME,body:null,contact:null},br=[],Sr=[],Mr=[],Rr=[],Te=[],Ee=[],Ye={type:"beginContact",bodyA:null,bodyB:null},$e={type:"endContact",bodyA:null,bodyB:null},be={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},Se={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};class Cr{constructor(e){G(this,"scene");G(this,"world");G(this,"bodies");G(this,"meshes");this.scene=e,this.world=new Ar,this.bodies=new Map,this.meshes=new Map,this.world.gravity.set(0,-9.82,0),this.world.broadphase=new Qn,this.world.solver.iterations=20}addBody(...e){e.forEach(t=>{this.scene.add(t.mesh),this.world.addBody(t.body),this.bodies.set(t.mesh.uuid,t.body),this.meshes.set(t.body.id,t.mesh)})}update(e){this.world.step(e),this.bodies.forEach(t=>{const n=this.meshes.get(t.id);n&&(n.position.copy(t.position),n.quaternion.copy(t.quaternion))})}}class Ir{constructor({size:e=4,position:t={x:0,y:20,z:0},rotation:n={pitch:0,yaw:0,roll:0}}={}){G(this,"mesh");G(this,"body");const s=new V.BoxGeometry(e,e,e),i=new V.MeshStandardMaterial({color:65280});this.mesh=new V.Mesh(s,i);const o=new Qt(new d(e/2,e/2,e/2));this.body=new _({mass:1,shape:o,material:new ct({friction:.3,restitution:.7})}),this.body.position.set(t.x,t.y,t.z),this.body.quaternion.setFromEuler((n==null?void 0:n.pitch)||0,(n==null?void 0:n.yaw)||0,(n==null?void 0:n.roll)||0,"XYZ"),this.mesh.position.copy(this.body.position),this.mesh.quaternion.copy(this.body.quaternion)}}class Lr{constructor(){G(this,"mesh");G(this,"body");const e=new V.PlaneGeometry(1e3,1e3),t=new V.MeshStandardMaterial({color:8947848});this.mesh=new V.Mesh(e,t),this.mesh.rotation.x=-Math.PI/2,this.mesh.receiveShadow=!0;const n=new no;this.body=new _({mass:0}),this.body.addShape(n),this.body.quaternion.setFromAxisAngle(new d(1,0,0),-Math.PI/2)}}class Tt extends Yt{constructor(){const e=Tt.SkyShader,t=new Ts({name:e.name,uniforms:bs.clone(e.uniforms),vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,side:Es,depthWrite:!1});super(new Ss(1,1,1),t),this.isSky=!0}}Tt.SkyShader={name:"SkyShader",uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new Z},up:{value:new Z(0,1,0)}},vertexShader:`
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calculation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorption + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`,fragmentShader:`
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`};class nn{constructor(e,t){G(this,"mesh");G(this,"body");this.mesh=e,this.body=t}static create({model:e,position:t={x:0,y:0,z:0},rotation:n={pitch:0,yaw:0,roll:0}}){const s=e.children[0],i=new V.Box3().setFromObject(e),o=new V.Vector3;i.getSize(o);const r=new Qt(new d(o.x/2,o.y/2,o.z/2)),a=new _({mass:0,shape:r,position:new d(t.x,t.y+o.y/2,t.z)});return a.quaternion.setFromEuler(n.pitch,n.yaw,n.roll,"XYZ"),s.position.copy(a.position),s.quaternion.copy(a.quaternion),new nn(s,a)}}class Pr{constructor(){G(this,"scene");G(this,"camera");G(this,"renderer");G(this,"physicsWorld");G(this,"clock");this.scene=new V.Scene,this.camera=new V.PerspectiveCamera(60,window.innerWidth/window.innerHeight,.1,1e3),this.renderer=new V.WebGLRenderer({antialias:!0}),this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=V.PCFSoftShadowMap,this.physicsWorld=new Cr(this.scene),this.clock=new V.Clock,this.init()}init(){this.renderer.setSize(window.innerWidth,window.innerHeight),this.renderer.setPixelRatio(window.devicePixelRatio),this.physicsWorld.addBody(...ot.assets.map(({model:a,options:c})=>nn.create({model:a,...c})),...Array.from({length:10}).map((a,c)=>new Ir({size:.2+2*Math.random(),position:{x:0+5*Math.random(),y:100+c*10,z:0},rotation:{pitch:Math.PI*Math.random(),yaw:0,roll:0}})),new Lr);const e=new V.HemisphereLight(16777147,526368,.6),t=new V.DirectionalLight(16777215,1.2),n=new Tt;n.scale.setScalar(1e3),this.scene.add(n);const s=n.material.uniforms;s.turbidity.value=5,s.rayleigh.value=1.5,s.mieCoefficient.value=.005,s.mieDirectionalG.value=.8;const i=new V.Vector3,o=V.MathUtils.degToRad(90),r=V.MathUtils.degToRad(180);i.setFromSphericalCoords(1,o,r),t.position.copy(i),s.sunPosition.value.copy(i),this.scene.add(e,t)}update(){const e=this.clock.getDelta();this.physicsWorld.update(e)}render(){this.renderer.render(this.scene,this.camera)}onWindowResize(){const e=window.innerWidth,t=window.innerHeight;this.camera.aspect=e/t,this.camera.updateProjectionMatrix(),this.renderer.setSize(e,t)}}class Fr{constructor({position:e}){G(this,"mesh");G(this,"body");this.mesh=new V.Mesh(new V.SphereGeometry(2),new V.MeshStandardMaterial),this.body=new _({mass:0,shape:new to(2),position:new d(e.x,e.y,e.z)}),this.mesh.visible=!1,this.mesh.position.copy(this.body.position),this.mesh.quaternion.copy(this.body.quaternion)}}class _r{constructor(e,t){G(this,"sceneManager");G(this,"camera");G(this,"moveSpeed");G(this,"lookSpeed");G(this,"pitch");G(this,"yaw");G(this,"locked",!1);G(this,"keys",{});G(this,"cameraBody",null);this.sceneManager=t,this.camera=e,this.moveSpeed=.1,this.lookSpeed=.002,this.camera.position.set(25,1.7,-25),this.camera.lookAt(0,0,0);const n=new V.Euler().setFromQuaternion(this.camera.quaternion,"YXZ");this.pitch=n.x,this.yaw=n.y,this.setupEventListeners(),this.initCameraBody()}initCameraBody(){this.cameraBody=new Fr({position:this.camera.position}),this.sceneManager.physicsWorld.addBody(this.cameraBody)}update(){const e=new V.Vector3(0,0,-1);e.applyQuaternion(this.camera.quaternion),e.y=0,e.normalize();const t=new V.Vector3(1,0,0);t.applyQuaternion(this.camera.quaternion),t.y=0,t.normalize(),this.keys.w&&this.camera.position.add(e.multiplyScalar(this.moveSpeed)),this.keys.s&&this.camera.position.add(e.multiplyScalar(-this.moveSpeed)),this.keys.a&&this.camera.position.add(t.multiplyScalar(-this.moveSpeed)),this.keys.d&&this.camera.position.add(t.multiplyScalar(this.moveSpeed)),this.cameraBody&&this.cameraBody.body.position.copy(new d(this.camera.position.x,this.camera.position.y,this.camera.position.z))}onWindowResize(){this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix()}onMouseMove(e){this.locked&&(this.yaw-=e.movementX*this.lookSpeed,this.pitch-=e.movementY*this.lookSpeed,this.pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.pitch)),this.camera.quaternion.setFromEuler(new V.Euler(this.pitch,this.yaw,0,"YXZ")),this.cameraBody&&this.cameraBody.body.position.copy(new d(this.camera.position.x,this.camera.position.y,this.camera.position.z)))}setKeyState(e,t){this.keys[e]=t}setupEventListeners(){document.addEventListener("keydown",e=>{this.locked&&this.setKeyState(e.key,!0)}),document.addEventListener("keyup",e=>{this.locked&&this.setKeyState(e.key,!1)}),document.addEventListener("pointerlockchange",()=>{this.locked=!!document.pointerLockElement;const e=document.querySelector(".tip");e&&(e.style.display=this.locked?"none":"block")}),document.addEventListener("mousemove",this.onMouseMove.bind(this)),document.addEventListener("click",()=>{document.pointerLockElement||this.sceneManager.renderer.domElement.requestPointerLock()})}}class Nr{constructor(){G(this,"startTime");G(this,"frames");G(this,"dom");this.startTime=Date.now(),this.frames=0,this.dom=document.createElement("div"),this.dom.classList.add("stats")}update(){this.frames++;const e=Date.now()-this.startTime;if(e>=1e3){const t=this.frames/e*1e3;this.dom.textContent=`FPS: ${t.toFixed(2)}`,this.startTime=Date.now(),this.frames=0}}}class Br{constructor(e){G(this,"sceneManager");this.sceneManager=e;const t=document.createElement("canvas");t.width=100,t.height=128;const n=t.getContext("2d");if(!n)return;n.fillStyle="rgba(0, 0, 0, 0)",n.fillRect(0,0,t.width,t.height),n.fillStyle="white",n.font="20px Arial",n.fillText("",10,50);const s=new V.CanvasTexture(t),i=new V.SpriteMaterial({map:s}),o=new V.Sprite(i);o.scale.set(1,1,1),o.position.set(15,3,-.1),this.sceneManager.scene.add(o)}update(){}}const ke=class ke{constructor(){G(this,"sceneManager");G(this,"camera");G(this,"stats");G(this,"uiLayout");this.sceneManager=new Pr,this.camera=new _r(this.sceneManager.camera,this.sceneManager),this.uiLayout=new Br(this.sceneManager),this.stats=new Nr,this.init(),this.animate()}static initialize(){ke.instance||(ke.instance=new ke)}init(){document.body.appendChild(this.sceneManager.renderer.domElement),document.body.appendChild(this.stats.dom),window.addEventListener("resize",this.onWindowResize.bind(this))}animate(){requestAnimationFrame(this.animate.bind(this)),this.sceneManager.update(),this.camera.update(),this.sceneManager.render(),this.uiLayout.update(),this.stats.update()}onWindowResize(){this.sceneManager.onWindowResize(),this.camera.onWindowResize()}};G(ke,"assets",[]),G(ke,"instance");let ot=ke;const zr="./models/",rs=f=>`${zr}${f}`,kr=async f=>{let e=0;const t=document.querySelector(".loading-screen"),n=document.querySelector(".status-text"),s=document.querySelector(".progress-fill");try{const i=f.map(r=>r.loader(rs(r.path),{name:r.name,onProgress:a=>{if(n.textContent=` ${r.name} (${a.toFixed(1)}%)`,a===100){e++;const c=e/f.length*100;s.style.width=`${c}%`}},sourcePath:r.sourcePath})),o=await Promise.allSettled(i);return t.style.display="none",o.map((r,a)=>({...r,options:f[a].options})).filter(r=>r.status==="fulfilled").map(r=>({model:r.value,options:r.options??{}}))}catch(i){return console.error(i),n.textContent="",n.classList.add("error-text"),s.style.background="#ff4444",[]}};function Cn(f,e){if(e===Ms)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),f;if(e===Ot||e===Bn){let t=f.getIndex();if(t===null){const o=[],r=f.getAttribute("position");if(r!==void 0){for(let a=0;a<r.count;a++)o.push(a);f.setIndex(o),t=f.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),f}const n=t.count-2,s=[];if(e===Ot)for(let o=1;o<=n;o++)s.push(t.getX(0)),s.push(t.getX(o)),s.push(t.getX(o+1));else for(let o=0;o<n;o++)o%2===0?(s.push(t.getX(o)),s.push(t.getX(o+1)),s.push(t.getX(o+2))):(s.push(t.getX(o+2)),s.push(t.getX(o+1)),s.push(t.getX(o)));s.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=f.clone();return i.setIndex(s),i.clearGroups(),i}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),f}class Or extends vt{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new jr(t)}),this.register(function(t){return new Vr(t)}),this.register(function(t){return new Jr(t)}),this.register(function(t){return new ea(t)}),this.register(function(t){return new ta(t)}),this.register(function(t){return new Wr(t)}),this.register(function(t){return new Xr(t)}),this.register(function(t){return new Kr(t)}),this.register(function(t){return new Yr(t)}),this.register(function(t){return new Hr(t)}),this.register(function(t){return new $r(t)}),this.register(function(t){return new Ur(t)}),this.register(function(t){return new Qr(t)}),this.register(function(t){return new Zr(t)}),this.register(function(t){return new Gr(t)}),this.register(function(t){return new na(t)}),this.register(function(t){return new sa(t)})}load(e,t,n,s){const i=this;let o;if(this.resourcePath!=="")o=this.resourcePath;else if(this.path!==""){const c=Ue.extractUrlBase(e);o=Ue.resolveURL(c,this.path)}else o=Ue.extractUrlBase(e);this.manager.itemStart(e);const r=function(c){s?s(c):console.error(c),i.manager.itemError(e),i.manager.itemEnd(e)},a=new $t(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(c){try{i.parse(c,o,function(h){t(h),i.manager.itemEnd(e)},r)}catch(h){r(h)}},n,r)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,s){let i;const o={},r={},a=new TextDecoder;if(typeof e=="string")i=JSON.parse(e);else if(e instanceof ArrayBuffer)if(a.decode(new Uint8Array(e,0,4))===as){try{o[q.KHR_BINARY_GLTF]=new ia(e)}catch(l){s&&s(l);return}i=JSON.parse(o[q.KHR_BINARY_GLTF].content)}else i=JSON.parse(a.decode(e));else i=e;if(i.asset===void 0||i.asset.version[0]<2){s&&s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new ya(i,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const l=this.pluginCallbacks[h](c);l.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),r[l.name]=l,o[l.name]=!0}if(i.extensionsUsed)for(let h=0;h<i.extensionsUsed.length;++h){const l=i.extensionsUsed[h],u=i.extensionsRequired||[];switch(l){case q.KHR_MATERIALS_UNLIT:o[l]=new qr;break;case q.KHR_DRACO_MESH_COMPRESSION:o[l]=new oa(i,this.dracoLoader);break;case q.KHR_TEXTURE_TRANSFORM:o[l]=new ra;break;case q.KHR_MESH_QUANTIZATION:o[l]=new aa;break;default:u.indexOf(l)>=0&&r[l]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+l+'".')}}c.setExtensions(o),c.setPlugins(r),c.parse(n,s)}parseAsync(e,t){const n=this;return new Promise(function(s,i){n.parse(e,t,s,i)})}}function Dr(){let f={};return{get:function(e){return f[e]},add:function(e,t){f[e]=t},remove:function(e){delete f[e]},removeAll:function(){f={}}}}const q={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Gr{constructor(e){this.parser=e,this.name=q.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,s=t.length;n<s;n++){const i=t[n];i.extensions&&i.extensions[this.name]&&i.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let s=t.cache.get(n);if(s)return s;const i=t.json,a=((i.extensions&&i.extensions[this.name]||{}).lights||[])[e];let c;const h=new se(16777215);a.color!==void 0&&h.setRGB(a.color[0],a.color[1],a.color[2],Re);const l=a.range!==void 0?a.range:0;switch(a.type){case"directional":c=new kn(h),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new Dt(h),c.distance=l;break;case"spot":c=new zn(h),c.distance=l,a.spot=a.spot||{},a.spot.innerConeAngle=a.spot.innerConeAngle!==void 0?a.spot.innerConeAngle:0,a.spot.outerConeAngle=a.spot.outerConeAngle!==void 0?a.spot.outerConeAngle:Math.PI/4,c.angle=a.spot.outerConeAngle,c.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return c.position.set(0,0,0),Me(c,a),a.intensity!==void 0&&(c.intensity=a.intensity),c.name=t.createUniqueName(a.name||"light_"+e),s=Promise.resolve(c),t.cache.add(n,s),s}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,n=this.parser,i=n.json.nodes[e],r=(i.extensions&&i.extensions[this.name]||{}).light;return r===void 0?null:this._loadLight(r).then(function(a){return n._getNodeRef(t.cache,r,a)})}}class qr{constructor(){this.name=q.KHR_MATERIALS_UNLIT}getMaterialType(){return Qe}extendParams(e,t,n){const s=[];e.color=new se(1,1,1),e.opacity=1;const i=t.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const o=i.baseColorFactor;e.color.setRGB(o[0],o[1],o[2],Re),e.opacity=o[3]}i.baseColorTexture!==void 0&&s.push(n.assignTexture(e,"map",i.baseColorTexture,ee))}return Promise.all(s)}}class Hr{constructor(e){this.parser=e,this.name=q.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=s.extensions[this.name].emissiveStrength;return i!==void 0&&(t.emissiveIntensity=i),Promise.resolve()}}class jr{constructor(e){this.parser=e,this.name=q.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:we}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],o=s.extensions[this.name];if(o.clearcoatFactor!==void 0&&(t.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&i.push(n.assignTexture(t,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&i.push(n.assignTexture(t,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(i.push(n.assignTexture(t,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const r=o.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Zt(r,r)}return Promise.all(i)}}class Vr{constructor(e){this.parser=e,this.name=q.KHR_MATERIALS_DISPERSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:we}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=s.extensions[this.name];return t.dispersion=i.dispersion!==void 0?i.dispersion:0,Promise.resolve()}}class Ur{constructor(e){this.parser=e,this.name=q.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:we}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],o=s.extensions[this.name];return o.iridescenceFactor!==void 0&&(t.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&i.push(n.assignTexture(t,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(t.iridescenceIOR=o.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&i.push(n.assignTexture(t,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(i)}}class Wr{constructor(e){this.parser=e,this.name=q.KHR_MATERIALS_SHEEN}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:we}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[];t.sheenColor=new se(0,0,0),t.sheenRoughness=0,t.sheen=1;const o=s.extensions[this.name];if(o.sheenColorFactor!==void 0){const r=o.sheenColorFactor;t.sheenColor.setRGB(r[0],r[1],r[2],Re)}return o.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&i.push(n.assignTexture(t,"sheenColorMap",o.sheenColorTexture,ee)),o.sheenRoughnessTexture!==void 0&&i.push(n.assignTexture(t,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(i)}}class Xr{constructor(e){this.parser=e,this.name=q.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:we}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],o=s.extensions[this.name];return o.transmissionFactor!==void 0&&(t.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&i.push(n.assignTexture(t,"transmissionMap",o.transmissionTexture)),Promise.all(i)}}class Kr{constructor(e){this.parser=e,this.name=q.KHR_MATERIALS_VOLUME}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:we}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],o=s.extensions[this.name];t.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&i.push(n.assignTexture(t,"thicknessMap",o.thicknessTexture)),t.attenuationDistance=o.attenuationDistance||1/0;const r=o.attenuationColor||[1,1,1];return t.attenuationColor=new se().setRGB(r[0],r[1],r[2],Re),Promise.all(i)}}class Yr{constructor(e){this.parser=e,this.name=q.KHR_MATERIALS_IOR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:we}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=s.extensions[this.name];return t.ior=i.ior!==void 0?i.ior:1.5,Promise.resolve()}}class $r{constructor(e){this.parser=e,this.name=q.KHR_MATERIALS_SPECULAR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:we}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],o=s.extensions[this.name];t.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&i.push(n.assignTexture(t,"specularIntensityMap",o.specularTexture));const r=o.specularColorFactor||[1,1,1];return t.specularColor=new se().setRGB(r[0],r[1],r[2],Re),o.specularColorTexture!==void 0&&i.push(n.assignTexture(t,"specularColorMap",o.specularColorTexture,ee)),Promise.all(i)}}class Zr{constructor(e){this.parser=e,this.name=q.EXT_MATERIALS_BUMP}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:we}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],o=s.extensions[this.name];return t.bumpScale=o.bumpFactor!==void 0?o.bumpFactor:1,o.bumpTexture!==void 0&&i.push(n.assignTexture(t,"bumpMap",o.bumpTexture)),Promise.all(i)}}class Qr{constructor(e){this.parser=e,this.name=q.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:we}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],o=s.extensions[this.name];return o.anisotropyStrength!==void 0&&(t.anisotropy=o.anisotropyStrength),o.anisotropyRotation!==void 0&&(t.anisotropyRotation=o.anisotropyRotation),o.anisotropyTexture!==void 0&&i.push(n.assignTexture(t,"anisotropyMap",o.anisotropyTexture)),Promise.all(i)}}class Jr{constructor(e){this.parser=e,this.name=q.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,n=t.json,s=n.textures[e];if(!s.extensions||!s.extensions[this.name])return null;const i=s.extensions[this.name],o=t.options.ktx2Loader;if(!o){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,i.source,o)}}class ea{constructor(e){this.parser=e,this.name=q.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,s=n.json,i=s.textures[e];if(!i.extensions||!i.extensions[t])return null;const o=i.extensions[t],r=s.images[o.source];let a=n.textureLoader;if(r.uri){const c=n.options.manager.getHandler(r.uri);c!==null&&(a=c)}return this.detectSupport().then(function(c){if(c)return n.loadTextureImage(e,o.source,a);if(s.extensionsRequired&&s.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class ta{constructor(e){this.parser=e,this.name=q.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,s=n.json,i=s.textures[e];if(!i.extensions||!i.extensions[t])return null;const o=i.extensions[t],r=s.images[o.source];let a=n.textureLoader;if(r.uri){const c=n.options.manager.getHandler(r.uri);c!==null&&(a=c)}return this.detectSupport().then(function(c){if(c)return n.loadTextureImage(e,o.source,a);if(s.extensionsRequired&&s.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class na{constructor(e){this.name=q.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const s=n.extensions[this.name],i=this.parser.getDependency("buffer",s.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return i.then(function(r){const a=s.byteOffset||0,c=s.byteLength||0,h=s.count,l=s.byteStride,u=new Uint8Array(r,a,c);return o.decodeGltfBufferAsync?o.decodeGltfBufferAsync(h,l,u,s.mode,s.filter).then(function(p){return p.buffer}):o.ready.then(function(){const p=new ArrayBuffer(h*l);return o.decodeGltfBuffer(new Uint8Array(p),h,l,u,s.mode,s.filter),p})})}else return null}}class sa{constructor(e){this.name=q.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,n=t.nodes[e];if(!n.extensions||!n.extensions[this.name]||n.mesh===void 0)return null;const s=t.meshes[n.mesh];for(const c of s.primitives)if(c.mode!==ce.TRIANGLES&&c.mode!==ce.TRIANGLE_STRIP&&c.mode!==ce.TRIANGLE_FAN&&c.mode!==void 0)return null;const o=n.extensions[this.name].attributes,r=[],a={};for(const c in o)r.push(this.parser.getDependency("accessor",o[c]).then(h=>(a[c]=h,a[c])));return r.length<1?null:(r.push(this.parser.createNodeMesh(e)),Promise.all(r).then(c=>{const h=c.pop(),l=h.isGroup?h.children:[h],u=c[0].count,p=[];for(const m of l){const y=new W,g=new Z,w=new ye,v=new Z(1,1,1),x=new Rs(m.geometry,m.material,u);for(let A=0;A<u;A++)a.TRANSLATION&&g.fromBufferAttribute(a.TRANSLATION,A),a.ROTATION&&w.fromBufferAttribute(a.ROTATION,A),a.SCALE&&v.fromBufferAttribute(a.SCALE,A),x.setMatrixAt(A,y.compose(g,w,v));for(const A in a)if(A==="_COLOR_0"){const T=a[A];x.instanceColor=new Cs(T.array,T.itemSize,T.normalized)}else A!=="TRANSLATION"&&A!=="ROTATION"&&A!=="SCALE"&&m.geometry.setAttribute(A,a[A]);je.prototype.copy.call(x,m),this.parser.assignFinalMaterial(x),p.push(x)}return h.isGroup?(h.clear(),h.add(...p),h):p[0]}))}}const as="glTF",Ze=12,In={JSON:1313821514,BIN:5130562};class ia{constructor(e){this.name=q.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Ze),n=new TextDecoder;if(this.header={magic:n.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==as)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const s=this.header.length-Ze,i=new DataView(e,Ze);let o=0;for(;o<s;){const r=i.getUint32(o,!0);o+=4;const a=i.getUint32(o,!0);if(o+=4,a===In.JSON){const c=new Uint8Array(e,Ze+o,r);this.content=n.decode(c)}else if(a===In.BIN){const c=Ze+o;this.body=e.slice(c,c+r)}o+=r}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class oa{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=q.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const n=this.json,s=this.dracoLoader,i=e.extensions[this.name].bufferView,o=e.extensions[this.name].attributes,r={},a={},c={};for(const h in o){const l=Wt[h]||h.toLowerCase();r[l]=o[h]}for(const h in e.attributes){const l=Wt[h]||h.toLowerCase();if(o[h]!==void 0){const u=n.accessors[e.attributes[h]],p=We[u.componentType];c[l]=p.name,a[l]=u.normalized===!0}}return t.getDependency("bufferView",i).then(function(h){return new Promise(function(l,u){s.decodeDracoFile(h,function(p){for(const m in p.attributes){const y=p.attributes[m],g=a[m];g!==void 0&&(y.normalized=g)}l(p)},r,c,Re,u)})})}}class ra{constructor(){this.name=q.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class aa{constructor(){this.name=q.KHR_MESH_QUANTIZATION}}class cs extends Vs{constructor(e,t,n,s){super(e,t,n,s)}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,s=this.valueSize,i=e*s*3+s;for(let o=0;o!==s;o++)t[o]=n[i+o];return t}interpolate_(e,t,n,s){const i=this.resultBuffer,o=this.sampleValues,r=this.valueSize,a=r*2,c=r*3,h=s-t,l=(n-t)/h,u=l*l,p=u*l,m=e*c,y=m-c,g=-2*p+3*u,w=p-u,v=1-g,x=w-u+l;for(let A=0;A!==r;A++){const T=o[y+A+r],E=o[y+A+a]*h,M=o[m+A+r],C=o[m+A]*h;i[A]=v*T+x*E+g*M+w*C}return i}}const ca=new ye;class la extends cs{interpolate_(e,t,n,s){const i=super.interpolate_(e,t,n,s);return ca.fromArray(i).normalize().toArray(i),i}}const ce={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},We={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Ln={9728:Gn,9729:Gt,9984:Ns,9985:_s,9986:Fs,9987:Dn},Pn={33071:qt,33648:Bs,10497:nt},Pt={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Wt={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Ie={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},ha={CUBICSPLINE:void 0,LINEAR:Kn,STEP:Hs},Ft={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function ua(f){return f.DefaultMaterial===void 0&&(f.DefaultMaterial=new Hn({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:js})),f.DefaultMaterial}function Ne(f,e,t){for(const n in t.extensions)f[n]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[n]=t.extensions[n])}function Me(f,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(f.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function da(f,e,t){let n=!1,s=!1,i=!1;for(let c=0,h=e.length;c<h;c++){const l=e[c];if(l.POSITION!==void 0&&(n=!0),l.NORMAL!==void 0&&(s=!0),l.COLOR_0!==void 0&&(i=!0),n&&s&&i)break}if(!n&&!s&&!i)return Promise.resolve(f);const o=[],r=[],a=[];for(let c=0,h=e.length;c<h;c++){const l=e[c];if(n){const u=l.POSITION!==void 0?t.getDependency("accessor",l.POSITION):f.attributes.position;o.push(u)}if(s){const u=l.NORMAL!==void 0?t.getDependency("accessor",l.NORMAL):f.attributes.normal;r.push(u)}if(i){const u=l.COLOR_0!==void 0?t.getDependency("accessor",l.COLOR_0):f.attributes.color;a.push(u)}}return Promise.all([Promise.all(o),Promise.all(r),Promise.all(a)]).then(function(c){const h=c[0],l=c[1],u=c[2];return n&&(f.morphAttributes.position=h),s&&(f.morphAttributes.normal=l),i&&(f.morphAttributes.color=u),f.morphTargetsRelative=!0,f})}function pa(f,e){if(f.updateMorphTargets(),e.weights!==void 0)for(let t=0,n=e.weights.length;t<n;t++)f.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(f.morphTargetInfluences.length===t.length){f.morphTargetDictionary={};for(let n=0,s=t.length;n<s;n++)f.morphTargetDictionary[t[n]]=n}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function fa(f){let e;const t=f.extensions&&f.extensions[q.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+_t(t.attributes):e=f.indices+":"+_t(f.attributes)+":"+f.mode,f.targets!==void 0)for(let n=0,s=f.targets.length;n<s;n++)e+=":"+_t(f.targets[n]);return e}function _t(f){let e="";const t=Object.keys(f).sort();for(let n=0,s=t.length;n<s;n++)e+=t[n]+":"+f[t[n]]+";";return e}function Xt(f){switch(f){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function ma(f){return f.search(/\.jpe?g($|\?)/i)>0||f.search(/^data\:image\/jpeg/)===0?"image/jpeg":f.search(/\.webp($|\?)/i)>0||f.search(/^data\:image\/webp/)===0?"image/webp":f.search(/\.ktx2($|\?)/i)>0||f.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"}const ga=new W;class ya{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new Dr,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let n=!1,s=-1,i=!1,o=-1;if(typeof navigator<"u"){const r=navigator.userAgent;n=/^((?!chrome|android).)*safari/i.test(r)===!0;const a=r.match(/Version\/(\d+)/);s=n&&a?parseInt(a[1],10):-1,i=r.indexOf("Firefox")>-1,o=i?r.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||n&&s<17||i&&o<98?this.textureLoader=new On(this.options.manager):this.textureLoader=new Is(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new $t(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const n=this,s=this.json,i=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(o){const r={scene:o[0][s.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:s.asset,parser:n,userData:{}};return Ne(i,r,s),Me(r,s),Promise.all(n._invokeAll(function(a){return a.afterRoot&&a.afterRoot(r)})).then(function(){for(const a of r.scenes)a.updateMatrixWorld();e(r)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[];for(let s=0,i=t.length;s<i;s++){const o=t[s].joints;for(let r=0,a=o.length;r<a;r++)e[o[r]].isBone=!0}for(let s=0,i=e.length;s<i;s++){const o=e[s];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(n[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,n){if(e.refs[t]<=1)return n;const s=n.clone(),i=(o,r)=>{const a=this.associations.get(o);a!=null&&this.associations.set(r,a);for(const[c,h]of o.children.entries())i(h,r.children[c])};return i(n,s),s.name+="_instance_"+e.uses[t]++,s}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let n=0;n<t.length;n++){const s=e(t[n]);if(s)return s}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const n=[];for(let s=0;s<t.length;s++){const i=e(t[s]);i&&n.push(i)}return n}getDependency(e,t){const n=e+":"+t;let s=this.cache.get(n);if(!s){switch(e){case"scene":s=this.loadScene(t);break;case"node":s=this._invokeOne(function(i){return i.loadNode&&i.loadNode(t)});break;case"mesh":s=this._invokeOne(function(i){return i.loadMesh&&i.loadMesh(t)});break;case"accessor":s=this.loadAccessor(t);break;case"bufferView":s=this._invokeOne(function(i){return i.loadBufferView&&i.loadBufferView(t)});break;case"buffer":s=this.loadBuffer(t);break;case"material":s=this._invokeOne(function(i){return i.loadMaterial&&i.loadMaterial(t)});break;case"texture":s=this._invokeOne(function(i){return i.loadTexture&&i.loadTexture(t)});break;case"skin":s=this.loadSkin(t);break;case"animation":s=this._invokeOne(function(i){return i.loadAnimation&&i.loadAnimation(t)});break;case"camera":s=this.loadCamera(t);break;default:if(s=this._invokeOne(function(i){return i!=this&&i.getDependency&&i.getDependency(e,t)}),!s)throw new Error("Unknown type: "+e);break}this.cache.add(n,s)}return s}getDependencies(e){let t=this.cache.get(e);if(!t){const n=this,s=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(s.map(function(i,o){return n.getDependency(e,o)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],n=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[q.KHR_BINARY_GLTF].body);const s=this.options;return new Promise(function(i,o){n.load(Ue.resolveURL(t.uri,s.path),i,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(n){const s=t.byteLength||0,i=t.byteOffset||0;return n.slice(i,i+s)})}loadAccessor(e){const t=this,n=this.json,s=this.json.accessors[e];if(s.bufferView===void 0&&s.sparse===void 0){const o=Pt[s.type],r=We[s.componentType],a=s.normalized===!0,c=new r(s.count*o);return Promise.resolve(new Et(c,o,a))}const i=[];return s.bufferView!==void 0?i.push(this.getDependency("bufferView",s.bufferView)):i.push(null),s.sparse!==void 0&&(i.push(this.getDependency("bufferView",s.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",s.sparse.values.bufferView))),Promise.all(i).then(function(o){const r=o[0],a=Pt[s.type],c=We[s.componentType],h=c.BYTES_PER_ELEMENT,l=h*a,u=s.byteOffset||0,p=s.bufferView!==void 0?n.bufferViews[s.bufferView].byteStride:void 0,m=s.normalized===!0;let y,g;if(p&&p!==l){const w=Math.floor(u/p),v="InterleavedBuffer:"+s.bufferView+":"+s.componentType+":"+w+":"+s.count;let x=t.cache.get(v);x||(y=new c(r,w*p,s.count*p/h),x=new Ls(y,p/h),t.cache.add(v,x)),g=new Ps(x,a,u%p/h,m)}else r===null?y=new c(s.count*a):y=new c(r,u,s.count*a),g=new Et(y,a,m);if(s.sparse!==void 0){const w=Pt.SCALAR,v=We[s.sparse.indices.componentType],x=s.sparse.indices.byteOffset||0,A=s.sparse.values.byteOffset||0,T=new v(o[1],x,s.sparse.count*w),E=new c(o[2],A,s.sparse.count*a);r!==null&&(g=new Et(g.array.slice(),g.itemSize,g.normalized)),g.normalized=!1;for(let M=0,C=T.length;M<C;M++){const N=T[M];if(g.setX(N,E[M*a]),a>=2&&g.setY(N,E[M*a+1]),a>=3&&g.setZ(N,E[M*a+2]),a>=4&&g.setW(N,E[M*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}g.normalized=m}return g})}loadTexture(e){const t=this.json,n=this.options,i=t.textures[e].source,o=t.images[i];let r=this.textureLoader;if(o.uri){const a=n.manager.getHandler(o.uri);a!==null&&(r=a)}return this.loadTextureImage(e,i,r)}loadTextureImage(e,t,n){const s=this,i=this.json,o=i.textures[e],r=i.images[t],a=(r.uri||r.bufferView)+":"+o.sampler;if(this.textureCache[a])return this.textureCache[a];const c=this.loadImageSource(t,n).then(function(h){h.flipY=!1,h.name=o.name||r.name||"",h.name===""&&typeof r.uri=="string"&&r.uri.startsWith("data:image/")===!1&&(h.name=r.uri);const u=(i.samplers||{})[o.sampler]||{};return h.magFilter=Ln[u.magFilter]||Gt,h.minFilter=Ln[u.minFilter]||Dn,h.wrapS=Pn[u.wrapS]||nt,h.wrapT=Pn[u.wrapT]||nt,h.generateMipmaps=!h.isCompressedTexture&&h.minFilter!==Gn&&h.minFilter!==Gt,s.associations.set(h,{textures:e}),h}).catch(function(){return null});return this.textureCache[a]=c,c}loadImageSource(e,t){const n=this,s=this.json,i=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(l=>l.clone());const o=s.images[e],r=self.URL||self.webkitURL;let a=o.uri||"",c=!1;if(o.bufferView!==void 0)a=n.getDependency("bufferView",o.bufferView).then(function(l){c=!0;const u=new Blob([l],{type:o.mimeType});return a=r.createObjectURL(u),a});else if(o.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const h=Promise.resolve(a).then(function(l){return new Promise(function(u,p){let m=u;t.isImageBitmapLoader===!0&&(m=function(y){const g=new jt(y);g.needsUpdate=!0,u(g)}),t.load(Ue.resolveURL(l,i.path),m,void 0,p)})}).then(function(l){return c===!0&&r.revokeObjectURL(a),Me(l,o),l.userData.mimeType=o.mimeType||ma(o.uri),l}).catch(function(l){throw console.error("THREE.GLTFLoader: Couldn't load texture",a),l});return this.sourceCache[e]=h,h}assignTexture(e,t,n,s){const i=this;return this.getDependency("texture",n.index).then(function(o){if(!o)return null;if(n.texCoord!==void 0&&n.texCoord>0&&(o=o.clone(),o.channel=n.texCoord),i.extensions[q.KHR_TEXTURE_TRANSFORM]){const r=n.extensions!==void 0?n.extensions[q.KHR_TEXTURE_TRANSFORM]:void 0;if(r){const a=i.associations.get(o);o=i.extensions[q.KHR_TEXTURE_TRANSFORM].extendTexture(o,r),i.associations.set(o,a)}}return s!==void 0&&(o.colorSpace=s),e[t]=o,o})}assignFinalMaterial(e){const t=e.geometry;let n=e.material;const s=t.attributes.tangent===void 0,i=t.attributes.color!==void 0,o=t.attributes.normal===void 0;if(e.isPoints){const r="PointsMaterial:"+n.uuid;let a=this.cache.get(r);a||(a=new zs,bt.prototype.copy.call(a,n),a.color.copy(n.color),a.map=n.map,a.sizeAttenuation=!1,this.cache.add(r,a)),n=a}else if(e.isLine){const r="LineBasicMaterial:"+n.uuid;let a=this.cache.get(r);a||(a=new qn,bt.prototype.copy.call(a,n),a.color.copy(n.color),a.map=n.map,this.cache.add(r,a)),n=a}if(s||i||o){let r="ClonedMaterial:"+n.uuid+":";s&&(r+="derivative-tangents:"),i&&(r+="vertex-colors:"),o&&(r+="flat-shading:");let a=this.cache.get(r);a||(a=n.clone(),i&&(a.vertexColors=!0),o&&(a.flatShading=!0),s&&(a.normalScale&&(a.normalScale.y*=-1),a.clearcoatNormalScale&&(a.clearcoatNormalScale.y*=-1)),this.cache.add(r,a),this.associations.set(a,this.associations.get(n))),n=a}e.material=n}getMaterialType(){return Hn}loadMaterial(e){const t=this,n=this.json,s=this.extensions,i=n.materials[e];let o;const r={},a=i.extensions||{},c=[];if(a[q.KHR_MATERIALS_UNLIT]){const l=s[q.KHR_MATERIALS_UNLIT];o=l.getMaterialType(),c.push(l.extendParams(r,i,t))}else{const l=i.pbrMetallicRoughness||{};if(r.color=new se(1,1,1),r.opacity=1,Array.isArray(l.baseColorFactor)){const u=l.baseColorFactor;r.color.setRGB(u[0],u[1],u[2],Re),r.opacity=u[3]}l.baseColorTexture!==void 0&&c.push(t.assignTexture(r,"map",l.baseColorTexture,ee)),r.metalness=l.metallicFactor!==void 0?l.metallicFactor:1,r.roughness=l.roughnessFactor!==void 0?l.roughnessFactor:1,l.metallicRoughnessTexture!==void 0&&(c.push(t.assignTexture(r,"metalnessMap",l.metallicRoughnessTexture)),c.push(t.assignTexture(r,"roughnessMap",l.metallicRoughnessTexture))),o=this._invokeOne(function(u){return u.getMaterialType&&u.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(u){return u.extendMaterialParams&&u.extendMaterialParams(e,r)})))}i.doubleSided===!0&&(r.side=ks);const h=i.alphaMode||Ft.OPAQUE;if(h===Ft.BLEND?(r.transparent=!0,r.depthWrite=!1):(r.transparent=!1,h===Ft.MASK&&(r.alphaTest=i.alphaCutoff!==void 0?i.alphaCutoff:.5)),i.normalTexture!==void 0&&o!==Qe&&(c.push(t.assignTexture(r,"normalMap",i.normalTexture)),r.normalScale=new Zt(1,1),i.normalTexture.scale!==void 0)){const l=i.normalTexture.scale;r.normalScale.set(l,l)}if(i.occlusionTexture!==void 0&&o!==Qe&&(c.push(t.assignTexture(r,"aoMap",i.occlusionTexture)),i.occlusionTexture.strength!==void 0&&(r.aoMapIntensity=i.occlusionTexture.strength)),i.emissiveFactor!==void 0&&o!==Qe){const l=i.emissiveFactor;r.emissive=new se().setRGB(l[0],l[1],l[2],Re)}return i.emissiveTexture!==void 0&&o!==Qe&&c.push(t.assignTexture(r,"emissiveMap",i.emissiveTexture,ee)),Promise.all(c).then(function(){const l=new o(r);return i.name&&(l.name=i.name),Me(l,i),t.associations.set(l,{materials:e}),i.extensions&&Ne(s,l,i),l})}createUniqueName(e){const t=st.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,n=this.extensions,s=this.primitiveCache;function i(r){return n[q.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(r,t).then(function(a){return Fn(a,r,t)})}const o=[];for(let r=0,a=e.length;r<a;r++){const c=e[r],h=fa(c),l=s[h];if(l)o.push(l.promise);else{let u;c.extensions&&c.extensions[q.KHR_DRACO_MESH_COMPRESSION]?u=i(c):u=Fn(new yt,c,t),s[h]={primitive:c,promise:u},o.push(u)}}return Promise.all(o)}loadMesh(e){const t=this,n=this.json,s=this.extensions,i=n.meshes[e],o=i.primitives,r=[];for(let a=0,c=o.length;a<c;a++){const h=o[a].material===void 0?ua(this.cache):this.getDependency("material",o[a].material);r.push(h)}return r.push(t.loadGeometries(o)),Promise.all(r).then(function(a){const c=a.slice(0,a.length-1),h=a[a.length-1],l=[];for(let p=0,m=h.length;p<m;p++){const y=h[p],g=o[p];let w;const v=c[p];if(g.mode===ce.TRIANGLES||g.mode===ce.TRIANGLE_STRIP||g.mode===ce.TRIANGLE_FAN||g.mode===void 0)w=i.isSkinnedMesh===!0?new jn(y,v):new Yt(y,v),w.isSkinnedMesh===!0&&w.normalizeSkinWeights(),g.mode===ce.TRIANGLE_STRIP?w.geometry=Cn(w.geometry,Bn):g.mode===ce.TRIANGLE_FAN&&(w.geometry=Cn(w.geometry,Ot));else if(g.mode===ce.LINES)w=new Os(y,v);else if(g.mode===ce.LINE_STRIP)w=new Vn(y,v);else if(g.mode===ce.LINE_LOOP)w=new Ds(y,v);else if(g.mode===ce.POINTS)w=new Gs(y,v);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+g.mode);Object.keys(w.geometry.morphAttributes).length>0&&pa(w,i),w.name=t.createUniqueName(i.name||"mesh_"+e),Me(w,i),g.extensions&&Ne(s,w,g),t.assignFinalMaterial(w),l.push(w)}for(let p=0,m=l.length;p<m;p++)t.associations.set(l[p],{meshes:e,primitives:p});if(l.length===1)return i.extensions&&Ne(s,l[0],i),l[0];const u=new Je;i.extensions&&Ne(s,u,i),t.associations.set(u,{meshes:e});for(let p=0,m=l.length;p<m;p++)u.add(l[p]);return u})}loadCamera(e){let t;const n=this.json.cameras[e],s=n[n.type];if(!s){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return n.type==="perspective"?t=new Un(ne.radToDeg(s.yfov),s.aspectRatio||1,s.znear||1,s.zfar||2e6):n.type==="orthographic"&&(t=new qs(-s.xmag,s.xmag,s.ymag,-s.ymag,s.znear,s.zfar)),n.name&&(t.name=this.createUniqueName(n.name)),Me(t,n),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],n=[];for(let s=0,i=t.joints.length;s<i;s++)n.push(this._loadNodeShallow(t.joints[s]));return t.inverseBindMatrices!==void 0?n.push(this.getDependency("accessor",t.inverseBindMatrices)):n.push(null),Promise.all(n).then(function(s){const i=s.pop(),o=s,r=[],a=[];for(let c=0,h=o.length;c<h;c++){const l=o[c];if(l){r.push(l);const u=new W;i!==null&&u.fromArray(i.array,c*16),a.push(u)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[c])}return new Wn(r,a)})}loadAnimation(e){const t=this.json,n=this,s=t.animations[e],i=s.name?s.name:"animation_"+e,o=[],r=[],a=[],c=[],h=[];for(let l=0,u=s.channels.length;l<u;l++){const p=s.channels[l],m=s.samplers[p.sampler],y=p.target,g=y.node,w=s.parameters!==void 0?s.parameters[m.input]:m.input,v=s.parameters!==void 0?s.parameters[m.output]:m.output;y.node!==void 0&&(o.push(this.getDependency("node",g)),r.push(this.getDependency("accessor",w)),a.push(this.getDependency("accessor",v)),c.push(m),h.push(y))}return Promise.all([Promise.all(o),Promise.all(r),Promise.all(a),Promise.all(c),Promise.all(h)]).then(function(l){const u=l[0],p=l[1],m=l[2],y=l[3],g=l[4],w=[];for(let v=0,x=u.length;v<x;v++){const A=u[v],T=p[v],E=m[v],M=y[v],C=g[v];if(A===void 0)continue;A.updateMatrix&&A.updateMatrix();const N=n._createAnimationTracks(A,T,E,M,C);if(N)for(let P=0;P<N.length;P++)w.push(N[P])}return new Xn(i,void 0,w)})}createNodeMesh(e){const t=this.json,n=this,s=t.nodes[e];return s.mesh===void 0?null:n.getDependency("mesh",s.mesh).then(function(i){const o=n._getNodeRef(n.meshCache,s.mesh,i);return s.weights!==void 0&&o.traverse(function(r){if(r.isMesh)for(let a=0,c=s.weights.length;a<c;a++)r.morphTargetInfluences[a]=s.weights[a]}),o})}loadNode(e){const t=this.json,n=this,s=t.nodes[e],i=n._loadNodeShallow(e),o=[],r=s.children||[];for(let c=0,h=r.length;c<h;c++)o.push(n.getDependency("node",r[c]));const a=s.skin===void 0?Promise.resolve(null):n.getDependency("skin",s.skin);return Promise.all([i,Promise.all(o),a]).then(function(c){const h=c[0],l=c[1],u=c[2];u!==null&&h.traverse(function(p){p.isSkinnedMesh&&p.bind(u,ga)});for(let p=0,m=l.length;p<m;p++)h.add(l[p]);return h})}_loadNodeShallow(e){const t=this.json,n=this.extensions,s=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const i=t.nodes[e],o=i.name?s.createUniqueName(i.name):"",r=[],a=s._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return a&&r.push(a),i.camera!==void 0&&r.push(s.getDependency("camera",i.camera).then(function(c){return s._getNodeRef(s.cameraCache,i.camera,c)})),s._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){r.push(c)}),this.nodeCache[e]=Promise.all(r).then(function(c){let h;if(i.isBone===!0?h=new Ht:c.length>1?h=new Je:c.length===1?h=c[0]:h=new je,h!==c[0])for(let l=0,u=c.length;l<u;l++)h.add(c[l]);if(i.name&&(h.userData.name=i.name,h.name=o),Me(h,i),i.extensions&&Ne(n,h,i),i.matrix!==void 0){const l=new W;l.fromArray(i.matrix),h.applyMatrix4(l)}else i.translation!==void 0&&h.position.fromArray(i.translation),i.rotation!==void 0&&h.quaternion.fromArray(i.rotation),i.scale!==void 0&&h.scale.fromArray(i.scale);return s.associations.has(h)||s.associations.set(h,{}),s.associations.get(h).nodes=e,h}),this.nodeCache[e]}loadScene(e){const t=this.extensions,n=this.json.scenes[e],s=this,i=new Je;n.name&&(i.name=s.createUniqueName(n.name)),Me(i,n),n.extensions&&Ne(t,i,n);const o=n.nodes||[],r=[];for(let a=0,c=o.length;a<c;a++)r.push(s.getDependency("node",o[a]));return Promise.all(r).then(function(a){for(let h=0,l=a.length;h<l;h++)i.add(a[h]);const c=h=>{const l=new Map;for(const[u,p]of s.associations)(u instanceof bt||u instanceof jt)&&l.set(u,p);return h.traverse(u=>{const p=s.associations.get(u);p!=null&&l.set(u,p)}),l};return s.associations=c(i),i})}_createAnimationTracks(e,t,n,s,i){const o=[],r=e.name?e.name:e.uuid,a=[];Ie[i.path]===Ie.weights?e.traverse(function(u){u.morphTargetInfluences&&a.push(u.name?u.name:u.uuid)}):a.push(r);let c;switch(Ie[i.path]){case Ie.weights:c=Ut;break;case Ie.rotation:c=wt;break;case Ie.position:case Ie.scale:c=Vt;break;default:switch(n.itemSize){case 1:c=Ut;break;case 2:case 3:default:c=Vt;break}break}const h=s.interpolation!==void 0?ha[s.interpolation]:Kn,l=this._getArrayFromAccessor(n);for(let u=0,p=a.length;u<p;u++){const m=new c(a[u]+"."+Ie[i.path],t.array,l,h);s.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(m),o.push(m)}return o}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const n=Xt(t.constructor),s=new Float32Array(t.length);for(let i=0,o=t.length;i<o;i++)s[i]=t[i]*n;t=s}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(n){const s=this instanceof wt?la:cs;return new s(this.times,this.values,this.getValueSize()/3,n)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function va(f,e,t){const n=e.attributes,s=new Us;if(n.POSITION!==void 0){const r=t.json.accessors[n.POSITION],a=r.min,c=r.max;if(a!==void 0&&c!==void 0){if(s.set(new Z(a[0],a[1],a[2]),new Z(c[0],c[1],c[2])),r.normalized){const h=Xt(We[r.componentType]);s.min.multiplyScalar(h),s.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=e.targets;if(i!==void 0){const r=new Z,a=new Z;for(let c=0,h=i.length;c<h;c++){const l=i[c];if(l.POSITION!==void 0){const u=t.json.accessors[l.POSITION],p=u.min,m=u.max;if(p!==void 0&&m!==void 0){if(a.setX(Math.max(Math.abs(p[0]),Math.abs(m[0]))),a.setY(Math.max(Math.abs(p[1]),Math.abs(m[1]))),a.setZ(Math.max(Math.abs(p[2]),Math.abs(m[2]))),u.normalized){const y=Xt(We[u.componentType]);a.multiplyScalar(y)}r.max(a)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}s.expandByVector(r)}f.boundingBox=s;const o=new Ws;s.getCenter(o.center),o.radius=s.min.distanceTo(s.max)/2,f.boundingSphere=o}function Fn(f,e,t){const n=e.attributes,s=[];function i(o,r){return t.getDependency("accessor",o).then(function(a){f.setAttribute(r,a)})}for(const o in n){const r=Wt[o]||o.toLowerCase();r in f.attributes||s.push(i(n[o],r))}if(e.indices!==void 0&&!f.index){const o=t.getDependency("accessor",e.indices).then(function(r){f.setIndex(r)});s.push(o)}return ve.workingColorSpace!==Re&&"COLOR_0"in n&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ve.workingColorSpace}" not supported.`),Me(f,e),va(f,e,t),Promise.all(s).then(function(){return e.targets!==void 0?da(f,e.targets,t):f})}const wa=(f,e={})=>{const t=e.manager||new Yn,n=new Or(t);return new Promise((s,i)=>{const o=Date.now();n.load(f,r=>{const a=((Date.now()-o)/1e3).toFixed(1);console.log(` ${e.name||f} loaded in ${a}s`),s(r.scene)},r=>{r.lengthComputable&&e.onProgress&&e.onProgress(r.loaded/r.total*100)},r=>{t.removeHandler(/.*/),i(new Error(`Failed to load ${f}: ${r.message}`))})})};/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.8.2
*/var le=Uint8Array,Ve=Uint16Array,xa=Int32Array,ls=new le([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),hs=new le([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Aa=new le([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),us=function(f,e){for(var t=new Ve(31),n=0;n<31;++n)t[n]=e+=1<<f[n-1];for(var s=new xa(t[30]),n=1;n<30;++n)for(var i=t[n];i<t[n+1];++i)s[i]=i-t[n]<<5|n;return{b:t,r:s}},ds=us(ls,2),ps=ds.b,Ta=ds.r;ps[28]=258,Ta[258]=28;var Ea=us(hs,0),ba=Ea.b,Kt=new Ve(32768);for(var X=0;X<32768;++X){var Le=(X&43690)>>1|(X&21845)<<1;Le=(Le&52428)>>2|(Le&13107)<<2,Le=(Le&61680)>>4|(Le&3855)<<4,Kt[X]=((Le&65280)>>8|(Le&255)<<8)>>1}var tt=function(f,e,t){for(var n=f.length,s=0,i=new Ve(e);s<n;++s)f[s]&&++i[f[s]-1];var o=new Ve(e);for(s=1;s<e;++s)o[s]=o[s-1]+i[s-1]<<1;var r;if(t){r=new Ve(1<<e);var a=15-e;for(s=0;s<n;++s)if(f[s])for(var c=s<<4|f[s],h=e-f[s],l=o[f[s]-1]++<<h,u=l|(1<<h)-1;l<=u;++l)r[Kt[l]>>a]=c}else for(r=new Ve(n),s=0;s<n;++s)f[s]&&(r[s]=Kt[o[f[s]-1]++]>>15-f[s]);return r},lt=new le(288);for(var X=0;X<144;++X)lt[X]=8;for(var X=144;X<256;++X)lt[X]=9;for(var X=256;X<280;++X)lt[X]=7;for(var X=280;X<288;++X)lt[X]=8;var fs=new le(32);for(var X=0;X<32;++X)fs[X]=5;var Sa=tt(lt,9,1),Ma=tt(fs,5,1),Nt=function(f){for(var e=f[0],t=1;t<f.length;++t)f[t]>e&&(e=f[t]);return e},ue=function(f,e,t){var n=e/8|0;return(f[n]|f[n+1]<<8)>>(e&7)&t},Bt=function(f,e){var t=e/8|0;return(f[t]|f[t+1]<<8|f[t+2]<<16)>>(e&7)},Ra=function(f){return(f+7)/8|0},Ca=function(f,e,t){return(t==null||t>f.length)&&(t=f.length),new le(f.subarray(e,t))},Ia=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],de=function(f,e,t){var n=new Error(e||Ia[f]);if(n.code=f,Error.captureStackTrace&&Error.captureStackTrace(n,de),!t)throw n;return n},La=function(f,e,t,n){var s=f.length,i=0;if(!s||e.f&&!e.l)return t||new le(0);var o=!t,r=o||e.i!=2,a=e.i;o&&(t=new le(s*3));var c=function(rn){var an=t.length;if(rn>an){var cn=new le(Math.max(an*2,rn));cn.set(t),t=cn}},h=e.f||0,l=e.p||0,u=e.b||0,p=e.l,m=e.d,y=e.m,g=e.n,w=s*8;do{if(!p){h=ue(f,l,1);var v=ue(f,l+1,3);if(l+=3,v)if(v==1)p=Sa,m=Ma,y=9,g=5;else if(v==2){var E=ue(f,l,31)+257,M=ue(f,l+10,15)+4,C=E+ue(f,l+5,31)+1;l+=14;for(var N=new le(C),P=new le(19),L=0;L<M;++L)P[Aa[L]]=ue(f,l+L*3,7);l+=M*3;for(var k=Nt(P),S=(1<<k)-1,I=tt(P,k,1),L=0;L<C;){var R=I[ue(f,l,S)];l+=R&15;var x=R>>4;if(x<16)N[L++]=x;else{var b=0,j=0;for(x==16?(j=3+ue(f,l,3),l+=2,b=N[L-1]):x==17?(j=3+ue(f,l,7),l+=3):x==18&&(j=11+ue(f,l,127),l+=7);j--;)N[L++]=b}}var O=N.subarray(0,E),z=N.subarray(E);y=Nt(O),g=Nt(z),p=tt(O,y,1),m=tt(z,g,1)}else de(1);else{var x=Ra(l)+4,A=f[x-4]|f[x-3]<<8,T=x+A;if(T>s){a&&de(0);break}r&&c(u+A),t.set(f.subarray(x,T),u),e.b=u+=A,e.p=l=T*8,e.f=h;continue}if(l>w){a&&de(0);break}}r&&c(u+131072);for(var te=(1<<y)-1,J=(1<<g)-1,B=l;;B=l){var b=p[Bt(f,l)&te],re=b>>4;if(l+=b&15,l>w){a&&de(0);break}if(b||de(2),re<256)t[u++]=re;else if(re==256){B=l,p=null;break}else{var Pe=re-254;if(re>264){var L=re-257,xe=ls[L];Pe=ue(f,l,(1<<xe)-1)+ps[L],l+=xe}var Fe=m[Bt(f,l)&J],Oe=Fe>>4;Fe||de(3),l+=Fe&15;var z=ba[Oe];if(Oe>3){var xe=hs[Oe];z+=Bt(f,l)&(1<<xe)-1,l+=xe}if(l>w){a&&de(0);break}r&&c(u+131072);var sn=u+Pe;if(u<z){var on=i-z,ws=Math.min(z,sn);for(on+u<0&&de(3);u<ws;++u)t[u]=n[on+u]}for(;u<sn;++u)t[u]=t[u-z]}}e.l=p,e.p=B,e.b=u,e.f=h,p&&(h=1,e.m=y,e.d=m,e.n=g)}while(!h);return u!=t.length&&o?Ca(t,0,u):t.subarray(0,u)},Pa=new le(0),Fa=function(f,e){return((f[0]&15)!=8||f[0]>>4>7||(f[0]<<8|f[1])%31)&&de(6,"invalid zlib data"),(f[1]>>5&1)==1&&de(6,"invalid zlib data: "+(f[1]&32?"need":"unexpected")+" dictionary"),(f[1]>>3&4)+2};function _a(f,e){return La(f.subarray(Fa(f),-4),{i:2},e,e)}var Na=typeof TextDecoder<"u"&&new TextDecoder,Ba=0;try{Na.decode(Pa,{stream:!0}),Ba=1}catch{}function ms(f,e,t){const n=t.length-f-1;if(e>=t[n])return n-1;if(e<=t[f])return f;let s=f,i=n,o=Math.floor((s+i)/2);for(;e<t[o]||e>=t[o+1];)e<t[o]?i=o:s=o,o=Math.floor((s+i)/2);return o}function za(f,e,t,n){const s=[],i=[],o=[];s[0]=1;for(let r=1;r<=t;++r){i[r]=e-n[f+1-r],o[r]=n[f+r]-e;let a=0;for(let c=0;c<r;++c){const h=o[c+1],l=i[r-c],u=s[c]/(h+l);s[c]=a+h*u,a=l*u}s[r]=a}return s}function ka(f,e,t,n){const s=ms(f,n,e),i=za(s,n,f,e),o=new it(0,0,0,0);for(let r=0;r<=f;++r){const a=t[s-f+r],c=i[r],h=a.w*c;o.x+=a.x*h,o.y+=a.y*h,o.z+=a.z*h,o.w+=a.w*c}return o}function Oa(f,e,t,n,s){const i=[];for(let l=0;l<=t;++l)i[l]=0;const o=[];for(let l=0;l<=n;++l)o[l]=i.slice(0);const r=[];for(let l=0;l<=t;++l)r[l]=i.slice(0);r[0][0]=1;const a=i.slice(0),c=i.slice(0);for(let l=1;l<=t;++l){a[l]=e-s[f+1-l],c[l]=s[f+l]-e;let u=0;for(let p=0;p<l;++p){const m=c[p+1],y=a[l-p];r[l][p]=m+y;const g=r[p][l-1]/r[l][p];r[p][l]=u+m*g,u=y*g}r[l][l]=u}for(let l=0;l<=t;++l)o[0][l]=r[l][t];for(let l=0;l<=t;++l){let u=0,p=1;const m=[];for(let y=0;y<=t;++y)m[y]=i.slice(0);m[0][0]=1;for(let y=1;y<=n;++y){let g=0;const w=l-y,v=t-y;l>=y&&(m[p][0]=m[u][0]/r[v+1][w],g=m[p][0]*r[w][v]);const x=w>=-1?1:-w,A=l-1<=v?y-1:t-l;for(let E=x;E<=A;++E)m[p][E]=(m[u][E]-m[u][E-1])/r[v+1][w+E],g+=m[p][E]*r[w+E][v];l<=v&&(m[p][y]=-m[u][y-1]/r[v+1][l],g+=m[p][y]*r[l][v]),o[y][l]=g;const T=u;u=p,p=T}}let h=t;for(let l=1;l<=n;++l){for(let u=0;u<=t;++u)o[l][u]*=h;h*=t-l}return o}function Da(f,e,t,n,s){const i=s<f?s:f,o=[],r=ms(f,n,e),a=Oa(r,n,f,i,e),c=[];for(let h=0;h<t.length;++h){const l=t[h].clone(),u=l.w;l.x*=u,l.y*=u,l.z*=u,c[h]=l}for(let h=0;h<=i;++h){const l=c[r-f].clone().multiplyScalar(a[h][0]);for(let u=1;u<=f;++u)l.add(c[r-f+u].clone().multiplyScalar(a[h][u]));o[h]=l}for(let h=i+1;h<=s+1;++h)o[h]=new it(0,0,0);return o}function Ga(f,e){let t=1;for(let s=2;s<=f;++s)t*=s;let n=1;for(let s=2;s<=e;++s)n*=s;for(let s=2;s<=f-e;++s)n*=s;return t/n}function qa(f){const e=f.length,t=[],n=[];for(let i=0;i<e;++i){const o=f[i];t[i]=new Z(o.x,o.y,o.z),n[i]=o.w}const s=[];for(let i=0;i<e;++i){const o=t[i].clone();for(let r=1;r<=i;++r)o.sub(s[i-r].clone().multiplyScalar(Ga(i,r)*n[r]));s[i]=o.divideScalar(n[0])}return s}function Ha(f,e,t,n,s){const i=Da(f,e,t,n,s);return qa(i)}class ja extends Xs{constructor(e,t,n,s,i){super();const o=t?t.length-1:0,r=n?n.length:0;this.degree=e,this.knots=t,this.controlPoints=[],this.startKnot=s||0,this.endKnot=i||o;for(let a=0;a<r;++a){const c=n[a];this.controlPoints[a]=new it(c.x,c.y,c.z,c.w)}}getPoint(e,t=new Z){const n=t,s=this.knots[this.startKnot]+e*(this.knots[this.endKnot]-this.knots[this.startKnot]),i=ka(this.degree,this.knots,this.controlPoints,s);return i.w!==1&&i.divideScalar(i.w),n.set(i.x,i.y,i.z)}getTangent(e,t=new Z){const n=t,s=this.knots[0]+e*(this.knots[this.knots.length-1]-this.knots[0]),i=Ha(this.degree,this.knots,this.controlPoints,s,1);return n.copy(i[1]).normalize(),n}toJSON(){const e=super.toJSON();return e.degree=this.degree,e.knots=[...this.knots],e.controlPoints=this.controlPoints.map(t=>t.toArray()),e.startKnot=this.startKnot,e.endKnot=this.endKnot,e}fromJSON(e){return super.fromJSON(e),this.degree=e.degree,this.knots=[...e.knots],this.controlPoints=e.controlPoints.map(t=>new it(t[0],t[1],t[2],t[3])),this.startKnot=e.startKnot,this.endKnot=e.endKnot,this}}let D,K,ie;class Va extends vt{constructor(e){super(e)}load(e,t,n,s){const i=this,o=i.path===""?Ue.extractUrlBase(e):i.path,r=new $t(this.manager);r.setPath(i.path),r.setResponseType("arraybuffer"),r.setRequestHeader(i.requestHeader),r.setWithCredentials(i.withCredentials),r.load(e,function(a){try{t(i.parse(a,o))}catch(c){s?s(c):console.error(c),i.manager.itemError(e)}},n,s)}parse(e,t){if($a(e))D=new Ya().parse(e);else{const s=vs(e);if(!Za(s))throw new Error("THREE.FBXLoader: Unknown format.");if(Nn(s)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+Nn(s));D=new Ka().parse(s)}const n=new On(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new Ua(n,this.manager).parse(D)}}class Ua{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){K=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),n=this.parseMaterials(t),s=this.parseDeformers(),i=new Wa().parse(s);return this.parseScene(s,i,n),ie}parseConnections(){const e=new Map;return"Connections"in D&&D.Connections.connections.forEach(function(n){const s=n[0],i=n[1],o=n[2];e.has(s)||e.set(s,{parents:[],children:[]});const r={ID:i,relationship:o};e.get(s).parents.push(r),e.has(i)||e.set(i,{parents:[],children:[]});const a={ID:s,relationship:o};e.get(i).children.push(a)}),e}parseImages(){const e={},t={};if("Video"in D.Objects){const n=D.Objects.Video;for(const s in n){const i=n[s],o=parseInt(s);if(e[o]=i.RelativeFilename||i.Filename,"Content"in i){const r=i.Content instanceof ArrayBuffer&&i.Content.byteLength>0,a=typeof i.Content=="string"&&i.Content!=="";if(r||a){const c=this.parseImage(n[s]);t[i.RelativeFilename||i.Filename]=c}}}}for(const n in e){const s=e[n];t[s]!==void 0?e[n]=t[s]:e[n]=e[n].split("\\").pop()}return e}parseImage(e){const t=e.Content,n=e.RelativeFilename||e.Filename,s=n.slice(n.lastIndexOf(".")+1).toLowerCase();let i;switch(s){case"bmp":i="image/bmp";break;case"jpg":case"jpeg":i="image/jpeg";break;case"png":i="image/png";break;case"tif":i="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",n),i="image/tga";break;default:console.warn('FBXLoader: Image type "'+s+'" is not supported.');return}if(typeof t=="string")return"data:"+i+";base64,"+t;{const o=new Uint8Array(t);return window.URL.createObjectURL(new Blob([o],{type:i}))}}parseTextures(e){const t=new Map;if("Texture"in D.Objects){const n=D.Objects.Texture;for(const s in n){const i=this.parseTexture(n[s],e);t.set(parseInt(s),i)}}return t}parseTexture(e,t){const n=this.loadTexture(e,t);n.ID=e.id,n.name=e.attrName;const s=e.WrapModeU,i=e.WrapModeV,o=s!==void 0?s.value:0,r=i!==void 0?i.value:0;if(n.wrapS=o===0?nt:qt,n.wrapT=r===0?nt:qt,"Scaling"in e){const a=e.Scaling.value;n.repeat.x=a[0],n.repeat.y=a[1]}if("Translation"in e){const a=e.Translation.value;n.offset.x=a[0],n.offset.y=a[1]}return n}loadTexture(e,t){const n=new Set(["tga","tif","tiff","exr","dds","hdr","ktx2"]),s=e.FileName.split(".").pop().toLowerCase(),i=n.has(s)?this.manager.getHandler(`.${s}`):this.textureLoader;if(!i)return console.warn(`FBXLoader: ${s.toUpperCase()} loader not found, creating placeholder texture for`,e.RelativeFilename),new jt;const o=i.path;o||i.setPath(this.textureLoader.path);const r=K.get(e.id).children;let a;r!==void 0&&r.length>0&&t[r[0].ID]!==void 0&&(a=t[r[0].ID],(a.indexOf("blob:")===0||a.indexOf("data:")===0)&&i.setPath(void 0));const c=i.load(a);return i.setPath(o),c}parseMaterials(e){const t=new Map;if("Material"in D.Objects){const n=D.Objects.Material;for(const s in n){const i=this.parseMaterial(n[s],e);i!==null&&t.set(parseInt(s),i)}}return t}parseMaterial(e,t){const n=e.id,s=e.attrName;let i=e.ShadingModel;if(typeof i=="object"&&(i=i.value),!K.has(n))return null;const o=this.parseParameters(e,t,n);let r;switch(i.toLowerCase()){case"phong":r=new ht;break;case"lambert":r=new Ks;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',i),r=new ht;break}return r.setValues(o),r.name=s,r}parseParameters(e,t,n){const s={};e.BumpFactor&&(s.bumpScale=e.BumpFactor.value),e.Diffuse?s.color=ve.toWorkingColorSpace(new se().fromArray(e.Diffuse.value),ee):e.DiffuseColor&&(e.DiffuseColor.type==="Color"||e.DiffuseColor.type==="ColorRGB")&&(s.color=ve.toWorkingColorSpace(new se().fromArray(e.DiffuseColor.value),ee)),e.DisplacementFactor&&(s.displacementScale=e.DisplacementFactor.value),e.Emissive?s.emissive=ve.toWorkingColorSpace(new se().fromArray(e.Emissive.value),ee):e.EmissiveColor&&(e.EmissiveColor.type==="Color"||e.EmissiveColor.type==="ColorRGB")&&(s.emissive=ve.toWorkingColorSpace(new se().fromArray(e.EmissiveColor.value),ee)),e.EmissiveFactor&&(s.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),s.opacity=1-(e.TransparencyFactor?parseFloat(e.TransparencyFactor.value):0),(s.opacity===1||s.opacity===0)&&(s.opacity=e.Opacity?parseFloat(e.Opacity.value):null,s.opacity===null&&(s.opacity=1-(e.TransparentColor?parseFloat(e.TransparentColor.value[0]):0))),s.opacity<1&&(s.transparent=!0),e.ReflectionFactor&&(s.reflectivity=e.ReflectionFactor.value),e.Shininess&&(s.shininess=e.Shininess.value),e.Specular?s.specular=ve.toWorkingColorSpace(new se().fromArray(e.Specular.value),ee):e.SpecularColor&&e.SpecularColor.type==="Color"&&(s.specular=ve.toWorkingColorSpace(new se().fromArray(e.SpecularColor.value),ee));const i=this;return K.get(n).children.forEach(function(o){const r=o.relationship;switch(r){case"Bump":s.bumpMap=i.getTexture(t,o.ID);break;case"Maya|TEX_ao_map":s.aoMap=i.getTexture(t,o.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":s.map=i.getTexture(t,o.ID),s.map!==void 0&&(s.map.colorSpace=ee);break;case"DisplacementColor":s.displacementMap=i.getTexture(t,o.ID);break;case"EmissiveColor":s.emissiveMap=i.getTexture(t,o.ID),s.emissiveMap!==void 0&&(s.emissiveMap.colorSpace=ee);break;case"NormalMap":case"Maya|TEX_normal_map":s.normalMap=i.getTexture(t,o.ID);break;case"ReflectionColor":s.envMap=i.getTexture(t,o.ID),s.envMap!==void 0&&(s.envMap.mapping=Ys,s.envMap.colorSpace=ee);break;case"SpecularColor":s.specularMap=i.getTexture(t,o.ID),s.specularMap!==void 0&&(s.specularMap.colorSpace=ee);break;case"TransparentColor":case"TransparencyFactor":s.alphaMap=i.getTexture(t,o.ID),s.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",r);break}}),s}getTexture(e,t){return"LayeredTexture"in D.Objects&&t in D.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=K.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in D.Objects){const n=D.Objects.Deformer;for(const s in n){const i=n[s],o=K.get(parseInt(s));if(i.attrType==="Skin"){const r=this.parseSkeleton(o,n);r.ID=s,o.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),r.geometryID=o.parents[0].ID,e[s]=r}else if(i.attrType==="BlendShape"){const r={id:s};r.rawTargets=this.parseMorphTargets(o,n),r.id=s,o.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[s]=r}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const n=[];return e.children.forEach(function(s){const i=t[s.ID];if(i.attrType!=="Cluster")return;const o={ID:s.ID,indices:[],weights:[],transformLink:new W().fromArray(i.TransformLink.a)};"Indexes"in i&&(o.indices=i.Indexes.a,o.weights=i.Weights.a),n.push(o)}),{rawBones:n,bones:[]}}parseMorphTargets(e,t){const n=[];for(let s=0;s<e.children.length;s++){const i=e.children[s],o=t[i.ID],r={name:o.attrName,initialWeight:o.DeformPercent,id:o.id,fullWeights:o.FullWeights.a};if(o.attrType!=="BlendShapeChannel")return;r.geoID=K.get(parseInt(i.ID)).children.filter(function(a){return a.relationship===void 0})[0].ID,n.push(r)}return n}parseScene(e,t,n){ie=new Je;const s=this.parseModels(e.skeletons,t,n),i=D.Objects.Model,o=this;s.forEach(function(a){const c=i[a.ID];o.setLookAtProperties(a,c),K.get(a.ID).parents.forEach(function(l){const u=s.get(l.ID);u!==void 0&&u.add(a)}),a.parent===null&&ie.add(a)}),this.bindSkeleton(e.skeletons,t,s),this.addGlobalSceneSettings(),ie.traverse(function(a){if(a.userData.transformData){a.parent&&(a.userData.transformData.parentMatrix=a.parent.matrix,a.userData.transformData.parentMatrixWorld=a.parent.matrixWorld);const c=ys(a.userData.transformData);a.applyMatrix4(c),a.updateWorldMatrix()}});const r=new Xa().parse();ie.children.length===1&&ie.children[0].isGroup&&(ie.children[0].animations=r,ie=ie.children[0]),ie.animations=r}parseModels(e,t,n){const s=new Map,i=D.Objects.Model;for(const o in i){const r=parseInt(o),a=i[o],c=K.get(r);let h=this.buildSkeleton(c,e,r,a.attrName);if(!h){switch(a.attrType){case"Camera":h=this.createCamera(c);break;case"Light":h=this.createLight(c);break;case"Mesh":h=this.createMesh(c,t,n);break;case"NurbsCurve":h=this.createCurve(c,t);break;case"LimbNode":case"Root":h=new Ht;break;case"Null":default:h=new Je;break}h.name=a.attrName?st.sanitizeNodeName(a.attrName):"",h.userData.originalName=a.attrName,h.ID=r}this.getTransformData(h,a),s.set(r,h)}return s}buildSkeleton(e,t,n,s){let i=null;return e.parents.forEach(function(o){for(const r in t){const a=t[r];a.rawBones.forEach(function(c,h){if(c.ID===o.ID){const l=i;i=new Ht,i.matrixWorld.copy(c.transformLink),i.name=s?st.sanitizeNodeName(s):"",i.userData.originalName=s,i.ID=n,a.bones[h]=i,l!==null&&i.add(l)}})}}),i}createCamera(e){let t,n;if(e.children.forEach(function(s){const i=D.Objects.NodeAttribute[s.ID];i!==void 0&&(n=i)}),n===void 0)t=new je;else{let s=0;n.CameraProjectionType!==void 0&&n.CameraProjectionType.value===1&&(s=1);let i=1;n.NearPlane!==void 0&&(i=n.NearPlane.value/1e3);let o=1e3;n.FarPlane!==void 0&&(o=n.FarPlane.value/1e3);let r=window.innerWidth,a=window.innerHeight;n.AspectWidth!==void 0&&n.AspectHeight!==void 0&&(r=n.AspectWidth.value,a=n.AspectHeight.value);const c=r/a;let h=45;n.FieldOfView!==void 0&&(h=n.FieldOfView.value);const l=n.FocalLength?n.FocalLength.value:null;switch(s){case 0:t=new Un(h,c,i,o),l!==null&&t.setFocalLength(l);break;case 1:console.warn("THREE.FBXLoader: Orthographic cameras not supported yet."),t=new je;break;default:console.warn("THREE.FBXLoader: Unknown camera type "+s+"."),t=new je;break}}return t}createLight(e){let t,n;if(e.children.forEach(function(s){const i=D.Objects.NodeAttribute[s.ID];i!==void 0&&(n=i)}),n===void 0)t=new je;else{let s;n.LightType===void 0?s=0:s=n.LightType.value;let i=16777215;n.Color!==void 0&&(i=ve.toWorkingColorSpace(new se().fromArray(n.Color.value),ee));let o=n.Intensity===void 0?1:n.Intensity.value/100;n.CastLightOnObject!==void 0&&n.CastLightOnObject.value===0&&(o=0);let r=0;n.FarAttenuationEnd!==void 0&&(n.EnableFarAttenuation!==void 0&&n.EnableFarAttenuation.value===0?r=0:r=n.FarAttenuationEnd.value);const a=1;switch(s){case 0:t=new Dt(i,o,r,a);break;case 1:t=new kn(i,o);break;case 2:let c=Math.PI/3;n.InnerAngle!==void 0&&(c=ne.degToRad(n.InnerAngle.value));let h=0;n.OuterAngle!==void 0&&(h=ne.degToRad(n.OuterAngle.value),h=Math.max(h,1)),t=new zn(i,o,r,c,h,a);break;default:console.warn("THREE.FBXLoader: Unknown light type "+n.LightType.value+", defaulting to a PointLight."),t=new Dt(i,o);break}n.CastShadows!==void 0&&n.CastShadows.value===1&&(t.castShadow=!0)}return t}createMesh(e,t,n){let s,i=null,o=null;const r=[];if(e.children.forEach(function(a){t.has(a.ID)&&(i=t.get(a.ID)),n.has(a.ID)&&r.push(n.get(a.ID))}),r.length>1?o=r:r.length>0?o=r[0]:(o=new ht({name:vt.DEFAULT_MATERIAL_NAME,color:13421772}),r.push(o)),"color"in i.attributes&&r.forEach(function(a){a.vertexColors=!0}),i.groups.length>0){let a=!1;for(let c=0,h=i.groups.length;c<h;c++){const l=i.groups[c];(l.materialIndex<0||l.materialIndex>=r.length)&&(l.materialIndex=r.length,a=!0)}if(a){const c=new ht;r.push(c)}}return i.FBX_Deformer?(s=new jn(i,o),s.normalizeSkinWeights()):s=new Yt(i,o),s}createCurve(e,t){const n=e.children.reduce(function(i,o){return t.has(o.ID)&&(i=t.get(o.ID)),i},null),s=new qn({name:vt.DEFAULT_MATERIAL_NAME,color:3342591,linewidth:1});return new Vn(n,s)}getTransformData(e,t){const n={};"InheritType"in t&&(n.inheritType=parseInt(t.InheritType.value)),"RotationOrder"in t?n.eulerOrder=rt(t.RotationOrder.value):n.eulerOrder=rt(0),"Lcl_Translation"in t&&(n.translation=t.Lcl_Translation.value),"PreRotation"in t&&(n.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(n.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(n.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(n.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(n.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(n.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(n.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(n.rotationPivot=t.RotationPivot.value),e.userData.transformData=n}setLookAtProperties(e,t){"LookAtProperty"in t&&K.get(e.ID).children.forEach(function(s){if(s.relationship==="LookAtProperty"){const i=D.Objects.Model[s.ID];if("Lcl_Translation"in i){const o=i.Lcl_Translation.value;e.target!==void 0?(e.target.position.fromArray(o),ie.add(e.target)):e.lookAt(new Z().fromArray(o))}}})}bindSkeleton(e,t,n){const s=this.parsePoseNodes();for(const i in e){const o=e[i];K.get(parseInt(o.ID)).parents.forEach(function(a){if(t.has(a.ID)){const c=a.ID;K.get(c).parents.forEach(function(l){n.has(l.ID)&&n.get(l.ID).bind(new Wn(o.bones),s[l.ID])})}})}}parsePoseNodes(){const e={};if("Pose"in D.Objects){const t=D.Objects.Pose;for(const n in t)if(t[n].attrType==="BindPose"&&t[n].NbPoseNodes>0){const s=t[n].PoseNode;Array.isArray(s)?s.forEach(function(i){e[i.Node]=new W().fromArray(i.Matrix.a)}):e[s.Node]=new W().fromArray(s.Matrix.a)}}return e}addGlobalSceneSettings(){if("GlobalSettings"in D){if("AmbientColor"in D.GlobalSettings){const e=D.GlobalSettings.AmbientColor.value,t=e[0],n=e[1],s=e[2];if(t!==0||n!==0||s!==0){const i=new se().setRGB(t,n,s,ee);ie.add(new $s(i,1))}}"UnitScaleFactor"in D.GlobalSettings&&(ie.userData.unitScaleFactor=D.GlobalSettings.UnitScaleFactor.value)}}}class Wa{constructor(){this.negativeMaterialIndices=!1}parse(e){const t=new Map;if("Geometry"in D.Objects){const n=D.Objects.Geometry;for(const s in n){const i=K.get(parseInt(s)),o=this.parseGeometry(i,n[s],e);t.set(parseInt(s),o)}}return this.negativeMaterialIndices===!0&&console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),t}parseGeometry(e,t,n){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,n);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,n){const s=n.skeletons,i=[],o=e.parents.map(function(l){return D.Objects.Model[l.ID]});if(o.length===0)return;const r=e.children.reduce(function(l,u){return s[u.ID]!==void 0&&(l=s[u.ID]),l},null);e.children.forEach(function(l){n.morphTargets[l.ID]!==void 0&&i.push(n.morphTargets[l.ID])});const a=o[0],c={};"RotationOrder"in a&&(c.eulerOrder=rt(a.RotationOrder.value)),"InheritType"in a&&(c.inheritType=parseInt(a.InheritType.value)),"GeometricTranslation"in a&&(c.translation=a.GeometricTranslation.value),"GeometricRotation"in a&&(c.rotation=a.GeometricRotation.value),"GeometricScaling"in a&&(c.scale=a.GeometricScaling.value);const h=ys(c);return this.genGeometry(t,r,i,h)}genGeometry(e,t,n,s){const i=new yt;e.attrName&&(i.name=e.attrName);const o=this.parseGeoNode(e,t),r=this.genBuffers(o),a=new De(r.vertex,3);if(a.applyMatrix4(s),i.setAttribute("position",a),r.colors.length>0&&i.setAttribute("color",new De(r.colors,3)),t&&(i.setAttribute("skinIndex",new Zs(r.weightsIndices,4)),i.setAttribute("skinWeight",new De(r.vertexWeights,4)),i.FBX_Deformer=t),r.normal.length>0){const c=new Qs().getNormalMatrix(s),h=new De(r.normal,3);h.applyNormalMatrix(c),i.setAttribute("normal",h)}if(r.uvs.forEach(function(c,h){const l=h===0?"uv":`uv${h}`;i.setAttribute(l,new De(r.uvs[h],2))}),o.material&&o.material.mappingType!=="AllSame"){let c=r.materialIndex[0],h=0;if(r.materialIndex.forEach(function(l,u){l!==c&&(i.addGroup(h,u-h,c),c=l,h=u)}),i.groups.length>0){const l=i.groups[i.groups.length-1],u=l.start+l.count;u!==r.materialIndex.length&&i.addGroup(u,r.materialIndex.length-u,c)}i.groups.length===0&&i.addGroup(0,r.materialIndex.length,r.materialIndex[0])}return this.addMorphTargets(i,e,n,s),i}parseGeoNode(e,t){const n={};if(n.vertexPositions=e.Vertices!==void 0?e.Vertices.a:[],n.vertexIndices=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(n.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(n.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(n.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){n.uv=[];let s=0;for(;e.LayerElementUV[s];)e.LayerElementUV[s].UV&&n.uv.push(this.parseUVs(e.LayerElementUV[s])),s++}return n.weightTable={},t!==null&&(n.skeleton=t,t.rawBones.forEach(function(s,i){s.indices.forEach(function(o,r){n.weightTable[o]===void 0&&(n.weightTable[o]=[]),n.weightTable[o].push({id:i,weight:s.weights[r]})})})),n}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let n=0,s=0,i=!1,o=[],r=[],a=[],c=[],h=[],l=[];const u=this;return e.vertexIndices.forEach(function(p,m){let y,g=!1;p<0&&(p=p^-1,g=!0);let w=[],v=[];if(o.push(p*3,p*3+1,p*3+2),e.color){const x=gt(m,n,p,e.color);a.push(x[0],x[1],x[2])}if(e.skeleton){if(e.weightTable[p]!==void 0&&e.weightTable[p].forEach(function(x){v.push(x.weight),w.push(x.id)}),v.length>4){i||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),i=!0);const x=[0,0,0,0],A=[0,0,0,0];v.forEach(function(T,E){let M=T,C=w[E];A.forEach(function(N,P,L){if(M>N){L[P]=M,M=N;const k=x[P];x[P]=C,C=k}})}),w=x,v=A}for(;v.length<4;)v.push(0),w.push(0);for(let x=0;x<4;++x)h.push(v[x]),l.push(w[x])}if(e.normal){const x=gt(m,n,p,e.normal);r.push(x[0],x[1],x[2])}e.material&&e.material.mappingType!=="AllSame"&&(y=gt(m,n,p,e.material)[0],y<0&&(u.negativeMaterialIndices=!0,y=0)),e.uv&&e.uv.forEach(function(x,A){const T=gt(m,n,p,x);c[A]===void 0&&(c[A]=[]),c[A].push(T[0]),c[A].push(T[1])}),s++,g&&(u.genFace(t,e,o,y,r,a,c,h,l,s),n++,s=0,o=[],r=[],a=[],c=[],h=[],l=[])}),t}getNormalNewell(e){const t=new Z(0,0,0);for(let n=0;n<e.length;n++){const s=e[n],i=e[(n+1)%e.length];t.x+=(s.y-i.y)*(s.z+i.z),t.y+=(s.z-i.z)*(s.x+i.x),t.z+=(s.x-i.x)*(s.y+i.y)}return t.normalize(),t}getNormalTangentAndBitangent(e){const t=this.getNormalNewell(e),s=(Math.abs(t.z)>.5?new Z(0,1,0):new Z(0,0,1)).cross(t).normalize(),i=t.clone().cross(s).normalize();return{normal:t,tangent:s,bitangent:i}}flattenVertex(e,t,n){return new Zt(e.dot(t),e.dot(n))}genFace(e,t,n,s,i,o,r,a,c,h){let l;if(h>3){const u=[],p=t.baseVertexPositions||t.vertexPositions;for(let w=0;w<n.length;w+=3)u.push(new Z(p[n[w]],p[n[w+1]],p[n[w+2]]));const{tangent:m,bitangent:y}=this.getNormalTangentAndBitangent(u),g=[];for(const w of u)g.push(this.flattenVertex(w,m,y));l=Js.triangulateShape(g,[])}else l=[[0,1,2]];for(const[u,p,m]of l)e.vertex.push(t.vertexPositions[n[u*3]]),e.vertex.push(t.vertexPositions[n[u*3+1]]),e.vertex.push(t.vertexPositions[n[u*3+2]]),e.vertex.push(t.vertexPositions[n[p*3]]),e.vertex.push(t.vertexPositions[n[p*3+1]]),e.vertex.push(t.vertexPositions[n[p*3+2]]),e.vertex.push(t.vertexPositions[n[m*3]]),e.vertex.push(t.vertexPositions[n[m*3+1]]),e.vertex.push(t.vertexPositions[n[m*3+2]]),t.skeleton&&(e.vertexWeights.push(a[u*4]),e.vertexWeights.push(a[u*4+1]),e.vertexWeights.push(a[u*4+2]),e.vertexWeights.push(a[u*4+3]),e.vertexWeights.push(a[p*4]),e.vertexWeights.push(a[p*4+1]),e.vertexWeights.push(a[p*4+2]),e.vertexWeights.push(a[p*4+3]),e.vertexWeights.push(a[m*4]),e.vertexWeights.push(a[m*4+1]),e.vertexWeights.push(a[m*4+2]),e.vertexWeights.push(a[m*4+3]),e.weightsIndices.push(c[u*4]),e.weightsIndices.push(c[u*4+1]),e.weightsIndices.push(c[u*4+2]),e.weightsIndices.push(c[u*4+3]),e.weightsIndices.push(c[p*4]),e.weightsIndices.push(c[p*4+1]),e.weightsIndices.push(c[p*4+2]),e.weightsIndices.push(c[p*4+3]),e.weightsIndices.push(c[m*4]),e.weightsIndices.push(c[m*4+1]),e.weightsIndices.push(c[m*4+2]),e.weightsIndices.push(c[m*4+3])),t.color&&(e.colors.push(o[u*3]),e.colors.push(o[u*3+1]),e.colors.push(o[u*3+2]),e.colors.push(o[p*3]),e.colors.push(o[p*3+1]),e.colors.push(o[p*3+2]),e.colors.push(o[m*3]),e.colors.push(o[m*3+1]),e.colors.push(o[m*3+2])),t.material&&t.material.mappingType!=="AllSame"&&(e.materialIndex.push(s),e.materialIndex.push(s),e.materialIndex.push(s)),t.normal&&(e.normal.push(i[u*3]),e.normal.push(i[u*3+1]),e.normal.push(i[u*3+2]),e.normal.push(i[p*3]),e.normal.push(i[p*3+1]),e.normal.push(i[p*3+2]),e.normal.push(i[m*3]),e.normal.push(i[m*3+1]),e.normal.push(i[m*3+2])),t.uv&&t.uv.forEach(function(y,g){e.uvs[g]===void 0&&(e.uvs[g]=[]),e.uvs[g].push(r[g][u*2]),e.uvs[g].push(r[g][u*2+1]),e.uvs[g].push(r[g][p*2]),e.uvs[g].push(r[g][p*2+1]),e.uvs[g].push(r[g][m*2]),e.uvs[g].push(r[g][m*2+1])})}addMorphTargets(e,t,n,s){if(n.length===0)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const i=this;n.forEach(function(o){o.rawTargets.forEach(function(r){const a=D.Objects.Geometry[r.geoID];a!==void 0&&i.genMorphGeometry(e,t,a,s,r.name)})})}genMorphGeometry(e,t,n,s,i){const o=t.Vertices!==void 0?t.Vertices.a:[],r=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],a=n.Vertices!==void 0?n.Vertices.a:[],c=n.Indexes!==void 0?n.Indexes.a:[],h=e.attributes.position.count*3,l=new Float32Array(h);for(let y=0;y<c.length;y++){const g=c[y]*3;l[g]=a[y*3],l[g+1]=a[y*3+1],l[g+2]=a[y*3+2]}const u={vertexIndices:r,vertexPositions:l,baseVertexPositions:o},p=this.genBuffers(u),m=new De(p.vertex,3);m.name=i||n.attrName,m.applyMatrix4(s),e.morphAttributes.position.push(m)}parseNormals(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,s=e.Normals.a;let i=[];return n==="IndexToDirect"&&("NormalIndex"in e?i=e.NormalIndex.a:"NormalsIndex"in e&&(i=e.NormalsIndex.a)),{dataSize:3,buffer:s,indices:i,mappingType:t,referenceType:n}}parseUVs(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,s=e.UV.a;let i=[];return n==="IndexToDirect"&&(i=e.UVIndex.a),{dataSize:2,buffer:s,indices:i,mappingType:t,referenceType:n}}parseVertexColors(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,s=e.Colors.a;let i=[];n==="IndexToDirect"&&(i=e.ColorIndex.a);for(let o=0,r=new se;o<s.length;o+=4)r.fromArray(s,o),ve.toWorkingColorSpace(r,ee),r.toArray(s,o);return{dataSize:4,buffer:s,indices:i,mappingType:t,referenceType:n}}parseMaterialIndices(e){const t=e.MappingInformationType,n=e.ReferenceInformationType;if(t==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:n};const s=e.Materials.a,i=[];for(let o=0;o<s.length;++o)i.push(o);return{dataSize:1,buffer:s,indices:i,mappingType:t,referenceType:n}}parseNurbsGeometry(e){const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new yt;const n=t-1,s=e.KnotVector.a,i=[],o=e.Points.a;for(let l=0,u=o.length;l<u;l+=4)i.push(new it().fromArray(o,l));let r,a;if(e.Form==="Closed")i.push(i[0]);else if(e.Form==="Periodic"){r=n,a=s.length-1-r;for(let l=0;l<n;++l)i.push(i[l])}const h=new ja(n,s,i,r,a).getPoints(i.length*12);return new yt().setFromPoints(h)}}class Xa{parse(){const e=[],t=this.parseClips();if(t!==void 0)for(const n in t){const s=t[n],i=this.addClip(s);e.push(i)}return e}parseClips(){if(D.Objects.AnimationCurve===void 0)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=D.Objects.AnimationCurveNode,t=new Map;for(const n in e){const s=e[n];if(s.attrName.match(/S|R|T|DeformPercent/)!==null){const i={id:s.id,attr:s.attrName,curves:{}};t.set(i.id,i)}}return t}parseAnimationCurves(e){const t=D.Objects.AnimationCurve;for(const n in t){const s={id:t[n].id,times:t[n].KeyTime.a.map(Qa),values:t[n].KeyValueFloat.a},i=K.get(s.id);if(i!==void 0){const o=i.parents[0].ID,r=i.parents[0].relationship;r.match(/X/)?e.get(o).curves.x=s:r.match(/Y/)?e.get(o).curves.y=s:r.match(/Z/)?e.get(o).curves.z=s:r.match(/DeformPercent/)&&e.has(o)&&(e.get(o).curves.morph=s)}}}parseAnimationLayers(e){const t=D.Objects.AnimationLayer,n=new Map;for(const s in t){const i=[],o=K.get(parseInt(s));o!==void 0&&(o.children.forEach(function(a,c){if(e.has(a.ID)){const h=e.get(a.ID);if(h.curves.x!==void 0||h.curves.y!==void 0||h.curves.z!==void 0){if(i[c]===void 0){const l=K.get(a.ID).parents.filter(function(u){return u.relationship!==void 0})[0].ID;if(l!==void 0){const u=D.Objects.Model[l.toString()];if(u===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",a);return}const p={modelName:u.attrName?st.sanitizeNodeName(u.attrName):"",ID:u.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};ie.traverse(function(m){m.ID===u.id&&(p.transform=m.matrix,m.userData.transformData&&(p.eulerOrder=m.userData.transformData.eulerOrder))}),p.transform||(p.transform=new W),"PreRotation"in u&&(p.preRotation=u.PreRotation.value),"PostRotation"in u&&(p.postRotation=u.PostRotation.value),i[c]=p}}i[c]&&(i[c][h.attr]=h)}else if(h.curves.morph!==void 0){if(i[c]===void 0){const l=K.get(a.ID).parents.filter(function(w){return w.relationship!==void 0})[0].ID,u=K.get(l).parents[0].ID,p=K.get(u).parents[0].ID,m=K.get(p).parents[0].ID,y=D.Objects.Model[m],g={modelName:y.attrName?st.sanitizeNodeName(y.attrName):"",morphName:D.Objects.Deformer[l].attrName};i[c]=g}i[c][h.attr]=h}}}),n.set(parseInt(s),i))}return n}parseAnimStacks(e){const t=D.Objects.AnimationStack,n={};for(const s in t){const i=K.get(parseInt(s)).children;i.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const o=e.get(i[0].ID);n[s]={name:t[s].attrName,layer:o}}return n}addClip(e){let t=[];const n=this;return e.layer.forEach(function(s){t=t.concat(n.generateTracks(s))}),new Xn(e.name,-1,t)}generateTracks(e){const t=[];let n=new Z,s=new Z;if(e.transform&&e.transform.decompose(n,new ye,s),n=n.toArray(),s=s.toArray(),e.T!==void 0&&Object.keys(e.T.curves).length>0){const i=this.generateVectorTrack(e.modelName,e.T.curves,n,"position");i!==void 0&&t.push(i)}if(e.R!==void 0&&Object.keys(e.R.curves).length>0){const i=this.generateRotationTrack(e.modelName,e.R.curves,e.preRotation,e.postRotation,e.eulerOrder);i!==void 0&&t.push(i)}if(e.S!==void 0&&Object.keys(e.S.curves).length>0){const i=this.generateVectorTrack(e.modelName,e.S.curves,s,"scale");i!==void 0&&t.push(i)}if(e.DeformPercent!==void 0){const i=this.generateMorphTrack(e);i!==void 0&&t.push(i)}return t}generateVectorTrack(e,t,n,s){const i=this.getTimesForAllAxes(t),o=this.getKeyframeTrackValues(i,t,n);return new Vt(e+"."+s,i,o)}generateRotationTrack(e,t,n,s,i){let o,r;if(t.x!==void 0&&t.y!==void 0&&t.z!==void 0){const u=this.interpolateRotations(t.x,t.y,t.z,i);o=u[0],r=u[1]}const a=rt(0);n!==void 0&&(n=n.map(ne.degToRad),n.push(a),n=new Be().fromArray(n),n=new ye().setFromEuler(n)),s!==void 0&&(s=s.map(ne.degToRad),s.push(a),s=new Be().fromArray(s),s=new ye().setFromEuler(s).invert());const c=new ye,h=new Be,l=[];if(!r||!o)return new wt(e+".quaternion",[0],[0]);for(let u=0;u<r.length;u+=3)h.set(r[u],r[u+1],r[u+2],i),c.setFromEuler(h),n!==void 0&&c.premultiply(n),s!==void 0&&c.multiply(s),u>2&&new ye().fromArray(l,(u-3)/3*4).dot(c)<0&&c.set(-c.x,-c.y,-c.z,-c.w),c.toArray(l,u/3*4);return new wt(e+".quaternion",o,l)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,n=t.values.map(function(i){return i/100}),s=ie.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new Ut(e.modelName+".morphTargetInfluences["+s+"]",t.times,n)}getTimesForAllAxes(e){let t=[];if(e.x!==void 0&&(t=t.concat(e.x.times)),e.y!==void 0&&(t=t.concat(e.y.times)),e.z!==void 0&&(t=t.concat(e.z.times)),t=t.sort(function(n,s){return n-s}),t.length>1){let n=1,s=t[0];for(let i=1;i<t.length;i++){const o=t[i];o!==s&&(t[n]=o,s=o,n++)}t=t.slice(0,n)}return t}getKeyframeTrackValues(e,t,n){const s=n,i=[];let o=-1,r=-1,a=-1;return e.forEach(function(c){if(t.x&&(o=t.x.times.indexOf(c)),t.y&&(r=t.y.times.indexOf(c)),t.z&&(a=t.z.times.indexOf(c)),o!==-1){const h=t.x.values[o];i.push(h),s[0]=h}else i.push(s[0]);if(r!==-1){const h=t.y.values[r];i.push(h),s[1]=h}else i.push(s[1]);if(a!==-1){const h=t.z.values[a];i.push(h),s[2]=h}else i.push(s[2])}),i}interpolateRotations(e,t,n,s){const i=[],o=[];i.push(e.times[0]),o.push(ne.degToRad(e.values[0])),o.push(ne.degToRad(t.values[0])),o.push(ne.degToRad(n.values[0]));for(let r=1;r<e.values.length;r++){const a=[e.values[r-1],t.values[r-1],n.values[r-1]];if(isNaN(a[0])||isNaN(a[1])||isNaN(a[2]))continue;const c=a.map(ne.degToRad),h=[e.values[r],t.values[r],n.values[r]];if(isNaN(h[0])||isNaN(h[1])||isNaN(h[2]))continue;const l=h.map(ne.degToRad),u=[h[0]-a[0],h[1]-a[1],h[2]-a[2]],p=[Math.abs(u[0]),Math.abs(u[1]),Math.abs(u[2])];if(p[0]>=180||p[1]>=180||p[2]>=180){const y=Math.max(...p)/180,g=new Be(...c,s),w=new Be(...l,s),v=new ye().setFromEuler(g),x=new ye().setFromEuler(w);v.dot(x)&&x.set(-x.x,-x.y,-x.z,-x.w);const A=e.times[r-1],T=e.times[r]-A,E=new ye,M=new Be;for(let C=0;C<1;C+=1/y)E.copy(v.clone().slerp(x.clone(),C)),i.push(A+C*T),M.setFromQuaternion(E,s),o.push(M.x),o.push(M.y),o.push(M.z)}else i.push(e.times[r]),o.push(ne.degToRad(e.values[r])),o.push(ne.degToRad(t.values[r])),o.push(ne.degToRad(n.values[r]))}return[i,o]}}class Ka{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new gs,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,n=e.split(/[\r\n]+/);return n.forEach(function(s,i){const o=s.match(/^[\s\t]*;/),r=s.match(/^[\s\t]*$/);if(o||r)return;const a=s.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),c=s.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),h=s.match("^\\t{"+(t.currentIndent-1)+"}}");a?t.parseNodeBegin(s,a):c?t.parseNodeProperty(s,c,n[++i]):h?t.popStack():s.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(s)}),this.allNodes}parseNodeBegin(e,t){const n=t[1].trim().replace(/^"/,"").replace(/"$/,""),s=t[2].split(",").map(function(a){return a.trim().replace(/^"/,"").replace(/"$/,"")}),i={name:n},o=this.parseNodeAttr(s),r=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(n,i):n in r?(n==="PoseNode"?r.PoseNode.push(i):r[n].id!==void 0&&(r[n]={},r[n][r[n].id]=r[n]),o.id!==""&&(r[n][o.id]=i)):typeof o.id=="number"?(r[n]={},r[n][o.id]=i):n!=="Properties70"&&(n==="PoseNode"?r[n]=[i]:r[n]=i),typeof o.id=="number"&&(i.id=o.id),o.name!==""&&(i.attrName=o.name),o.type!==""&&(i.attrType=o.type),this.pushStack(i)}parseNodeAttr(e){let t=e[0];e[0]!==""&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let n="",s="";return e.length>1&&(n=e[1].replace(/^(\w+)::/,""),s=e[2]),{id:t,name:n,type:s}}parseNodeProperty(e,t,n){let s=t[1].replace(/^"/,"").replace(/"$/,"").trim(),i=t[2].replace(/^"/,"").replace(/"$/,"").trim();s==="Content"&&i===","&&(i=n.replace(/"/g,"").replace(/,$/,"").trim());const o=this.getCurrentNode();if(o.name==="Properties70"){this.parseNodeSpecialProperty(e,s,i);return}if(s==="C"){const a=i.split(",").slice(1),c=parseInt(a[0]),h=parseInt(a[1]);let l=i.split(",").slice(3);l=l.map(function(u){return u.trim().replace(/^"/,"")}),s="connections",i=[c,h],ec(i,l),o[s]===void 0&&(o[s]=[])}s==="Node"&&(o.id=i),s in o&&Array.isArray(o[s])?o[s].push(i):s!=="a"?o[s]=i:o.a=i,this.setCurrentProp(o,s),s==="a"&&i.slice(-1)!==","&&(o.a=kt(i))}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,e.slice(-1)!==","&&(t.a=kt(t.a))}parseNodeSpecialProperty(e,t,n){const s=n.split('",').map(function(h){return h.trim().replace(/^\"/,"").replace(/\s/,"_")}),i=s[0],o=s[1],r=s[2],a=s[3];let c=s[4];switch(o){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":c=parseFloat(c);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":c=kt(c);break}this.getPrevNode()[i]={type:o,type2:r,flag:a,value:c},this.setCurrentProp(this.getPrevNode(),i)}}class Ya{parse(e){const t=new _n(e);t.skip(23);const n=t.getUint32();if(n<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+n);const s=new gs;for(;!this.endOfContent(t);){const i=this.parseNode(t,n);i!==null&&s.add(i.name,i)}return s}endOfContent(e){return e.size()%16===0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const n={},s=t>=7500?e.getUint64():e.getUint32(),i=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const o=e.getUint8(),r=e.getString(o);if(s===0)return null;const a=[];for(let u=0;u<i;u++)a.push(this.parseProperty(e));const c=a.length>0?a[0]:"",h=a.length>1?a[1]:"",l=a.length>2?a[2]:"";for(n.singleProperty=i===1&&e.getOffset()===s;s>e.getOffset();){const u=this.parseNode(e,t);u!==null&&this.parseSubNode(r,n,u)}return n.propertyList=a,typeof c=="number"&&(n.id=c),h!==""&&(n.attrName=h),l!==""&&(n.attrType=l),r!==""&&(n.name=r),n}parseSubNode(e,t,n){if(n.singleProperty===!0){const s=n.propertyList[0];Array.isArray(s)?(t[n.name]=n,n.a=s):t[n.name]=s}else if(e==="Connections"&&n.name==="C"){const s=[];n.propertyList.forEach(function(i,o){o!==0&&s.push(i)}),t.connections===void 0&&(t.connections=[]),t.connections.push(s)}else if(n.name==="Properties70")Object.keys(n).forEach(function(i){t[i]=n[i]});else if(e==="Properties70"&&n.name==="P"){let s=n.propertyList[0],i=n.propertyList[1];const o=n.propertyList[2],r=n.propertyList[3];let a;s.indexOf("Lcl ")===0&&(s=s.replace("Lcl ","Lcl_")),i.indexOf("Lcl ")===0&&(i=i.replace("Lcl ","Lcl_")),i==="Color"||i==="ColorRGB"||i==="Vector"||i==="Vector3D"||i.indexOf("Lcl_")===0?a=[n.propertyList[4],n.propertyList[5],n.propertyList[6]]:a=n.propertyList[4],t[s]={type:i,type2:o,flag:r,value:a}}else t[n.name]===void 0?typeof n.id=="number"?(t[n.name]={},t[n.name][n.id]=n):t[n.name]=n:n.name==="PoseNode"?(Array.isArray(t[n.name])||(t[n.name]=[t[n.name]]),t[n.name].push(n)):t[n.name][n.id]===void 0&&(t[n.name][n.id]=n)}parseProperty(e){const t=e.getString(1);let n;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return n=e.getUint32(),e.getArrayBuffer(n);case"S":return n=e.getUint32(),e.getString(n);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const s=e.getUint32(),i=e.getUint32(),o=e.getUint32();if(i===0)switch(t){case"b":case"c":return e.getBooleanArray(s);case"d":return e.getFloat64Array(s);case"f":return e.getFloat32Array(s);case"i":return e.getInt32Array(s);case"l":return e.getInt64Array(s)}const r=_a(new Uint8Array(e.getArrayBuffer(o))),a=new _n(r.buffer);switch(t){case"b":case"c":return a.getBooleanArray(s);case"d":return a.getFloat64Array(s);case"f":return a.getFloat32Array(s);case"i":return a.getInt32Array(s);case"l":return a.getInt64Array(s)}break;default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class _n{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=t!==void 0?t:!0,this._textDecoder=new TextDecoder}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(e){const t=[];for(let n=0;n<e;n++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t&2147483648?(t=~t&4294967295,e=~e&4294967295,e===4294967295&&(t=t+1&4294967295),e=e+1&4294967295,-(t*4294967296+e)):t*4294967296+e}getInt64Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t*4294967296+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){const t=this.offset;let n=new Uint8Array(this.dv.buffer,t,e);this.skip(e);const s=n.indexOf(0);return s>=0&&(n=new Uint8Array(this.dv.buffer,t,s)),this._textDecoder.decode(n)}}class gs{add(e,t){this[e]=t}}function $a(f){const e="Kaydara FBX Binary  \0";return f.byteLength>=e.length&&e===vs(f,0,e.length)}function Za(f){const e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let t=0;function n(s){const i=f[s-1];return f=f.slice(t+s),t++,i}for(let s=0;s<e.length;++s)if(n(1)===e[s])return!1;return!0}function Nn(f){const e=/FBXVersion: (\d+)/,t=f.match(e);if(t)return parseInt(t[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function Qa(f){return f/46186158e3}const Ja=[];function gt(f,e,t,n){let s;switch(n.mappingType){case"ByPolygonVertex":s=f;break;case"ByPolygon":s=e;break;case"ByVertice":s=t;break;case"AllSame":s=n.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+n.mappingType)}n.referenceType==="IndexToDirect"&&(s=n.indices[s]);const i=s*n.dataSize,o=i+n.dataSize;return tc(Ja,n.buffer,i,o)}const zt=new Be,He=new Z;function ys(f){const e=new W,t=new W,n=new W,s=new W,i=new W,o=new W,r=new W,a=new W,c=new W,h=new W,l=new W,u=new W,p=f.inheritType?f.inheritType:0;f.translation&&e.setPosition(He.fromArray(f.translation));const m=rt(0);if(f.preRotation){const L=f.preRotation.map(ne.degToRad);L.push(m),t.makeRotationFromEuler(zt.fromArray(L))}if(f.rotation){const L=f.rotation.map(ne.degToRad);L.push(f.eulerOrder||m),n.makeRotationFromEuler(zt.fromArray(L))}if(f.postRotation){const L=f.postRotation.map(ne.degToRad);L.push(m),s.makeRotationFromEuler(zt.fromArray(L)),s.invert()}f.scale&&i.scale(He.fromArray(f.scale)),f.scalingOffset&&r.setPosition(He.fromArray(f.scalingOffset)),f.scalingPivot&&o.setPosition(He.fromArray(f.scalingPivot)),f.rotationOffset&&a.setPosition(He.fromArray(f.rotationOffset)),f.rotationPivot&&c.setPosition(He.fromArray(f.rotationPivot)),f.parentMatrixWorld&&(l.copy(f.parentMatrix),h.copy(f.parentMatrixWorld));const y=t.clone().multiply(n).multiply(s),g=new W;g.extractRotation(h);const w=new W;w.copyPosition(h);const v=w.clone().invert().multiply(h),x=g.clone().invert().multiply(v),A=i,T=new W;if(p===0)T.copy(g).multiply(y).multiply(x).multiply(A);else if(p===1)T.copy(g).multiply(x).multiply(y).multiply(A);else{const k=new W().scale(new Z().setFromMatrixScale(l)).clone().invert(),S=x.clone().multiply(k);T.copy(g).multiply(y).multiply(S).multiply(A)}const E=c.clone().invert(),M=o.clone().invert();let C=e.clone().multiply(a).multiply(c).multiply(t).multiply(n).multiply(s).multiply(E).multiply(r).multiply(o).multiply(i).multiply(M);const N=new W().copyPosition(C),P=h.clone().multiply(N);return u.copyPosition(P),C=u.clone().multiply(T),C.premultiply(h.invert()),C}function rt(f){f=f||0;const e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return f===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[f]}function kt(f){return f.split(",").map(function(t){return parseFloat(t)})}function vs(f,e,t){return e===void 0&&(e=0),t===void 0&&(t=f.byteLength),new TextDecoder().decode(new Uint8Array(f,e,t))}function ec(f,e){for(let t=0,n=f.length,s=e.length;t<s;t++,n++)f[n]=e[t]}function tc(f,e,t,n){for(let s=t,i=0;s<n;s++,i++)f[i]=e[s];return f}const nc=(f,e={})=>{const t=e.manager||new Yn,n=new Va(t);return n.setResourcePath(e.sourcePath?rs(e.sourcePath):f.split("/").slice(0,-1).join("/")+"/textures/"),new Promise((s,i)=>{const o=Date.now();n.load(f,r=>{const a=((Date.now()-o)/1e3).toFixed(1);console.log(` ${e.name||f} loaded in ${a}s`),s(r)},r=>{r.lengthComputable&&e.onProgress&&e.onProgress(r.loaded/r.total*100)},r=>{t.removeHandler(/.*/),i(new Error(`Failed to load ${f}: ${r.message}`))})})},sc=[{path:"whitebox.glb",name:"Box",loader:wa,options:{position:{x:15,y:0,z:0}}},{path:"TZ/model.fbx",name:"TZ",loader:nc,sourcePath:"TZ/tex/"}];(async()=>(ot.assets=await kr(sc),ot.initialize()))();
